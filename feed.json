{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Promise Li的博客",
  "home_page_url": "https://github.com/letme350/",
  "feed_url": "https://github.com/letme350/feed.json",
  "description": "白茶清欢无别事，我在等风也等你。清酒独酌了无趣，我在梦花也梦你。",
  "author": {
    "name": "Promise Li"
  },
  "items": [
    {
      "title": "CSS部分",
      "url": "https://github.com/letme350/css/css/",
      "id": "https://github.com/letme350/css/css/",
      "content_html": "<h1 id=\"css部分\"> CSS部分</h1>\n<h2 id=\"css面试\"> css面试</h2>\n<h3 id=\"_1-css-sprite是什么-有什么优缺点\"> 1.css sprite是什么,有什么优缺点</h3>\n<ul>\n<li>概念：将多个小图片拼接到一个图片中。通过<code>background-position</code>和元素尺寸调节需要显示的背景图案。</li>\n<li>优点：\n<ul>\n<li>减少<code>HTTP</code>请求数，极大地提高页面加载速度</li>\n<li>增加图片信息重复度，提高压缩比，减少图片大小</li>\n<li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>图片合并麻烦</li>\n<li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_2-display-none-与visibility-hidden-的区别\"> 2. <code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3>\n<ul>\n<li>联系：它们都能让元素不可见</li>\n<li>区别：\n<ul>\n<li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li>\n<li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示<code>；visibility: hidden;</code>是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>可以让子孙节点显式</li>\n<li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘。</li>\n<li>读屏器不会读取<code>display: none</code>;元素内容；会读取<code>visibility: hidden;</code>元素内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_3-link与-import的区别\"> 3. <code>link</code>与<code>@import</code>的区别</h3>\n<ol>\n<li><code>link</code>是<code>HTML</code>方式， <code>@import</code>是CSS方式</li>\n<li><code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<code>FOUC</code>(文档样式短暂失效)</li>\n<li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li>\n<li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li>\n<li><code>@import</code>必须在样式规则之前，可以在css文件中引用其他文件</li>\n<li>总体来说：<code>link</code>优于<code>@import</code></li>\n</ol>\n<h3 id=\"_4-什么是fouc-如何避免\"> 4. 什么是FOUC?如何避免</h3>\n<ul>\n<li><code>Flash Of Unstyled Content</code>：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。</li>\n<li><strong>解决方法</strong>：把样式表放到文档的<code>&lt;head&gt;</code></li>\n</ul>\n<h3 id=\"_5-如何创建块级格式化上下文-block-formatting-context-bfc有什么用\"> 5. 如何创建块级格式化上下文(block formatting context),BFC有什么用</h3>\n<blockquote>\n<p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响</p>\n</blockquote>\n<p><strong>触发条件 (以下任意一条)：</strong></p>\n<ul>\n<li><code>float</code>的值不为<code>none</code></li>\n<li><code>overflow</code>的值不为<code>visible</code></li>\n<li><code>display</code>的值为<code>table-cell</code>、<code>tabble-caption</code>和<code>inline-block</code>之一</li>\n<li><code>position</code>的值不为<code>static</code>或则<code>releative</code>中的任何一个</li>\n</ul>\n<blockquote>\n<p>在<code>IE</code>下, <code>Layout</code>,可通过<code>zoom:1</code> 触发</p>\n</blockquote>\n<p><strong>.BFC布局与普通文档流布局区别 普通文档流布局:</strong></p>\n<ul>\n<li>浮动的元素是不会被父级计算高度</li>\n<li>非浮动元素会覆盖浮动元素的位置</li>\n<li><code>margin</code>会传递给父级元素</li>\n<li>两个相邻元素上下的<code>margin</code>会重叠</li>\n</ul>\n<p><strong>BFC布局规则:</strong></p>\n<ul>\n<li>浮动的元素会被父级计算高度(父级元素触发了<code>BFC</code>)</li>\n<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了<code>BFC</code>)</li>\n<li><code>margin</code>不会传递给父级(父级触发<code>BFC</code>)</li>\n<li>属于同一个<code>BFC</code>的两个相邻元素上下<code>margin</code>会重叠</li>\n</ul>\n<p><strong>开发中的应用：</strong></p>\n<ul>\n<li>阻止<code>margin</code>重叠</li>\n<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 <code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li>\n<li>自适应两栏布局</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ul>\n<h3 id=\"_6-display、float、position的关系\"> 6. display、float、position的关系</h3>\n<ul>\n<li>如果<code>display</code>取值为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</li>\n<li>否则，如果<code>position</code>取值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整。</li>\n<li>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</li>\n<li>否则，如果元素是根元素，<code>display</code>根据下表进行调整</li>\n<li>其他情况下<code>display</code>的值为指定值</li>\n<li>总结起来：<strong>绝对定位、浮动、根元素都需要调整<code>display</code></strong></li>\n</ul>\n<h3 id=\"_7-清除浮动的几种方式-各自的优缺点\"> 7. 清除浮动的几种方式，各自的优缺点</h3>\n<ul>\n<li>父级<code>div</code>定义<code>height</code></li>\n<li>结尾处加空<code>div</code>标签<code>clear:both</code></li>\n<li>父级<code>div</code>定义伪类<code>:after</code>和<code>zoom</code></li>\n<li>父级<code>div</code>定义<code>overflow:hidden</code></li>\n<li>父级<code>div</code>也浮动，需要定义宽度</li>\n<li>结尾处加<code>br</code>标签<code>clear:both</code></li>\n<li>比较好的是第3种方式，好多网站都这么用</li>\n</ul>\n<h3 id=\"_8-为什么要初始化css样式\"> 8. 为什么要初始化CSS样式?</h3>\n<ul>\n<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对<code>CSS</code>初始化往往会出现浏览器之间的页面显示差异。</li>\n<li>当然，初始化样式会对<code>SEO</code>有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</li>\n</ul>\n<h3 id=\"_9-css3有哪些新特性\"> 9. css3有哪些新特性</h3>\n<ul>\n<li>新增选择器 <code>p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</code></li>\n<li>弹性盒模型 <code>display: flex;</code></li>\n<li>多列布局 <code>column-count: 5;</code></li>\n<li>媒体查询 <code>@media (max-width: 480px) {.box: {column-count: 1;}}</code></li>\n<li>个性化字体 <code>@font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</code></li>\n<li>颜色透明度 <code>color: rgba(255, 0, 0, 0.75);</code></li>\n<li>圆角 <code>border-radius: 5px;</code></li>\n<li>渐变 <code>background:linear-gradient(red, green, blue);</code></li>\n<li>阴影 <code>box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</code></li>\n<li>倒影 <code>box-reflect: below 2px;</code></li>\n<li>文字装饰 <code>text-stroke-color: red;</code></li>\n<li>文字溢出 <code>text-overflow:ellipsis;</code></li>\n<li>背景效果 <code>background-size: 100px 100px;</code></li>\n<li>边框效果 <code>border-image:url(bt_blue.png) 0 10;</code></li>\n<li>转换\n<ul>\n<li>旋转 <code>transform: rotate(20deg);</code></li>\n<li>倾斜 <code>transform: skew(150deg, -10deg);</code></li>\n<li>位移 <code>transform: translate(20px, 20px);</code></li>\n<li>缩放 <code>transform: scale(.5);</code></li>\n</ul>\n</li>\n<li>平滑过渡 <code>transition: all .3s ease-in .1s;</code></li>\n<li>动画 <code>@keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</code></li>\n</ul>\n<p><strong>CSS3新增伪类有那些？</strong></p>\n<ul>\n<li><code>p:first-of-type</code> 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code> 元素。</li>\n<li><code>p:last-of-type</code> 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素。</li>\n<li><code>p:only-of-type</code> 选择属于其父元素唯一的 <code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。</li>\n<li><code>p:only-child</code> 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li>\n<li><code>p:nth-child(2)</code> 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li>\n<li><code>:after</code> 在元素之前添加内容,也可以用来做清除浮动。</li>\n<li><code>:before</code> 在元素之后添加内容。</li>\n<li><code>:enabled</code> 已启用的表单元素。</li>\n<li><code>:disabled</code> 已禁用的表单元素。</li>\n<li><code>:checked</code> 单选框或复选框被选中。</li>\n</ul>\n<h3 id=\"_10-display有哪些值-说明他们的作用\"> 10. display有哪些值？说明他们的作用</h3>\n<ul>\n<li><code>block</code> 转换成块状元素。</li>\n<li><code>inline</code> 转换成行内元素。</li>\n<li><code>none</code> 设置元素不可见。</li>\n<li><code>inline-block</code> 象行内元素一样显示，但其内容象块类型元素一样显示。</li>\n<li><code>list-item</code> 象块类型元素一样显示，并添加样式列表标记。</li>\n<li><code>table</code> 此元素会作为块级表格来显示</li>\n<li><code>inherit</code> 规定应该从父元素继承 <code>display</code> 属性的值</li>\n</ul>\n<h3 id=\"_11-介绍一下标准的css的盒子模型-低版本ie的盒子模型有什么不同的\"> 11. 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3>\n<blockquote>\n<ul>\n<li>有两种， <code>IE</code>盒子模型、<code>W3C</code>盒子模型；</li>\n<li>盒模型： 内容(content)、填充(<code>padding</code>)、边界(<code>margin</code>)、 边框(<code>border</code>)；</li>\n<li>区 别： <code>IE</code>的c<code>ontent</code>部分把 <code>border</code> 和 <code>padding</code>计算了进去;</li>\n</ul>\n</blockquote>\n<ul>\n<li>盒子模型构成：内容(<code>content</code>)、内填充(<code>padding</code>)、 边框(<code>border</code>)、外边距(<code>margin</code>)</li>\n<li><code>IE8</code>及其以下版本浏览器，未声明 <code>DOCTYPE</code>，内容宽高会包含内填充和边框，称为怪异盒模型(<code>IE</code>盒模型)</li>\n<li>标准(<code>W3C</code>)盒模型：元素宽度 = <code>width + padding + border + margin</code></li>\n<li>怪异(<code>IE</code>)盒模型：元素宽度 = <code>width + margin</code></li>\n<li>标准浏览器通过设置 css3 的 <code>box-sizing: border-box</code> 属性，触发“怪异模式”解析计算宽高</li>\n</ul>\n<p><strong>box-sizing 常用的属性有哪些？分别有什么作用？</strong></p>\n<ul>\n<li><code>box-sizing: content-box;</code> 默认的标准(W3C)盒模型元素效果</li>\n<li><code>box-sizing: border-box;</code> 触发怪异(IE)盒模型元素的效果</li>\n<li><code>box-sizing: inherit;</code> 继承父元素 <code>box-sizing</code> 属性的值</li>\n</ul>\n<h3 id=\"_12-css优先级算法如何计算\"> 12. CSS优先级算法如何计算？</h3>\n<ul>\n<li>优先级就近原则，同权重情况下样式定义最近者为准</li>\n<li>载入样式以最后载入的定位为准</li>\n<li>优先级为: <code>!important &gt; id &gt; class &gt; tag</code>; <code>!important</code> 比 内联优先级高</li>\n</ul>\n<h3 id=\"_13-对bfc规范的理解\"> 13. 对BFC规范的理解？</h3>\n<ul>\n<li>一个页面是由很多个 <code>Box</code> 组成的,元素的类型和 <code>d</code>isplay` 属性,决定了这个 Box 的类型</li>\n<li>不同类型的 <code>Box</code>,会参与不同的 <code>Formatting Context</code>（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li>\n</ul>\n<h3 id=\"_14-谈谈浮动和清除浮动\"> 14. 谈谈浮动和清除浮动</h3>\n<ul>\n<li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li>\n</ul>\n<h3 id=\"_15-position的值-relative和absolute定位原点是\"> 15. position的值， relative和absolute定位原点是</h3>\n<ul>\n<li><code>absolute</code>：生成绝对定位的元素，相对于 <code>static</code> 定位以外的第一个父元素进行定位</li>\n<li><code>fixed</code>：生成绝对定位的元素，相对于浏览器窗口进行定位</li>\n<li><code>relative</code>：生成相对定位的元素，相对于其正常位置进行定位</li>\n<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>\n<li><code>inherit</code> 规定从父元素继承 <code>position</code> 属性的值</li>\n</ul>\n<h3 id=\"_16-display-inline-block-什么时候不会显示间隙-携程\"> 16. display:inline-block 什么时候不会显示间隙？(携程)</h3>\n<ul>\n<li>移除空格</li>\n<li>使用<code>margin</code>负值</li>\n<li>使用<code>font-size:0</code></li>\n<li><code>letter-spacing</code></li>\n<li><code>word-spacing</code></li>\n</ul>\n<h3 id=\"_17-png-gif-jpg的区别及如何选\"> 17. PNG\\GIF\\JPG的区别及如何选</h3>\n<ul>\n<li><code>GIF</code>\n<ul>\n<li><code>8</code>位像素，<code>256</code>色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持<code>boolean</code>透明</li>\n<li>适合简单动画</li>\n</ul>\n</li>\n<li><code>JPEG</code>\n<ul>\n<li>颜色限于<code>256</code></li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n</li>\n<li><code>PNG</code>\n<ul>\n<li>有<code>PNG8</code>和<code>truecolor PNG</code></li>\n<li><code>PNG8</code>类似<code>GIF</code>颜色上限为<code>256</code>，文件小，支持<code>alpha</code>透明度，无动画</li>\n<li>适合图标、背景、按钮</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_18-行内元素float-left后是否变为块级元素\"> 18. 行内元素float:left后是否变为块级元素？</h3>\n<blockquote>\n<p>行内元素设置成浮动之后变得更加像是<code>inline-block</code>（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是<code>100%</code>），这时候给行内元素设置<code>padding-top</code>和<code>padding-bottom</code>或者<code>width</code>、<code>height</code>都是有效果的</p>\n</blockquote>\n<h3 id=\"_19-在网页中的应该使用奇数还是偶数的字体-为什么呢\"> 19. 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h3>\n<ul>\n<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li>\n</ul>\n<h3 id=\"_20-before-和-after中双冒号和单冒号-有什么区别-解释一下这2个伪元素的作用\"> 20. ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3>\n<ul>\n<li>单冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素</li>\n<li>用于区分伪类和伪元素</li>\n</ul>\n<h3 id=\"_21-如果需要手动写动画-你认为最小时间间隔是多久-为什么-阿里\"> 21. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3>\n<ul>\n<li>多数显示器默认频率是<code>60Hz</code>，即<code>1</code>秒刷新<code>60</code>次，所以理论上最小间隔为<code>1/60*1000ms ＝ 16.7ms</code></li>\n</ul>\n<h3 id=\"_22-css合并方法\"> 22. CSS合并方法</h3>\n<ul>\n<li>避免使用<code>@import</code>引入多个<code>css</code>文件，可以使用<code>CSS</code>工具将<code>CSS</code>合并为一个<code>CSS</code>文件，例如使用<code>Sass\\Compass</code>等</li>\n</ul>\n<h3 id=\"_23-css不同选择器的权重-css层叠的规则\"> 23. CSS不同选择器的权重(CSS层叠的规则)</h3>\n<ul>\n<li><code>！important</code>规则最重要，大于其它规则</li>\n<li>行内样式规则，加<code>1000</code></li>\n<li>对于选择器中给定的各个<code>ID</code>属性值，加<code>100</code></li>\n<li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加<code>10</code></li>\n<li>对于选择其中给定的各个元素标签选择器，加1</li>\n<li>如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则</li>\n</ul>\n<blockquote>\n<p>以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：</p>\n</blockquote>\n<div><pre><code><span>/*权重为1*/</span>\n<span>div</span><span>{</span>\n<span>}</span>\n<span>/*权重为10*/</span>\n<span>.class1</span><span>{</span>\n<span>}</span>\n<span>/*权重为100*/</span>\n<span>#id1</span><span>{</span>\n<span>}</span>\n<span>/*权重为100+1=101*/</span>\n<span>#id1 div</span><span>{</span>\n<span>}</span>\n<span>/*权重为10+1=11*/</span>\n<span>.class1 div</span><span>{</span>\n<span>}</span>\n<span>/*权重为10+10+1=21*/</span>\n<span>.class1 .class2 div</span><span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>\n<p>如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</p>\n</blockquote>\n<h3 id=\"_24-列出你所知道可以改变页面布局的属性\"> 24. 列出你所知道可以改变页面布局的属性</h3>\n<ul>\n<li><code>position</code>、<code>display</code>、<code>float</code>、<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>top</code>、<code>left</code>、<code>right</code>、`</li>\n</ul>\n<h3 id=\"_25-在性能优化方面的实践-25-css在性能优化方面的实践\"> 25. 在性能优化方面的实践)25 CSS在性能优化方面的实践</h3>\n<ul>\n<li><code>css</code>压缩与合并、<code>Gzip</code>压缩</li>\n<li><code>css</code>文件放在<code>head</code>里、不要用<code>@import</code></li>\n<li>尽量用缩写、避免用滤镜、合理使用选择器</li>\n</ul>\n<h3 id=\"_26-css3动画-简单动画的实现-如旋转等\"> 26. CSS3动画（简单动画的实现，如旋转等）</h3>\n<ul>\n<li>依靠<code>CSS3</code>中提出的三个属性：<code>transition</code>、<code>transform</code>、<code>animation</code></li>\n<li><code>transition</code>：定义了元素在变化过程中是怎么样的，包含<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code>。</li>\n<li><code>transform</code>：定义元素的变化结果，包含<code>rotate</code>、<code>scale</code>、<code>skew</code>、<code>translate</code>。</li>\n<li><code>animation</code>：动画定义了动作的每一帧（<code>@keyframes</code>）有什么效果，包括<code>animation-name</code>，<code>animation-duration</code>、<code>animation-timing-function</code>、<code>animation-delay</code>、<code>animation-iteration-count</code>、<code>animation-direction</code></li>\n</ul>\n<h3 id=\"_27-base64的原理及优缺点\"> 27. base64的原理及优缺点</h3>\n<ul>\n<li>优点可以加密，减少了<code>HTTTP</code>请求</li>\n<li>缺点是需要消耗<code>CPU</code>进行编解码</li>\n</ul>\n<h3 id=\"_28-几种常见的css布局\"> 28. 几种常见的CSS布局</h3>\n<h4 id=\"流体布局\"> 流体布局</h4>\n<div><pre><code><span>.left</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> 100px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background</span><span>:</span> red<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>float</span><span>:</span> right<span>;</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background</span><span>:</span> blue<span>;</span>\n<span>}</span>\n<span>.main</span> <span>{</span>\n  <span>margin-left</span><span>:</span> 120px<span>;</span>\n  <span>margin-right</span><span>:</span> 220px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background</span><span>:</span> green<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>main<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"圣杯布局\"> 圣杯布局</h4>\n<p>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽</p>\n<ul>\n<li>好处：重要的内容放在文档流前面可以优先渲染</li>\n<li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li>\n</ul>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>padding-left</span><span>:</span> 150px<span>;</span>\n  <span>padding-right</span><span>:</span> 190px<span>;</span>\n<span>}</span>\n<span>.main</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> 190px<span>;</span>\n  <span>margin-left</span><span>:</span> -100%<span>;</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>left</span><span>:</span> -150px<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> 190px<span>;</span>\n  <span>margin-left</span><span>:</span> -190px<span>;</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>right</span><span>:</span> -190px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>main<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"双飞翼布局\"> 双飞翼布局</h4>\n<ul>\n<li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li>\n<li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li>\n</ul>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>/*padding-left:150px;*/</span>\n  <span>/*padding-right:190px;*/</span>\n<span>}</span>\n<span>.main-wrap</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n<span>.main</span> <span>{</span>\n  <span>margin-left</span><span>:</span> 150px<span>;</span>\n  <span>margin-right</span><span>:</span> 190px<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> 150px<span>;</span>\n  <span>margin-left</span><span>:</span> -100%<span>;</span>\n  <span>/*position: relative;*/</span>\n  <span>/*left:-150px;*/</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>float</span><span>:</span> left<span>;</span>\n  <span>width</span><span>:</span> 190px<span>;</span>\n  <span>margin-left</span><span>:</span> -190px<span>;</span>\n  <span>/*position:relative;*/</span>\n  <span>/*right:-190px;*/</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>content<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>main<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_29-stylus-sass-less区别\"> 29. stylus/sass/less区别</h3>\n<ul>\n<li>均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性</li>\n<li><code>Scss</code>和<code>LESS</code>语法较为严谨，<code>LESS</code>要求一定要使用大括号“{}”，<code>Scss</code>和<code>Stylus</code>可以通过缩进表示层次与嵌套关系</li>\n<li><code>Scss</code>无全局变量的概念，<code>LESS</code>和<code>Stylus</code>有类似于其它语言的作用域概念</li>\n<li><code>Sass</code>是基于<code>Ruby</code>语言的，而<code>LESS</code>和<code>Stylus</code>可以基于<code>NodeJS</code> <code>NPM</code>下载相应库后进行编译；</li>\n</ul>\n<h3 id=\"_30-postcss的作用\"> 30. postcss的作用</h3>\n<ul>\n<li>可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大</li>\n<li><code>PostCSS</code> 提供了一个解析器，它能够将 <code>CSS</code> 解析成抽象语法树</li>\n<li>通过在 <code>PostCSS</code> 这个平台上，我们能够开发一些插件，来处理我们的<code>CSS</code>，比如热门的：<code>autoprefixer</code></li>\n<li><code>postcss</code>可以对sass处理过后的<code>css</code>再处理 最常见的就是<code>autoprefixer</code></li>\n</ul>\n<h3 id=\"_31-css样式-选择器-的优先级\"> 31. css样式（选择器）的优先级</h3>\n<ul>\n<li>计算权重确定</li>\n<li><code>!important</code></li>\n<li>内联样式</li>\n<li>后写的优先级高</li>\n</ul>\n<h3 id=\"_32-自定义字体的使用场景\"> 32. 自定义字体的使用场景</h3>\n<ul>\n<li>宣传/品牌/<code>banner</code>等固定文案</li>\n<li>字体图标</li>\n</ul>\n<h3 id=\"_33-如何美化checkbox\"> 33. 如何美化CheckBox</h3>\n<ul>\n<li><code>&lt;label&gt;</code> 属性 <code>for</code> 和 <code>id</code></li>\n<li>隐藏原生的 <code>&lt;input&gt;</code></li>\n<li><code>:checked + &lt;label&gt;</code></li>\n</ul>\n<h3 id=\"_34-伪类和伪元素的区别\"> 34. 伪类和伪元素的区别</h3>\n<ul>\n<li>伪类表状态</li>\n<li>伪元素是真的有元素</li>\n<li>前者单冒号，后者双冒号</li>\n</ul>\n<h3 id=\"_35-base64的使用\"> 35. <code>base64</code>的使用</h3>\n<ul>\n<li>用于减少 <code>HTTP</code> 请求</li>\n<li>适用于小图片</li>\n<li><code>base64</code>的体积约为原图的<code>4/3</code></li>\n</ul>\n<h3 id=\"_36-自适应布局\"> 36. 自适应布局</h3>\n<p>思路：</p>\n<ul>\n<li>左侧浮动或者绝对定位，然后右侧<code>margin</code>撑开</li>\n<li>使用<code>&lt;div&gt;</code>包含，然后靠负<code>margin</code>形成<code>bfc</code></li>\n<li>使用<code>flex</code></li>\n</ul>\n<h3 id=\"_37-请用css写一个简单的幻灯片效果页面\"> 37. 请用CSS写一个简单的幻灯片效果页面</h3>\n<blockquote>\n<p>知道是要用<code>CSS3</code>。使用<code>animation</code>动画实现一个简单的幻灯片效果</p>\n</blockquote>\n<div><pre><code><span>/**css**/</span>\n<span>.ani</span><span>{</span>\n  <span>width</span><span>:</span>480px<span>;</span>\n  <span>height</span><span>:</span>320px<span>;</span>\n  <span>margin</span><span>:</span>50px auto<span>;</span>\n  <span>overflow</span><span>:</span> hidden<span>;</span>\n  <span>box-shadow</span><span>:</span>0 0 5px <span>rgba</span><span>(</span>0<span>,</span>0<span>,</span>0<span>,</span>1<span>)</span><span>;</span>\n  <span>background-size</span><span>:</span> cover<span>;</span>\n  <span>background-position</span><span>:</span> center<span>;</span>\n  <span>-webkit-animation-name</span><span>:</span> <span>\"loops\"</span><span>;</span>\n  <span>-webkit-animation-duration</span><span>:</span> 20s<span>;</span>\n  <span>-webkit-animation-iteration-count</span><span>:</span> infinite<span>;</span>\n<span>}</span>\n<span><span>@-webkit-keyframes</span> <span>\"loops\"</span></span> <span>{</span>\n  <span>0%</span> <span>{</span>\n    <span>background</span><span>:</span><span><span>url</span><span>(</span>http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg<span>)</span></span> no-repeat<span>;</span>             \n  <span>}</span>\n  <span>25%</span> <span>{</span>\n    <span>background</span><span>:</span><span><span>url</span><span>(</span>http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg<span>)</span></span> no-repeat<span>;</span>\n  <span>}</span>\n  <span>50%</span> <span>{</span>\n    <span>background</span><span>:</span><span><span>url</span><span>(</span>http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg<span>)</span></span> no-repeat<span>;</span>\n  <span>}</span>\n  <span>75%</span> <span>{</span>\n    <span>background</span><span>:</span><span><span>url</span><span>(</span>http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg<span>)</span></span> no-repeat<span>;</span>\n  <span>}</span>\n  <span>100%</span> <span>{</span>\n    <span>background</span><span>:</span><span><span>url</span><span>(</span>http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg<span>)</span></span> no-repeat<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id=\"_38-什么是外边距重叠-重叠的结果是什么\"> 38. 什么是外边距重叠？重叠的结果是什么？</h3>\n<blockquote>\n<p>外边距重叠就是margin-collapse</p>\n</blockquote>\n<ul>\n<li>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</li>\n</ul>\n<p><strong>折叠结果遵循下列计算规则</strong>：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>\n</ul>\n<h3 id=\"_39-rgba-和opacity的透明效果有什么不同\"> 39. rgba()和opacity的透明效果有什么不同？</h3>\n<ul>\n<li><code>rgba()</code>和<code>opacity</code>都能实现透明效果，但最大的不同是<code>opacity</code>作用于元素，以及元素内的所有内容的透明度，</li>\n<li>而<code>rgba()</code>只作用于元素的颜色或其背景色。（设置<code>rgba</code>透明的元素的子元素不会继承透明效果！）</li>\n</ul>\n<h3 id=\"_40-css中可以让文字在垂直和水平方向上重叠的两个属性是什么\"> 40. css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3>\n<ul>\n<li>垂直方向：<code>line-height</code></li>\n<li>水平方向：<code>letter-spacing</code></li>\n</ul>\n<h3 id=\"_41-如何垂直居中一个浮动元素\"> 41. 如何垂直居中一个浮动元素？</h3>\n<div><pre><code><span>/**方法一：已知元素的高宽**/</span>\n\n<span>#div1</span><span>{</span>\n  <span>background-color</span><span>:</span>#6699FF<span>;</span>\n  <span>width</span><span>:</span>200px<span>;</span>\n  <span>height</span><span>:</span>200px<span>;</span>\n  <span>position</span><span>:</span> absolute<span>;</span>        //父元素需要相对定位\n  <span>top</span><span>:</span> 50%<span>;</span>\n  <span>left</span><span>:</span> 50%<span>;</span>\n  <span>margin-top</span><span>:</span>-100px <span>;</span>   //二分之一的height，width\n  <span>margin-left</span><span>:</span> -100px<span>;</span>\n<span>}</span>\n\n<span>/**方法二:**/</span>\n\n<span>#div1</span><span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> #6699FF<span>;</span>\n  <span>margin</span><span>:</span>auto<span>;</span>\n  <span>position</span><span>:</span> absolute<span>;</span>        //父元素需要相对定位\n  <span>left</span><span>:</span> 0<span>;</span>\n  <span>top</span><span>:</span> 0<span>;</span>\n  <span>right</span><span>:</span> 0<span>;</span>\n  <span>bottom</span><span>:</span> 0<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>如何垂直居中一个<code>&lt;img&gt;</code>?（用更简便的方法。）</strong></p>\n<div><pre><code>#container     <span>/**&lt;img>的容器设置如下**/</span>\n<span>{</span>\n  <span>display</span><span>:</span>table-cell<span>;</span>\n  <span>text-align</span><span>:</span>center<span>;</span>\n  <span>vertical-align</span><span>:</span>middle<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_42-px和em的区别\"> 42. px和em的区别</h3>\n<ul>\n<li><code>px</code>和<code>em</code>都是长度单位，区别是，<code>px</code>的值是固定的，指定是多少就是多少，计算比较容易。<code>em</code>得值不是固定的，并且<code>em</code>会继承父级元素的字体大小。</li>\n<li>浏览器的默认字体高都是<code>16px</code>。所以未经调整的浏览器都符合: <code>1em=16px</code>。那么<code>12px=0.75em</code>, <code>10px=0.625em</code>。</li>\n</ul>\n<blockquote>\n<ul>\n<li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li>\n<li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li>\n</ul>\n</blockquote>\n<h3 id=\"_43-sass、less是什么-大家为什么要使用他们\"> 43. Sass、LESS是什么？大家为什么要使用他们？</h3>\n<ul>\n<li>他们是<code>CSS</code>预处理器。他是<code>CSS</code>上的一种抽象层。他们是一种特殊的语法/语言编译成<code>CSS</code>。</li>\n<li>例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. <code>LESS</code> 既可以在客户端上运行 (支持<code>IE 6+</code>, <code>Webkit</code>, <code>Firefox</code>)，也可一在服务端运行 (借助 <code>Node.js</code>)</li>\n</ul>\n<p><strong>为什么要使用它们？</strong></p>\n<ul>\n<li>结构清晰，便于扩展。</li>\n<li>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。</li>\n<li>可以轻松实现多重继承。</li>\n<li>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译</li>\n</ul>\n<h3 id=\"_44-知道css有个content属性吗-有什么作用-有什么应用\"> 44. 知道css有个content属性吗？有什么作用？有什么应用？</h3>\n<blockquote>\n<p>css的<code>content</code>属性专门应用在 <code>before/after</code>伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。</p>\n</blockquote>\n<div><pre><code><span>/**一种常见利用伪类清除浮动的代码**/</span>\n<span>.clearfix:after</span> <span>{</span>\n  <span>content</span><span>:</span><span>\".\"</span><span>;</span>       //这里利用到了content属性\n  <span>display</span><span>:</span>block<span>;</span>\n  <span>height</span><span>:</span>0<span>;</span>\n  <span>visibility</span><span>:</span>hidden<span>;</span>\n  <span>clear</span><span>:</span>both<span>;</span> \n <span>}</span>\n<span>.clearfix</span> <span>{</span>\n  *<span>zoom</span><span>:</span>1<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_45-水平居中的方法\"> 45. 水平居中的方法</h3>\n<ul>\n<li>元素为行内元素，设置父元素<code>text-align:center</code></li>\n<li>如果元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</li>\n<li>绝对定位和移动: <code>absolute + transform</code></li>\n<li>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为center</li>\n<li><code>display</code>设置为<code>tabel-ceil</code></li>\n</ul>\n<h3 id=\"_46-垂直居中的方法\"> 46. 垂直居中的方法</h3>\n<ul>\n<li>\n<p>将显示方式设置为表格，<code>display:table-cell</code>,同时设置<code>vertial-align：middle</code></p>\n</li>\n<li>\n<p>使用<code>flex</code>布局，设置为<code>align-item：center</code></p>\n</li>\n<li>\n<p>绝对定位中设置<code>bottom:0,top:0</code>,并设置<code>margin:auto</code></p>\n</li>\n<li>\n<p>绝对定位中固定高度时设置<code>top:50%，margin-top</code>值为高度一半的负值</p>\n</li>\n<li>\n<p>文本垂直居中设置<code>line-height</code>为<code>height</code>值</p>\n</li>\n<li>\n<p>如果是单行文本, line-height 设置成和 height 值</p>\n</li>\n</ul>\n<div><pre><code><span>.vertical</span> <span>{</span>\n  <span>height</span><span>:</span> 100px<span>;</span>\n  <span>line-height</span><span>:</span> 100px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>已知高度的块级子元素，采用绝对定位和负边距</li>\n</ul>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n<span>}</span>\n<span>.vertical</span> <span>{</span>\n  <span>height</span><span>:</span> 300px<span>;</span>  <span>/*子元素高度*/</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n  <span>top</span><span>:</span>50%<span>;</span>  <span>/*父元素高度50%*/</span>\n  <span>margin-top</span><span>:</span> -150px<span>;</span> <span>/*自身高度一半*/</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>未知高度的块级父子元素居中，模拟表格布局</li>\n<li>缺点：IE67不兼容，父级 overflow：hidden 失效</li>\n</ul>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>display</span><span>:</span> table<span>;</span>\n<span>}</span>\n<span>.content</span> <span>{</span>\n  <span>display</span><span>:</span> table-cell<span>;</span>\n  <span>vertical-align</span><span>:</span> middle<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>新增 inline-block 兄弟元素，设置 vertical-align</p>\n<ul>\n<li>缺点：需要增加额外标签，IE67不兼容</li>\n</ul>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>height</span><span>:</span> 100%<span>;</span><span>/*定义父级高度，作为参考*/</span>\n<span>}</span>\n<span>.extra .vertical</span><span>{</span>\n  <span>display</span><span>:</span> inline-block<span>;</span>  <span>/*行内块显示*/</span>\n  <span>vertical-align</span><span>:</span> middle<span>;</span> <span>/*垂直居中*/</span>\n<span>}</span>\n<span>.extra</span> <span>{</span>\n  <span>height</span><span>:</span> 100%<span>;</span> <span>/*设置新增元素高度为100%*/</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>绝对定位配合 CSS3 位移</li>\n</ul>\n<div><pre><code><span>.vertical</span> <span>{</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n  <span>top</span><span>:</span>50%<span>;</span>  <span>/*父元素高度50%*/</span>\n  <span>transform</span><span>:</span><span>translateY</span><span>(</span>-50%<span>,</span> -50%<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>CSS3弹性盒模型</li>\n</ul>\n<div><pre><code><span>.container</span> <span>{</span>\n  <span>display</span><span>:</span>flex<span>;</span>\n  <span>justify-content</span><span>:</span> center<span>;</span> <span>/*子元素水平居中*/</span>\n  <span>align-items</span><span>:</span> center<span>;</span> <span>/*子元素垂直居中*/</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_47-如何使用css实现硬件加速\"> 47. 如何使用CSS实现硬件加速？</h3>\n<blockquote>\n<p>硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能，</p>\n</blockquote>\n<ul>\n<li>一般触发硬件加速的<code>CSS</code>属性有<code>transform</code>、<code>opacity</code>、<code>filter</code>，为了避免2D动画在 开始和结束的时候的<code>repaint</code>操作，一般使用<code>tranform:translateZ(0)</code></li>\n</ul>\n<h3 id=\"_48-重绘和回流-重排-是什么-如何避免\"> 48. 重绘和回流（重排）是什么，如何避免？</h3>\n<ul>\n<li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li>\n<li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流</li>\n<li>注意：JS获取Layout属性值（如：<code>offsetLeft</code>、<code>scrollTop</code>、<code>getComputedStyle</code>等）也会引起回流。因为浏览器需要通过回流计算最新值</li>\n<li>回流必将引起重绘，而重绘不一定会引起回流</li>\n</ul>\n<p><strong>如何最小化重绘(repaint)和回流(reflow)</strong>：</p>\n<ul>\n<li>需要要对元素进行复杂的操作时，可以先隐藏(<code>display:&quot;none&quot;</code>)，操作完成后再显示</li>\n<li>需要创建多个<code>DOM</code>节点时，使用<code>DocumentFragment</code>创建完后一次性的加入<code>document</code></li>\n<li>缓存<code>Layout</code>属性值，如：<code>var left = elem.offsetLeft;</code> 这样，多次使用 <code>left</code> 只产生一次回流</li>\n<li>尽量避免用<code>table</code>布局（<code>table</code>元素一旦触发回流就会导致table里所有的其它元素回流）</li>\n<li>避免使用<code>css</code>表达式(<code>expression</code>)，因为每次调用都会重新计算值（包括加载页面）</li>\n<li>尽量使用 <code>css</code> 属性简写，如：用 <code>border</code> 代替 <code>border-width</code>, <code>border-style</code>, <code>border-color</code></li>\n<li>批量修改元素样式：<code>elem.className</code> 和 <code>elem.style.cssText</code> 代替 <code>elem.style.xxx</code></li>\n</ul>\n<h3 id=\"_49-说一说css3的animation\"> 49. 说一说css3的animation</h3>\n<ul>\n<li>css3的<code>animation</code>是css3新增的动画属性，这个css3动画的每一帧是通过<code>@keyframes</code>来声明的，<code>keyframes</code>声明了动画的名称，通过<code>from</code>、<code>to</code>或者是百分比来定义</li>\n<li>每一帧动画元素的状态，通过<code>animation-name</code>来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，</li>\n<li>这些相关的动画子属性有：<code>animation-name</code>定义动画名、<code>animation-duration</code>定义动画播放的时长、<code>animation-delay</code>定义动画延迟播放的时间、<code>animation-direction</code>定义 动画的播放方向、<code>animation-iteration-count</code>定义播放次数、<code>animation-fill-mode</code>定义动画播放之后的状态、<code>animation-play-state</code>定义播放状态，如暂停运行等、<code>animation-timing-function</code></li>\n<li>定义播放的方式，如恒速播放、艰涩播放等。</li>\n</ul>\n<h3 id=\"_50-左边宽度固定-右边自适应\"> 50. 左边宽度固定，右边自适应</h3>\n<blockquote>\n<p>左侧固定宽度，右侧自适应宽度的两列布局实现</p>\n</blockquote>\n<p>html结构</p>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>outer<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>left<span>\"</span></span><span>></span></span>固定宽度<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>right<span>\"</span></span><span>></span></span>自适应宽度<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>在外层<code>div</code>（类名为<code>outer</code>）的<code>div</code>中，有两个子<code>div</code>，类名分别为<code>left</code>和<code>right</code>，其中<code>left</code>为固定宽度，而<code>right</code>为自适应宽度</p>\n</blockquote>\n<p><strong>方法1：左侧div设置成浮动：float: left，右侧div宽度会自拉升适应：</strong></p>\n<div><pre><code><span>.outer</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>height</span><span>:</span> 500px<span>;</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> red<span>;</span>\n  <span>float</span><span>:</span> left<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> blue<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应：</strong></p>\n<blockquote>\n<p>绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将 <code>width</code>设置为 <code>auto</code> 的时候（或者不设置，默认为 <code>auto</code> ），绝对定位元素会根据其 <code>left</code> 和 <code>right</code> 自动伸缩其大小</p>\n</blockquote>\n<div><pre><code><span>.outer</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>height</span><span>:</span> 500px<span>;</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> red<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> blue<span>;</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n  <span>left</span><span>:</span> 200px<span>;</span>\n  <span>top</span><span>:</span>0<span>;</span>          \n  <span>right</span><span>:</span> 0<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>方法3：将左侧<code>div</code>进行绝对定位，然后右侧<code>div</code>设置<code>margin-left: 200px</code></strong></p>\n<div><pre><code><span>.outer</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>height</span><span>:</span> 500px<span>;</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> red<span>;</span>\n  <span>position</span><span>:</span> absolute<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> blue<span>;</span>\n  <span>margin-left</span><span>:</span> 200px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>方法4：使用flex布局：</strong></p>\n<div><pre><code><span>.outer</span> <span>{</span>\n  <span>width</span><span>:</span> 100%<span>;</span>\n  <span>height</span><span>:</span> 500px<span>;</span>\n  <span>background-color</span><span>:</span> yellow<span>;</span>\n  <span>display</span><span>:</span> flex<span>;</span>\n  <span>flex-direction</span><span>:</span> row<span>;</span>\n<span>}</span>\n<span>.left</span> <span>{</span>\n  <span>width</span><span>:</span> 200px<span>;</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> red<span>;</span>\n<span>}</span>\n<span>.right</span> <span>{</span>\n  <span>height</span><span>:</span> 200px<span>;</span>\n  <span>background-color</span><span>:</span> blue<span>;</span>\n  <span>flex</span><span>:</span> 1<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_51-两种以上方式实现已知或者未知宽度的垂直水平居中\"> 51. 两种以上方式实现已知或者未知宽度的垂直水平居中</h3>\n<div><pre><code><span>/** 1 **/</span>\n<span>.wraper</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>.box</span> <span>{</span>\n    <span>position</span><span>:</span> absolute<span>;</span>\n    <span>top</span><span>:</span> 50%<span>;</span>\n    <span>left</span><span>:</span> 50%<span>;</span>\n    <span>width</span><span>:</span> 100px<span>;</span>\n    <span>height</span><span>:</span> 100px<span>;</span>\n    <span>margin</span><span>:</span> -50px 0 0 -50px<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/** 2 **/</span>\n<span>.wraper</span> <span>{</span>\n  <span>position</span><span>:</span> relative<span>;</span>\n  <span>.box</span> <span>{</span>\n    <span>position</span><span>:</span> absolute<span>;</span>\n    <span>top</span><span>:</span> 50%<span>;</span>\n    <span>left</span><span>:</span> 50%<span>;</span>\n    <span>transform</span><span>:</span> <span>translate</span><span>(</span>-50%<span>,</span> -50%<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/** 3 **/</span>\n<span>.wraper</span> <span>{</span>\n  <span>.box</span> <span>{</span>\n    <span>display</span><span>:</span> flex<span>;</span>\n    <span>justify-content</span><span>:</span>center<span>;</span>\n    <span>align-items</span><span>:</span> center<span>;</span>\n    <span>height</span><span>:</span> 100px<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>/** 4 **/</span>\n<span>.wraper</span> <span>{</span>\n  <span>display</span><span>:</span> table<span>;</span>\n  <span>.box</span> <span>{</span>\n    <span>display</span><span>:</span> table-cell<span>;</span>\n    <span>vertical-align</span><span>:</span> middle<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_52-如何实现小于12px的字体效果\"> 52. 如何实现小于12px的字体效果</h3>\n<blockquote>\n<p><code>transform:scale()</code>这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个<code>display:inline-block</code>;</p>\n</blockquote>\n<div><pre><code><span>transform</span><span>:</span> <span>scale</span><span>(</span>0.7<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><code>css</code>的属性，可以缩放大小</p>\n<h3 id=\"_53-css-hack原理及常用hack\"> 53. css hack原理及常用hack</h3>\n<ul>\n<li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li>\n<li>常见的hack有\n<ul>\n<li>属性hack</li>\n<li>选择器hack</li>\n<li>IE条件注释</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_54-css有哪些继承属性\"> 54. CSS有哪些继承属性</h3>\n<p>关于文字排版的属性如：</p>\n<ul>\n<li>font\n<ul>\n<li><code>word-break</code></li>\n<li><code>letter-spacing</code></li>\n<li><code>text-align</code></li>\n<li><code>text-rendering</code></li>\n<li><code>word-spacing</code></li>\n<li><code>white-space</code></li>\n<li><code>text-indent</code></li>\n<li><code>text-transform</code></li>\n<li><code>text-shadow</code></li>\n</ul>\n</li>\n<li><code>line-height</code></li>\n<li><code>color</code></li>\n<li><code>visibility</code></li>\n<li><code>cursor</code></li>\n</ul>\n<h3 id=\"_55-外边距折叠-collapsing-margins\"> 55. 外边距折叠(collapsing margins)</h3>\n<p>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：</p>\n<ul>\n<li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li>\n<li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li>\n<li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li>\n<li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li>\n</ul>\n<h3 id=\"_56-css选择符有哪些-哪些属性可以继承\"> 56. CSS选择符有哪些？哪些属性可以继承</h3>\n<ul>\n<li>id选择器（ <code># myid</code>）</li>\n<li>类选择器（<code>.myclassname</code>）</li>\n<li>标签选择器（<code>div</code>, <code>h1</code>, <code>p</code>）</li>\n<li>相邻选择器（<code>h1 + p</code>）</li>\n<li>子选择器（<code>ul &gt; li</code>）</li>\n<li>后代选择器（<code>li a</code>）</li>\n<li>通配符选择器（ <code>*</code> ）</li>\n<li>属性选择器（<code>a[rel = &quot;external&quot;]</code>）</li>\n<li>伪类选择器（<code>a:hover, li:nth-child</code>）</li>\n</ul>\n<p><strong>CSS哪些属性可以继承？哪些属性不可以继承：</strong></p>\n<ul>\n<li>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></li>\n<li>不可继承的样式：<code>border padding margin width height</code></li>\n</ul>\n<h3 id=\"_57-css3新增伪类有那些\"> 57. CSS3新增伪类有那些</h3>\n<ul>\n<li><code>:root</code> 选择文档的根元素，等同于 html 元素</li>\n<li><code>:empty</code> 选择没有子元素的元素</li>\n<li><code>:target</code> 选取当前活动的目标元素</li>\n<li><code>:not(selector)</code> 选择除 <code>selector</code> 元素意外的元素</li>\n<li><code>:enabled</code> 选择可用的表单元素</li>\n<li><code>:disabled</code> 选择禁用的表单元素</li>\n<li><code>:checked</code> 选择被选中的表单元素</li>\n<li><code>:after</code> 在元素内部最前添加内容</li>\n<li><code>:before</code> 在元素内部最后添加内容</li>\n<li><code>:nth-child(n)</code> 匹配父元素下指定子元素，在所有子元素中排序第n</li>\n<li><code>:nth-last-child(n)</code> 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</li>\n<li><code>:nth-child(odd)</code></li>\n<li><code>:nth-child(even)</code></li>\n<li><code>:nth-child(3n+1)</code></li>\n<li><code>:first-child</code></li>\n<li><code>:last-child</code></li>\n<li><code>:only-child</code></li>\n<li><code>:nth-of-type(n)</code> 匹配父元素下指定子元素，在同类子元素中排序第n</li>\n<li><code>:nth-last-of-type(n)</code> 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</li>\n<li><code>:nth-of-type(odd)</code></li>\n<li><code>:nth-of-type(even)</code></li>\n<li><code>:nth-of-type(3n+1)</code></li>\n<li><code>:first-of-type</code></li>\n<li><code>:last-of-type</code></li>\n<li><code>:only-of-type</code></li>\n<li><code>::selection</code> 选择被用户选取的元素部分</li>\n<li><code>:first-line</code> 选择元素中的第一行</li>\n<li><code>:first-letter</code> 选择元素中的第一个字符</li>\n</ul>\n<h3 id=\"_58-如何居中div-如何居中一个浮动元素-如何让绝对定位的div居中\"> 58. 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中</h3>\n<ul>\n<li>给<code>div</code>设置一个宽度，然后添加<code>margin:0 auto</code>属性</li>\n</ul>\n<div><pre><code><span>div</span><span>{</span>\n  <span>width</span><span>:</span>200px<span>;</span>\n  <span>margin</span><span>:</span>0 auto<span>;</span>\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>居中一个浮动元素</li>\n</ul>\n<div><pre><code><span>/* 确定容器的宽高 宽500 高 300 的层\n设置层的外边距 */</span>\n\n<span>.div</span> <span>{</span>\n  <span>width</span><span>:</span>500px <span>;</span> <span>height</span><span>:</span>300px<span>;</span>//高度可以不设\n  <span>margin</span><span>:</span> -150px 0 0 -250px<span>;</span>\n  <span>position</span><span>:</span>relative<span>;</span>         //相对定位\n  <span>background-color</span><span>:</span>pink<span>;</span>     //方便看效果\n  <span>left</span><span>:</span>50%<span>;</span>\n  <span>top</span><span>:</span>50%<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>让绝对定位的div居中</p>\n</blockquote>\n<div><pre><code><span>position</span><span>:</span> absolute<span>;</span>\n<span>width</span><span>:</span> 1200px<span>;</span>\n<span>background</span><span>:</span> none<span>;</span>\n<span>margin</span><span>:</span> 0 auto<span>;</span>\n<span>top</span><span>:</span> 0<span>;</span>\n<span>left</span><span>:</span> 0<span>;</span>\n<span>bottom</span><span>:</span> 0<span>;</span>\n<span>right</span><span>:</span> 0<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_59-用纯css创建一个三角形的原理是什么\"> 59. 用纯CSS创建一个三角形的原理是什么</h3>\n<div><pre><code><span>/* 把上、左、右三条边隐藏掉（颜色设为 transparent） */</span>\n<span>#demo</span> <span>{</span>\n  <span>width</span><span>:</span> 0<span>;</span>\n  <span>height</span><span>:</span> 0<span>;</span>\n  <span>border-width</span><span>:</span> 20px<span>;</span>\n  <span>border-style</span><span>:</span> solid<span>;</span>\n  <span>border-color</span><span>:</span> transparent transparent red transparent<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_60-一个满屏-品-字布局-如何设计\"> 60. 一个满屏 品 字布局 如何设计?</h3>\n<p>简单的方式：</p>\n<ul>\n<li>上面的<code>div</code>宽<code>100%</code>，</li>\n<li>下面的两个<code>div</code>分别宽<code>50%</code>，</li>\n<li>然后用<code>float</code>或者<code>inline</code>使其不换行即可</li>\n</ul>\n<h3 id=\"_61-li与li之间有看不见的空白间隔是什么原因引起的-有什么解决办法\"> 61. li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法</h3>\n<blockquote>\n<p>行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</p>\n</blockquote>\n<h3 id=\"_62-为什么要初始化css样式\"> 62. 为什么要初始化CSS样式</h3>\n<blockquote>\n<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</p>\n</blockquote>\n<h3 id=\"_63-请列举几种隐藏元素的方法\"> 63. 请列举几种隐藏元素的方法</h3>\n<ul>\n<li><code>visibility: hidden;</code> 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li>\n<li><code>opacity: 0;</code> <code>CSS3</code>属性，设置<code>0</code>可以使一个元素完全透明</li>\n<li><code>position: absolute;</code> 设置一个很大的 <code>left</code> 负值定位，使元素定位在可见区域之外</li>\n<li><code>display: none;</code> 元素会变得不可见，并且不会再占用文档的空间。</li>\n<li><code>transform: scale(0);</code> 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li>\n<li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> HTML5属性,效果和<code>display:none;</code>相同，但这个属性用于记录一个元素的状态</li>\n<li><code>height: 0;</code> 将元素高度设为 <code>0</code> ，并消除边框</li>\n<li><code>filter: blur(0);</code> CSS3属性，将一个元素的模糊度设置为<code>0</code>，从而使这个元素“消失”在页面中</li>\n</ul>\n<h3 id=\"_64-rgba-和-opacity-的透明效果有什么不同\"> 64. rgba() 和 opacity 的透明效果有什么不同</h3>\n<ul>\n<li><code>opacity</code> 作用于元素以及元素内的所有内容（包括文字）的透明度</li>\n<li><code>rgba()</code> 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li>\n</ul>\n<h3 id=\"_65-css-属性-content-有什么作用\"> 65. css 属性 content 有什么作用</h3>\n<ul>\n<li>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</li>\n</ul>\n<h3 id=\"_66-请解释一下-css3-的-flexbox-弹性盒布局模型-以及适用场景\"> 66. 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景</h3>\n<blockquote>\n<p>1Flexbox1 用于不同尺寸屏幕中创建可自动扩展和收缩布局</p>\n</blockquote>\n<h3 id=\"_67-经常遇到的浏览器的js兼容性有哪些-解决方法是什么\"> 67. 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么</h3>\n<ul>\n<li>当前样式：<code>getComputedStyle(el, null) VS el.currentStyle</code></li>\n<li>事件对象：<code>e VS window.event</code></li>\n<li>鼠标坐标：<code>e.pageX, e.pageY VS window.event.x, window.event.y</code></li>\n<li>按键码：<code>e.which VS event.keyCode</code></li>\n<li>文本节点：<code>el.textContent VS el.innerText</code></li>\n</ul>\n<h3 id=\"_68-请写出多种等高布局\"> 68. 请写出多种等高布局</h3>\n<ul>\n<li>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</li>\n<li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li>\n<li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li>\n</ul>\n<h3 id=\"_69-浮动元素引起的问题\"> 69. 浮动元素引起的问题</h3>\n<ul>\n<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>\n<li>与浮动元素同级的非浮动元素会跟随其后</li>\n</ul>\n<h3 id=\"_70-css优化、提高性能的方法有哪些\"> 70. CSS优化、提高性能的方法有哪些</h3>\n<ul>\n<li>多个<code>css</code>合并，尽量减少<code>HTTP</code>请求</li>\n<li>将<code>css</code>文件放在页面最上面</li>\n<li>移除空的<code>css</code>规则</li>\n<li>避免使用<code>CSS</code>表达式</li>\n<li>选择器优化嵌套，尽量避免层级过深</li>\n<li>充分利用<code>css</code>继承属性，减少代码量</li>\n<li>抽象提取公共样式，减少代码量</li>\n<li>属性值为<code>0</code>时，不加单位</li>\n<li>属性值为小于<code>1</code>的小数时，省略小数点前面的0</li>\n<li><code>css</code>雪碧图</li>\n</ul>\n<h3 id=\"_71-浏览器是怎样解析css选择器的\"> 71. 浏览器是怎样解析CSS选择器的</h3>\n<ul>\n<li>浏览器解析 CSS 选择器的方式是从右到左</li>\n</ul>\n<h3 id=\"_72-在网页中的应该使用奇数还是偶数的字体\"> 72. 在网页中的应该使用奇数还是偶数的字体</h3>\n<p>在网页中的应该使用“偶数”字体：</p>\n<ul>\n<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li>\n<li>使用奇数号字体时文本段落无法对齐</li>\n<li>宋体的中文网页排布中使用最多的就是 12 和 14</li>\n</ul>\n<h3 id=\"_73-margin和padding分别适合什么场景使用\"> 73. margin和padding分别适合什么场景使用</h3>\n<ul>\n<li>需要在<code>border</code>外侧添加空白，且空白处不需要背景（色）时，使用 <code>margin</code></li>\n<li>需要在<code>border</code>内测添加空白，且空白处需要背景（色）时，使用 <code>padding</code></li>\n</ul>\n<h3 id=\"_74-抽离样式模块怎么写-说出思路\"> 74. 抽离样式模块怎么写，说出思路</h3>\n<p>CSS可以拆分成2部分：公共CSS 和 业务CSS：</p>\n<ul>\n<li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li>\n<li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li>\n</ul>\n<h3 id=\"_75-元素竖向的百分比设定是相对于容器的高度吗\"> 75. 元素竖向的百分比设定是相对于容器的高度吗</h3>\n<blockquote>\n<p>元素竖向的百分比设定是相对于容器的宽度，而不是高度</p>\n</blockquote>\n<h3 id=\"_76-全屏滚动的原理是什么-用到了css的那些属性\"> 76. 全屏滚动的原理是什么？ 用到了CSS的那些属性</h3>\n<ul>\n<li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li>\n<li>可能用到的CSS属性：<code>overflow:hidden; transform:translate(100%, 100%); display:none;</code></li>\n</ul>\n<h3 id=\"_77-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie\"> 77. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE</h3>\n<ul>\n<li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li>\n<li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li>\n<li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li>\n</ul>\n<div><pre><code><span>$</span><span>(</span>window<span>)</span><span>.</span><span>resize</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>screenRespond</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n<span>screenRespond</span><span>(</span><span>)</span><span>;</span>\n<span>function</span> <span>screenRespond</span><span>(</span><span>)</span><span>{</span>\n<span>var</span> screenWidth <span>=</span> <span>$</span><span>(</span>window<span>)</span><span>.</span><span>width</span><span>(</span><span>)</span><span>;</span>\n<span>if</span><span>(</span>screenWidth <span>&lt;=</span> <span>1800</span><span>)</span><span>{</span>\n  <span>$</span><span>(</span><span>\"body\"</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>\"class\"</span><span>,</span> <span>\"w1800\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>if</span><span>(</span>screenWidth <span>&lt;=</span> <span>1400</span><span>)</span><span>{</span>\n  <span>$</span><span>(</span><span>\"body\"</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>\"class\"</span><span>,</span> <span>\"w1400\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>if</span><span>(</span>screenWidth <span>></span> <span>1800</span><span>)</span><span>{</span>\n  <span>$</span><span>(</span><span>\"body\"</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>\"class\"</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_78-什么是视差滚动效果-如何给每页做不同的动画\"> 78. 什么是视差滚动效果，如何给每页做不同的动画</h3>\n<ul>\n<li>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</li>\n<li>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</li>\n<li>实现原理\n<ul>\n<li>以 “页面滚动条” 作为 “视差动画进度条”</li>\n<li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li>\n<li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_79-a标签上四个伪类的执行顺序是怎么样的\"> 79. a标签上四个伪类的执行顺序是怎么样的</h3>\n<blockquote>\n<p>link &gt; visited &gt; hover &gt; active</p>\n</blockquote>\n<ul>\n<li><code>L-V-H-A</code> <code>love hate</code> 用喜欢和讨厌两个词来方便记忆</li>\n</ul>\n<h3 id=\"_80-伪元素和伪类的区别和作用\"> 80. 伪元素和伪类的区别和作用</h3>\n<ul>\n<li>伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li>\n<li>它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li>\n</ul>\n<div><pre><code><span>p::before</span> <span>{</span><span>content</span><span>:</span><span>\"第一章：\"</span><span>;</span><span>}</span>\n<span>p::after</span> <span>{</span><span>content</span><span>:</span><span>\"Hot!\"</span><span>;</span><span>}</span>\n<span>p::first-line</span> <span>{</span><span>background</span><span>:</span>red<span>;</span><span>}</span>\n<span>p::first-letter</span> <span>{</span><span>font-size</span><span>:</span>30px<span>;</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li>\n</ul>\n<div><pre><code><span>a:hover</span> <span>{</span><span>color</span><span>:</span> #FF00FF<span>}</span>\n<span>p:first-child</span> <span>{</span><span>color</span><span>:</span> red<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_81-before-和-after-中双冒号和单冒号有什么区别\"> 81 ::before 和 :after 中双冒号和单冒号有什么区别</h3>\n<ul>\n<li>在 CSS 中伪类一直用 <code>:</code> 表示，如 <code>:hover</code>, <code>:active</code> 等</li>\n<li>伪元素在CSS1中已存在，当时语法是用 <code>:</code> 表示，如 <code>:before</code> 和 <code>:after</code></li>\n<li>后来在CSS3中修订，伪元素用 <code>::</code> 表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类</li>\n<li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li>\n<li>综上所述：<code>::before</code> 是 <code>CSS3</code> 中写伪元素的新语法； <code>:after</code> 是 <code>CSS1</code> 中存在的、兼容IE的老语法</li>\n</ul>\n<h3 id=\"_82-如何修改chrome记住密码后自动填充表单的黄色背景\"> 82. 如何修改Chrome记住密码后自动填充表单的黄色背景</h3>\n<ul>\n<li>产生原因：由于Chrome默认会给自动填充的input表单加上 <code>input:-webkit-autofill</code> 私有属性造成的</li>\n<li>解决方案1：在form标签上直接关闭了表单的自动填充：<code>autocomplete=&quot;off&quot;</code></li>\n<li>解决方案2：<code>input:-webkit-autofill { background-color: transparent; }</code></li>\n</ul>\n<p><strong>input [type=search] 搜索框右侧小图标如何美化？</strong></p>\n<div><pre><code><span>input[type=\"search\"]::-webkit-search-cancel-button</span><span>{</span>\n  <span>-webkit-appearance</span><span>:</span> none<span>;</span>\n  <span>height</span><span>:</span> 15px<span>;</span>\n  <span>width</span><span>:</span> 15px<span>;</span>\n  <span>border-radius</span><span>:</span> 8px<span>;</span>\n  <span>background</span><span>:</span><span><span>url</span><span>(</span><span>\"images/searchicon.png\"</span><span>)</span></span> no-repeat 0 0<span>;</span>\n  <span>background-size</span><span>:</span> 15px 15px<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_83-网站图片文件-如何点击下载-而非点击预览\"> 83. 网站图片文件，如何点击下载？而非点击预览</h3>\n<blockquote>\n<p>&lt;a href=&quot;logo.jpg&quot; download&gt;下载</a> &lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载</a></p>\n</blockquote>\n<h3 id=\"_84-你对-line-height-是如何理解的\"> 84. 你对 line-height 是如何理解的</h3>\n<ul>\n<li><code>line-height</code> 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li>\n<li>如果一个标签没有定义 <code>height</code> 属性，那么其最终表现的高度是由 <code>line-height</code> 决定的</li>\n<li>一个容器没有设置高度，那么撑开容器高度的是 <code>line-height</code> 而不是容器内的文字内容</li>\n<li>把 <code>line-height</code> 值设置为 <code>height</code> 一样大小的值可以实现单行文字的垂直居中</li>\n<li><code>line-height</code> 和 <code>height</code> 都能撑开一个高度，<code>height</code> 会触发 <code>haslayout</code>，而 <code>line-height</code> 不会</li>\n</ul>\n<h3 id=\"_85-line-height-三种赋值方式有何区别-带单位、纯数字、百分比\"> 85. line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</h3>\n<ul>\n<li>带单位：<code>px</code> 是固定值，而 <code>em</code> 会参考父元素 <code>font-size</code> 值计算自身的行高</li>\n<li>纯数字：会把比例传递给后代。例如，父级行高为 <code>1.5</code>，子元素字体为 <code>18px</code>，则子元素行高为 <code>1.5 * 18 = 27px</code></li>\n<li>百分比：将计算后的值传递给后代</li>\n</ul>\n<h3 id=\"_86-设置元素浮动后-该元素的-display-值会如何变化\"> 86. 设置元素浮动后，该元素的 display 值会如何变化</h3>\n<blockquote>\n<p>设置元素浮动后，该元素的 <code>display</code> 值自动变成 <code>block</code></p>\n</blockquote>\n<h3 id=\"_87-让页面里的字体变清晰-变细用css怎么做-ios手机浏览器字体齿轮设置\"> 87. 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</h3>\n<div><pre><code><span>-webkit-font-smoothing</span><span>:</span> antialiased<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_88-font-style-属性-oblique-是什么意思\"> 88. font-style 属性 oblique 是什么意思</h3>\n<blockquote>\n<p><code>font-style: oblique;</code> 使没有 <code>italic</code> 属性的文字实现倾斜</p>\n</blockquote>\n<h3 id=\"_89-display-inline-block-什么时候会显示间隙\"> 89. display:inline-block 什么时候会显示间隙</h3>\n<ul>\n<li>相邻的 <code>inline-block</code> 元素之间有换行或空格分隔的情况下会产生间距</li>\n<li>非 <code>inline-block</code> 水平元素设置为 <code>inline-block</code> 也会有水平间距</li>\n<li>可以借助 <code>vertical-align:top;</code> 消除垂直间隙</li>\n<li>可以在父级加 <code>font-size：0;</code> 在子元素里设置需要的字体大小，消除垂直间隙</li>\n<li>把 <code>li</code> 标签写到同一行可以消除垂直间隙，但代码可读性差</li>\n</ul>\n<h3 id=\"_90-一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度\"> 90. 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h3>\n<ul>\n<li>方案1：\n<ul>\n<li><code>.sub { height: calc(100%-100px); }</code></li>\n</ul>\n</li>\n<li>方案2：\n<ul>\n<li><code>.container { position:relative; }</code></li>\n<li><code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li>\n</ul>\n</li>\n<li>方案3：\n<ul>\n<li><code>.container { display:flex; flex-direction:column; }</code></li>\n<li><code>.sub { flex:1; }</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_91-ios-safari-如何阻止-橡皮筋效果\"> 91. iOS safari 如何阻止“橡皮筋效果”</h3>\n<div><pre><code><span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>var</span> <span>stopScrolling</span> <span>=</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>\n    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  document<span>.</span><span>addEventListener</span><span>(</span><span>'touchstart'</span><span>,</span> stopScrolling<span>,</span> <span>false</span><span>)</span><span>;</span>\n  document<span>.</span><span>addEventListener</span><span>(</span><span>'touchmove'</span><span>,</span> stopScrolling<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "date_published": "2021-07-30T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:56.984Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "css"
      ]
    },
    {
      "title": "Project home",
      "url": "https://github.com/letme350/home/",
      "id": "https://github.com/letme350/home/",
      "content_html": "<p>This is an example of a normal homepage. You can place your main content here.</p>\n<p>To use this layout, you need to set <code>home: true</code> in the page front matter.</p>\n<p>For related descriptions of configuration items, please see <a href=\"https://vuepress-theme-hope.github.io/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">Project HomePage Layout Config</a>.</p>\n",
      "date_modified": "2021-07-30T15:17:56.985Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": []
    },
    {
      "title": "关于我",
      "url": "https://github.com/letme350/intro/",
      "id": "https://github.com/letme350/intro/",
      "content_html": "<h1 id=\"关于我\"> 关于我</h1>\n<h2 id=\"个人信息\"> 个人信息</h2>\n<p><img src=\"/logo.jpg\" alt=\"img\" /></p>\n<p>我是<strong>PromiseLi</strong>（瞎起的），今年23岁，坐标北京市朝阳区，一名非常热爱学习的前端菜鸟。每天游走在写BUG与改BUG之间，生活在与产品和测试的撕逼之中，生活极其舒服安逸。</p>\n<h2 id=\"自我评价\"> 自我评价</h2>\n<ul>\n<li>具备扎实基础能力，擅长开发与重构各种前端应用</li>\n<li>具备良好编程能力，敢于追求编码细节和代码规范</li>\n<li>具备优秀写作能力，活跃技术社区且拥有过万读者</li>\n<li>具备细致思考能力，单独拥有超过三十份技术专利</li>\n<li>具备全面架构能力，独立设计多个大前端公共架构</li>\n<li>致力于前端项目的工程架构、性能优化和设计模式</li>\n<li>（以上纯属吹牛逼~~~）</li>\n</ul>\n<h2 id=\"人生目标\"> 人生目标</h2>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 自己养活自己</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 宝马750Li（30岁不知道能不能完成）</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 存款100W（有第二条还想着完成？？）</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-3\"><label for=\"task-item-3\"> 拥有一个女朋友（屁~~~，注定寡王）</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-4\"><label for=\"task-item-4\"> 大厂游一游（这个比较好实现）</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-5\"><label for=\"task-item-5\"> 看遍华夏的大好河山</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-6\"><label for=\"task-item-6\"> ....(其他的再想想)</label></li>\n</ul>\n<h2 id=\"教育经历\"> 教育经历</h2>\n<p>算了，这个就不写了。。。</p>\n<h2 id=\"开源分享\"> 开源分享</h2>\n<p>没有，菜鸟一个，能有啥开源。。。</p>\n",
      "image": "https://github.com/letme350/logo.jpg",
      "date_published": "2021-07-29T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:56.987Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "关于我"
      ]
    },
    {
      "title": "JavaScript补充",
      "url": "https://github.com/letme350/javaScript/advanced/",
      "id": "https://github.com/letme350/javaScript/advanced/",
      "content_html": "<h1 id=\"javascript补充\"> JavaScript补充</h1>\n<h2 id=\"javascript进阶\"> JavaScript进阶</h2>\n<h3 id=\"_1-内置类型\"> 1 内置类型</h3>\n<ul>\n<li><code>JS</code> 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（<code>Object</code>）。</li>\n<li>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</li>\n<li>其中 <code>JS</code> 的数字类型是浮点类型的，没有整型。并且浮点类型基于 <code>IEEE 754</code>标准实现，在使用中会遇到某些 Bug。<code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。</li>\n<li>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。</li>\n</ul>\n<div><pre><code><span>let</span> a <span>=</span> <span>111</span> <span>// 这只是字面量，不是 number 类型</span>\na<span>.</span><span>toString</span><span>(</span><span>)</span> <span>// 使用时候才会转换为对象类型</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>对象（<code>Object</code>）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。</p>\n</blockquote>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span> name<span>:</span> <span>'FE'</span> <span>}</span>\n<span>let</span> b <span>=</span> a\nb<span>.</span>name <span>=</span> <span>'EF'</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span> <span>// EF</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_2-typeof\"> 2 Typeof</h3>\n<blockquote>\n<p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p>\n</blockquote>\n<div><pre><code><span>typeof</span> <span>1</span> <span>// 'number'</span>\n<span>typeof</span> <span>'1'</span> <span>// 'string'</span>\n<span>typeof</span> <span>undefined</span> <span>// 'undefined'</span>\n<span>typeof</span> <span>true</span> <span>// 'boolean'</span>\n<span>typeof</span> <span>Symbol</span><span>(</span><span>)</span> <span>// 'symbol'</span>\n<span>typeof</span> b <span>// b 没有声明，但是还会显示 undefined</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>typeof<code>对于对象，除了函数都会显示</code>object</p>\n</blockquote>\n<div><pre><code><span>typeof</span> <span>[</span><span>]</span> <span>// 'object'</span>\n<span>typeof</span> <span>{</span><span>}</span> <span>// 'object'</span>\n<span>typeof</span> console<span>.</span>log <span>// 'function'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>对于 <code>null</code>来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 <code>Bug</code></p>\n</blockquote>\n<div><pre><code>typeof null // &#39;object&#39;\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>PS：为什么会出现这种情况呢？因为在 <code>JS</code>的最初版本中，使用的是 <code>32</code> 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code>表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个<code>Bug</code>却是一直流传下来。</p>\n</blockquote>\n<ul>\n<li>如果我们想获得一个变量的正确类型，可以通过 <code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[object Type]</code> 的字符串</li>\n</ul>\n<div><pre><code><span>let</span> a\n<span>// 我们也可以这样判断 undefined</span>\na <span>===</span> <span>undefined</span>\n<span>// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span>\n<span>let</span> <span>undefined</span> <span>=</span> <span>1</span>\n<span>// 这样判断就会出错</span>\n<span>// 所以可以用下面的方式来判断，并且代码量更少</span>\n<span>// 因为 void 后面随便跟上一个组成表达式</span>\n<span>// 返回就是 undefined</span>\na <span>===</span> <span>void</span> <span>0</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-类型转换\"> 3 类型转换</h3>\n<p><strong>转Boolean：</strong></p>\n<blockquote>\n<p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>''</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象</p>\n</blockquote>\n<p><strong>对象转基本类型：</strong></p>\n<blockquote>\n<p>对象在转换基本类型时，首先会调用 <code>valueOf</code> 然后调用 <code>toString</code>。并且这两个方法你是可以重写的</p>\n</blockquote>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  <span>valueOf</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>0</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>四则运算符：</strong></p>\n<blockquote>\n<p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串</p>\n</blockquote>\n<div><pre><code><span>1</span> <span>+</span> <span>'1'</span> <span>// '11'</span>\n<span>2</span> <span>*</span> <span>'2'</span> <span>// 4</span>\n<span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span> <span>+</span> <span>[</span><span>2</span><span>,</span> <span>1</span><span>]</span> <span>// '1,22,1'</span>\n<span>// [1, 2].toString() -> '1,2'</span>\n<span>// [2, 1].toString() -> '2,1'</span>\n<span>// '1,2' + '2,1' = '1,22,1'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>对于加号需要注意这个表达式 <code>'a' + + 'b'</code></p>\n</blockquote>\n<div><pre><code><span>'a'</span> <span>+</span> <span>+</span> <span>'b'</span> <span>// -> \"aNaN\"</span>\n<span>// 因为 + 'b' -> NaN</span>\n<span>// 你也许在一些代码中看到过 + '1' -> 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>== 操作符：</strong></p>\n<blockquote>\n<p>这里来解析一道题目 <code>[] == ![] // -&gt; true</code> ，下面是这个表达式为何为 <code>true</code> 的步骤</p>\n</blockquote>\n<div><pre><code><span>// [] 转成 true，然后取反变成 false</span>\n<span>[</span><span>]</span> <span>==</span> <span>false</span>\n<span>// 根据第 8 条得出</span>\n<span>[</span><span>]</span> <span>==</span> <span>ToNumber</span><span>(</span><span>false</span><span>)</span>\n<span>[</span><span>]</span> <span>==</span> <span>0</span>\n<span>// 根据第 10 条得出</span>\n<span>ToPrimitive</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>==</span> <span>0</span>\n<span>// [].toString() -> ''</span>\n<span>''</span> <span>==</span> <span>0</span>\n<span>// 根据第 6 条得出</span>\n<span>0</span> <span>==</span> <span>0</span> <span>// -> true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>比较运算符：</strong></p>\n<ul>\n<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>\n<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>\n</ul>\n<h3 id=\"_4-原型\"> 4 原型</h3>\n<p><img src=\"/javaScriptBase/prototype.png\" alt=\"prototype\" /></p>\n<ul>\n<li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li>\n<li>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</li>\n<li>对象可以通过<code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链</li>\n</ul>\n<h3 id=\"_5-new\"> 5 new</h3>\n<ul>\n<li>新生成了一个对象</li>\n<li>链接到原型</li>\n<li>绑定 <code>this</code></li>\n<li>返回新对象</li>\n</ul>\n<blockquote>\n<p>在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>create</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 创建一个空的对象</span>\n  <span>let</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span>\n  <span>// 获得构造函数</span>\n  <span>let</span> Con <span>=</span> <span>[</span><span>]</span><span>.</span><span>shift</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span>\n  <span>// 链接到原型</span>\n  obj<span>.</span>__proto__ <span>=</span> <span>Con</span><span>.</span>prototype\n  <span>// 绑定 this，执行构造函数</span>\n  <span>let</span> result <span>=</span> <span>Con</span><span>.</span><span>apply</span><span>(</span>obj<span>,</span> arguments<span>)</span>\n  <span>// 确保 new 出来的是个对象</span>\n  <span>return</span> <span>typeof</span> result <span>===</span> <span>'object'</span> <span>?</span> result <span>:</span> obj\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_6-instanceof\"> 6 instanceof</h3>\n<blockquote>\n<p>instanceof<code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的</code>prototype\n我们也可以试着实现一下 <code>instanceof</code></p>\n</blockquote>\n<div><pre><code><span>function</span> <span>instanceof</span><span>(</span><span>left<span>,</span> right</span><span>)</span> <span>{</span>\n  <span>// 获得类型的原型</span>\n  <span>let</span> prototype <span>=</span> right<span>.</span>prototype\n  <span>// 获得对象的原型</span>\n  left <span>=</span> left<span>.</span>__proto__\n  <span>// 判断对象的类型是否等于类型的原型</span>\n  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>left <span>===</span> <span>null</span><span>)</span>\n      <span>return</span> <span>false</span>\n    <span>if</span> <span>(</span>prototype <span>===</span> left<span>)</span>\n      <span>return</span> <span>true</span>\n    left <span>=</span> left<span>.</span>__proto__\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_7-this\"> 7 this</h3>\n<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>a<span>)</span>\n<span>}</span>\n<span>var</span> a <span>=</span> <span>1</span>\n<span>foo</span><span>(</span><span>)</span>\n\n<span>var</span> obj <span>=</span> <span>{</span>\n  a<span>:</span> <span>2</span><span>,</span>\n  foo<span>:</span> foo\n<span>}</span>\nobj<span>.</span><span>foo</span><span>(</span><span>)</span>\n\n<span>// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span>\n\n<span>// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向</span>\n<span>var</span> c <span>=</span> <span>new</span> <span>foo</span><span>(</span><span>)</span>\nc<span>.</span>a <span>=</span> <span>3</span>\nconsole<span>.</span><span>log</span><span>(</span>c<span>.</span>a<span>)</span>\n\n<span>// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>\n<p>看看箭头函数中的 <code>this</code></p>\n</blockquote>\n<div><pre><code><span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>a</span><span>(</span><span>)</span><span>(</span><span>)</span><span>(</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code>。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是 <code>window</code>。并且 this 一旦绑定了上下文，就不会被任何代码改变</p>\n</blockquote>\n<h3 id=\"_8-执行上下文\"> 8 执行上下文</h3>\n<blockquote>\n<p>当执行 JS 代码时，会产生三种执行上下文</p>\n</blockquote>\n<ul>\n<li>全局执行上下文</li>\n<li>函数执行上下文</li>\n<li><code>eval</code> 执行上下文</li>\n</ul>\n<blockquote>\n<p>每个执行上下文中都有三个重要的属性</p>\n</blockquote>\n<ul>\n<li>变量对象（<code>VO</code>），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li>\n<li>作用域链（<code>JS</code> 采用词法作用域，也就是说变量的作用域是在定义时就决定了）</li>\n<li><code>this</code></li>\n</ul>\n<div><pre><code><span>var</span> a <span>=</span> <span>10</span>function <span>foo</span><span>(</span><span>i</span><span>)</span> <span>{</span>  <span>var</span> b <span>=</span> <span>20</span><span>}</span><span>foo</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。</p>\n</blockquote>\n<div><pre><code>stack <span>=</span> <span>[</span>    globalContext<span>,</span>    fooContext<span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>对于全局上下文来说，<code>VO</code>大概是这样的</p>\n</blockquote>\n<div><pre><code>globalContext<span>.</span><span>VO</span> <span>===</span> globe\nglobalContext<span>.</span><span>VO</span> <span>=</span> <span>{</span>\n  a<span>:</span> <span>undefined</span><span>,</span>\n  foo<span>:</span> <span>&lt;</span>Function<span>></span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>对于函数 <code>foo</code> 来说，<code>VO</code> 不能访问，只能访问到活动对象（<code>AO</code>）</p>\n</blockquote>\n<div><pre><code>fooContext<span>.</span><span>VO</span> <span>===</span> foo<span>.</span><span>AO</span>\nfooContext<span>.</span><span>AO</span> <span>{</span>\n  i<span>:</span> <span>undefined</span><span>,</span>\n  b<span>:</span> <span>undefined</span><span>,</span>\n  arguments<span>:</span> <span>&lt;</span><span>></span>\n<span>}</span>\n<span>// arguments 是函数独有的对象(箭头函数没有)</span>\n<span>// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span>\n<span>// 该对象中的 `callee` 属性代表函数本身</span>\n<span>// `caller` 属性代表函数的调用者</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<p>对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 <code>[[Scope]]</code>属性查找上级变量</p>\n</blockquote>\n<div><pre><code>fooContext<span>.</span><span>[</span><span>[</span>Scope<span>]</span><span>]</span> <span>=</span> <span>[</span>\n  globalContext<span>.</span><span>VO</span>\n<span>]</span>\nfooContext<span>.</span>Scope <span>=</span> fooContext<span>.</span><span>[</span><span>[</span>Scope<span>]</span><span>]</span> <span>+</span> fooContext<span>.</span><span>VO</span>\nfooContext<span>.</span>Scope <span>=</span> <span>[</span>\n  fooContext<span>.</span><span>VO</span><span>,</span>\n  globalContext<span>.</span><span>VO</span>\n<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>接下来让我们看一个老生常谈的例子，<code>var</code></p>\n</blockquote>\n<div><pre><code><span>b</span><span>(</span><span>)</span> <span>// call b</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span> <span>// undefined</span>\n\n<span>var</span> a <span>=</span> <span>'Hello world'</span>\n\n<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'call b'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 <code>VO</code>），<code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</p>\n</blockquote>\n<ul>\n<li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li>\n</ul>\n<div><pre><code><span>b</span><span>(</span><span>)</span> <span>// call b second</span>\n\n<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'call b fist'</span><span>)</span>\n<span>}</span>\n<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'call b second'</span><span>)</span>\n<span>}</span>\n<span>var</span> b <span>=</span> <span>'Hello world'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p><code>var</code>会产生很多错误，所以在 <code>ES6</code>中引入了 <code>let</code>。<code>let</code>不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。</p>\n</blockquote>\n<ul>\n<li>对于非匿名的立即执行函数需要注意以下一点</li>\n</ul>\n<div><pre><code><span>var</span> foo <span>=</span> <span>1</span>\n<span>(</span><span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>\n  foo <span>=</span> <span>10</span>\n  console<span>.</span><span>log</span><span>(</span>foo<span>)</span>\n<span>}</span><span>(</span><span>)</span><span>)</span> <span>// -> ƒ foo() { foo = 10 ; console.log(foo) }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>因为当 <code>JS</code> 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code>，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>\n</blockquote>\n<div><pre><code>specialObject <span>=</span> <span>{</span><span>}</span><span>;</span>\n\nScope <span>=</span> specialObject <span>+</span> Scope<span>;</span>\n\nfoo <span>=</span> <span>new</span> <span>FunctionExpression</span><span>;</span>\nfoo<span>.</span><span>[</span><span>[</span>Scope<span>]</span><span>]</span> <span>=</span> Scope<span>;</span>\nspecialObject<span>.</span>foo <span>=</span> foo<span>;</span> <span>// {DontDelete}, {ReadOnly}</span>\n\n<span>delete</span> Scope<span>[</span><span>0</span><span>]</span><span>;</span> <span>// remove specialObject from the front of scope chain</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_9-闭包\"> 9 闭包</h3>\n<blockquote>\n<p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>A</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> a <span>=</span> <span>1</span>\n  <span>function</span> <span>B</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>a<span>)</span>\n  <span>}</span>\n  <span>return</span> <span>B</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>你是否会疑惑，为什么函数 <code>A</code>已经弹出调用栈了，为什么函数 <code>B</code> 还能引用到函数 <code>A</code>中的变量。因为函数 <code>A</code> 中的变量这时候是存储在堆上的。现在的 <code>JS</code>引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>\n</blockquote>\n<p>经典面试题，循环中使用闭包解决 var 定义函数的问题</p>\n<div><pre><code><span>for</span> <span>(</span> <span>var</span> i<span>=</span><span>1</span><span>;</span> i<span>&lt;=</span><span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span> <span>function</span> <span>timer</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span> i <span>)</span><span>;</span>\n  <span>}</span><span>,</span> i<span>*</span><span>1000</span> <span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 <code>6</code> 了，所以会输出一堆 <code>6</code>。</li>\n<li>解决办法两种，第一种使用闭包</li>\n</ul>\n<div><pre><code><span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>(</span><span>function</span><span>(</span><span>j</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>function</span> <span>timer</span><span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>j<span>)</span><span>;</span>\n    <span>}</span><span>,</span> j <span>*</span> <span>1000</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>(</span>i<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>第二种就是使用 <code>setTimeout</code> 的第三个参数</li>\n</ul>\n<div><pre><code><span>for</span> <span>(</span> <span>var</span> i<span>=</span><span>1</span><span>;</span> i<span>&lt;=</span><span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span> <span>function</span> <span>timer</span><span>(</span><span>j</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span> j <span>)</span><span>;</span>\n  <span>}</span><span>,</span> i<span>*</span><span>1000</span><span>,</span> i<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p>\n</blockquote>\n<div><pre><code><span>for</span> <span>(</span> <span>let</span> i<span>=</span><span>1</span><span>;</span> i<span>&lt;=</span><span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span> <span>function</span> <span>timer</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span> i <span>)</span><span>;</span>\n  <span>}</span><span>,</span> i<span>*</span><span>1000</span> <span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p>\n</blockquote>\n<div><pre><code><span>{</span> <span>// 形成块级作用域</span>\n  <span>let</span> i <span>=</span> <span>0</span>\n  <span>{</span>\n    <span>let</span> ii <span>=</span> i\n    <span>setTimeout</span><span>(</span> <span>function</span> <span>timer</span><span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span> i <span>)</span><span>;</span>\n    <span>}</span><span>,</span> i<span>*</span><span>1000</span> <span>)</span><span>;</span>\n  <span>}</span>\n  i<span>++</span>\n  <span>{</span>\n    <span>let</span> ii <span>=</span> i\n  <span>}</span>\n  i<span>++</span>\n  <span>{</span>\n    <span>let</span> ii <span>=</span> i\n  <span>}</span>\n  <span>...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_10-深浅拷贝\"> 10 深浅拷贝</h3>\n<div><pre><code>letet a a <span>=</span> <span>{</span>\n  age<span>:</span> <span>1</span>\n<span>}</span>\n<span>let</span> b <span>=</span> a\na<span>.</span>age <span>=</span> <span>2</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span>age<span>)</span> <span>// 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</li>\n<li>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题</li>\n</ul>\n<p><strong>浅拷贝：</strong></p>\n<blockquote>\n<p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p>\n</blockquote>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  age<span>:</span> <span>1</span>\n<span>}</span>\n<span>let</span> b <span>=</span> Object<span>.</span><span>assign</span><span>(</span><span>{</span><span>}</span><span>,</span> a<span>)</span>\na<span>.</span>age <span>=</span> <span>2</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span>age<span>)</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>当然我们也可以通过展开运算符<code>（…）</code>来解决</p>\n</blockquote>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  age<span>:</span> <span>1</span>\n<span>}</span>\n<span>let</span> b <span>=</span> <span>{</span><span>...</span>a<span>}</span>\na<span>.</span>age <span>=</span> <span>2</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span>age<span>)</span> <span>// 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p>\n</blockquote>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  age<span>:</span> <span>1</span><span>,</span>\n  jobs<span>:</span> <span>{</span>\n    first<span>:</span> <span>'FE'</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> b <span>=</span> <span>{</span><span>...</span>a<span>}</span>\na<span>.</span>jobs<span>.</span>first <span>=</span> <span>'native'</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span>jobs<span>.</span>first<span>)</span> <span>// native</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷</p>\n</blockquote>\n<p><strong>深拷贝：</strong></p>\n<blockquote>\n<p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</p>\n</blockquote>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  age<span>:</span> <span>1</span><span>,</span>\n  jobs<span>:</span> <span>{</span>\n    first<span>:</span> <span>'FE'</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> b <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>a<span>)</span><span>)</span>\na<span>.</span>jobs<span>.</span>first <span>=</span> <span>'native'</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span>jobs<span>.</span>first<span>)</span> <span>// FE</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>但是该方法也是有局限性的：</p>\n</blockquote>\n<ul>\n<li>会忽略 <code>undefined</code></li>\n<li>不能序列化函数</li>\n<li>不能解决循环引用的对象</li>\n</ul>\n<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>\n  a<span>:</span> <span>1</span><span>,</span>\n  b<span>:</span> <span>{</span>\n    c<span>:</span> <span>2</span><span>,</span>\n    d<span>:</span> <span>3</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span>\nobj<span>.</span>c <span>=</span> obj<span>.</span>b\nobj<span>.</span>e <span>=</span> obj<span>.</span>a\nobj<span>.</span>b<span>.</span>c <span>=</span> obj<span>.</span>c\nobj<span>.</span>b<span>.</span>d <span>=</span> obj<span>.</span>b\nobj<span>.</span>b<span>.</span>e <span>=</span> obj<span>.</span>b<span>.</span>c\n<span>let</span> newObj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>newObj<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>\n<p>如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝</p>\n</blockquote>\n<ul>\n<li>在遇到函数或者 <code>undefined</code> 的时候，该对象也不能正常的序列化</li>\n</ul>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  age<span>:</span> <span>undefined</span><span>,</span>\n  <span>jobs</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>\n  name<span>:</span> <span>'poetries'</span>\n<span>}</span>\n<span>let</span> b <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>a<span>)</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>)</span> <span>// {name: \"poetries\"}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>你会发现在上述情况中，该方法会忽略掉函数和`undefined。</li>\n<li>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <code>lodash</code> 的深拷贝函数。</li>\n</ul>\n<h3 id=\"_11-模块化\"> 11 模块化</h3>\n<blockquote>\n<p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code>的模块化</p>\n</blockquote>\n<div><pre><code><span>// file a.js</span>\n<span>export</span> <span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>export</span> <span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>// file b.js</span>\n<span>export</span> <span>default</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\n<span>import</span> <span>{</span>a<span>,</span> b<span>}</span> <span>from</span> <span>'./a.js'</span>\n<span>import</span> <span>XXX</span> <span>from</span> <span>'./b.js'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>CommonJS：</strong></p>\n<blockquote>\n<p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code>解析了。</p>\n</blockquote>\n<div><pre><code><span>// a.js</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  a<span>:</span> <span>1</span>\n<span>}</span>\n<span>// or</span>\nexports<span>.</span>a <span>=</span> <span>1</span>\n\n<span>// b.js</span>\n<span>var</span> module <span>=</span> <span>require</span><span>(</span><span>'./a.js'</span><span>)</span>\nmodule<span>.</span>a <span>// -> log 1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p>\n</blockquote>\n<div><pre><code><span>var</span> module <span>=</span> <span>require</span><span>(</span><span>'./a.js'</span><span>)</span>\nmodule<span>.</span>a\n<span>// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span>\n<span>// 重要的是 module 这里，module 是 Node 独有的一个变量</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  a<span>:</span> <span>1</span>\n<span>}</span>\n<span>// 基本实现</span>\n<span>var</span> module <span>=</span> <span>{</span>\n  exports<span>:</span> <span>{</span><span>}</span> <span>// exports 就是个空对象</span>\n<span>}</span>\n<span>// 这个是为什么 exports 和 module.exports 用法相似的原因</span>\n<span>var</span> exports <span>=</span> module<span>.</span>exports\n<span>var</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>module</span><span>)</span> <span>{</span>\n  <span>// 导出的东西</span>\n  <span>var</span> a <span>=</span> <span>1</span>\n  module<span>.</span>exports <span>=</span> a\n  <span>return</span> module<span>.</span>exports\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>\n<p>再来说说 <code>module.exports</code> 和<code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。\n对于 <code>CommonJS</code> 和 <code>ES6</code> 中的模块化的两者区别是：</p>\n</blockquote>\n<ul>\n<li>前者支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li>\n<li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>\n<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li>\n<li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>\n<li>后者会编译成 <code>require/exports</code> 来执行的</li>\n</ul>\n<p><strong>AMD：</strong></p>\n<blockquote>\n<p><code>AMD</code> 是由 <code>RequireJS</code> 提出的</p>\n</blockquote>\n<div><pre><code><span>// AMD</span>\n<span>define</span><span>(</span><span>[</span><span>'./a'</span><span>,</span> <span>'./b'</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  a<span>.</span><span>do</span><span>(</span><span>)</span>\n  b<span>.</span><span>do</span><span>(</span><span>)</span>\n<span>}</span><span>)</span>\n<span>define</span><span>(</span><span>function</span><span>(</span><span>require<span>,</span> exports<span>,</span> module</span><span>)</span> <span>{</span>   \n  <span>var</span> a <span>=</span> <span>require</span><span>(</span><span>'./a'</span><span>)</span>  \n  a<span>.</span><span>doSomething</span><span>(</span><span>)</span>   \n  <span>var</span> b <span>=</span> <span>require</span><span>(</span><span>'./b'</span><span>)</span>\n  b<span>.</span><span>doSomething</span><span>(</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_12-防抖\"> 12 防抖</h3>\n<blockquote>\n<p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>\n</blockquote>\n<ul>\n<li>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作</li>\n<li>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于<code>wait</code>，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数<code>wait</code>）调用函数</li>\n</ul>\n<div><pre><code><span>// 这个是用来获取当前时间戳的</span>\n<span>function</span> <span>now</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>+</span><span>new</span> <span>Date</span><span>(</span><span>)</span>\n<span>}</span>\n<span>/**\n * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */</span>\n<span>function</span> <span>debounce</span> <span>(</span><span>func<span>,</span> wait <span>=</span> <span>50</span><span>,</span> immediate <span>=</span> <span>true</span></span><span>)</span> <span>{</span>\n  <span>let</span> timer<span>,</span> context<span>,</span> args\n\n  <span>// 延迟执行函数</span>\n  <span>const</span> <span>later</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>// 延迟函数执行完毕，清空缓存的定时器序号</span>\n    timer <span>=</span> <span>null</span>\n    <span>// 延迟执行的情况下，函数会在延迟函数中执行</span>\n    <span>// 使用到之前缓存的参数和上下文</span>\n    <span>if</span> <span>(</span><span>!</span>immediate<span>)</span> <span>{</span>\n      <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span>\n      context <span>=</span> args <span>=</span> <span>null</span>\n    <span>}</span>\n  <span>}</span><span>,</span> wait<span>)</span>\n\n  <span>// 这里返回的函数是每次实际调用的函数</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>params</span><span>)</span> <span>{</span>\n    <span>// 如果没有创建延迟执行函数（later），就创建一个</span>\n    <span>if</span> <span>(</span><span>!</span>timer<span>)</span> <span>{</span>\n      timer <span>=</span> <span>later</span><span>(</span><span>)</span>\n      <span>// 如果是立即执行，调用函数</span>\n      <span>// 否则缓存参数和调用上下文</span>\n      <span>if</span> <span>(</span>immediate<span>)</span> <span>{</span>\n        <span>func</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> params<span>)</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        context <span>=</span> <span>this</span>\n        args <span>=</span> params\n      <span>}</span>\n    <span>// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span>\n    <span>// 这样做延迟函数会重新计时</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>clearTimeout</span><span>(</span>timer<span>)</span>\n      timer <span>=</span> <span>later</span><span>(</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><ul>\n<li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 <code>null</code>，就可以再次点击了。</li>\n<li>对于延时执行函数来说的实现：清除定时器<code>ID</code>，如果是延迟调用就调用函数</li>\n</ul>\n<h3 id=\"_13-节流\"> 13 节流</h3>\n<blockquote>\n<p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p>\n</blockquote>\n<div><pre><code><span>/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */</span>\n_<span>.</span><span>throttle</span> <span>=</span> <span>function</span><span>(</span><span>func<span>,</span> wait<span>,</span> options</span><span>)</span> <span>{</span>\n  <span>var</span> context<span>,</span> args<span>,</span> result<span>;</span>\n  <span>var</span> timeout <span>=</span> <span>null</span><span>;</span>\n  <span>// 之前的时间戳</span>\n  <span>var</span> previous <span>=</span> <span>0</span><span>;</span>\n  <span>// 如果 options 没传则设为空对象</span>\n  <span>if</span> <span>(</span><span>!</span>options<span>)</span> options <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>// 定时器回调函数</span>\n  <span>var</span> <span>later</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 如果设置了 leading，就将 previous 设为 0</span>\n    <span>// 用于下面函数的第一个 if 判断</span>\n    previous <span>=</span> options<span>.</span>leading <span>===</span> <span>false</span> <span>?</span> <span>0</span> <span>:</span> _<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n    <span>// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span>\n    timeout <span>=</span> <span>null</span><span>;</span>\n    result <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>!</span>timeout<span>)</span> context <span>=</span> args <span>=</span> <span>null</span><span>;</span>\n  <span>}</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>// 获得当前时间戳</span>\n  <span>var</span> now <span>=</span> _<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n  <span>// 首次进入前者肯定为 true</span>\n  <span>// 如果需要第一次不执行函数</span>\n  <span>// 就将上次时间戳设为当前的</span>\n  <span>// 这样在接下来计算 remaining 的值时会大于0</span>\n  <span>if</span> <span>(</span><span>!</span>previous <span>&amp;&amp;</span> options<span>.</span>leading <span>===</span> <span>false</span><span>)</span> previous <span>=</span> now<span>;</span>\n  <span>// 计算剩余时间</span>\n  <span>var</span> remaining <span>=</span> wait <span>-</span> <span>(</span>now <span>-</span> previous<span>)</span><span>;</span>\n  context <span>=</span> <span>this</span><span>;</span>\n  args <span>=</span> arguments<span>;</span>\n  <span>// 如果当前调用已经大于上次调用时间 + wait</span>\n  <span>// 或者用户手动调了时间</span>\n  <span>// 如果设置了 trailing，只会进入这个条件</span>\n  <span>// 如果没有设置 leading，那么第一次会进入这个条件</span>\n  <span>// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span>\n  <span>// 其实还是会进入的，因为定时器的延时</span>\n  <span>// 并不是准确的时间，很可能你设置了2秒</span>\n  <span>// 但是他需要2.2秒才触发，这时候就会进入这个条件</span>\n  <span>if</span> <span>(</span>remaining <span>&lt;=</span> <span>0</span> <span>||</span> remaining <span>></span> wait<span>)</span> <span>{</span>\n    <span>// 如果存在定时器就清理掉否则会调用二次回调</span>\n    <span>if</span> <span>(</span>timeout<span>)</span> <span>{</span>\n      <span>clearTimeout</span><span>(</span>timeout<span>)</span><span>;</span>\n      timeout <span>=</span> <span>null</span><span>;</span>\n    <span>}</span>\n    previous <span>=</span> now<span>;</span>\n    result <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>!</span>timeout<span>)</span> context <span>=</span> args <span>=</span> <span>null</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>timeout <span>&amp;&amp;</span> options<span>.</span>trailing <span>!==</span> <span>false</span><span>)</span> <span>{</span>\n    <span>// 判断是否设置了定时器和 trailing</span>\n    <span>// 没有的话就开启一个定时器</span>\n    <span>// 并且不能不能同时设置 leading 和 trailing</span>\n    timeout <span>=</span> <span>setTimeout</span><span>(</span>later<span>,</span> remaining<span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> result<span>;</span>\n  <span>}</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h3 id=\"_14-继承\"> 14 继承</h3>\n<blockquote>\n<p>在 ES5 中，我们可以使用如下方式解决继承的问题</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>Super</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>Super</span><span>.</span>prototype<span>.</span><span>getNumber</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>1</span>\n<span>}</span>\n\n<span>function</span> <span>Sub</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>let</span> s <span>=</span> <span>new</span> <span>Sub</span><span>(</span><span>)</span>\n<span>Sub</span><span>.</span>prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>Super</span><span>.</span>prototype<span>,</span> <span>{</span>\n  constructor<span>:</span> <span>{</span>\n    value<span>:</span> Sub<span>,</span>\n    enumerable<span>:</span> <span>false</span><span>,</span>\n    writable<span>:</span> <span>true</span><span>,</span>\n    configurable<span>:</span> <span>true</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li>以上继承实现思路就是将子类的原型设置为父类的原型</li>\n<li>在 <code>ES6</code> 中，我们可以通过 <code>class</code> 语法轻松解决这个问题</li>\n</ul>\n<div><pre><code><span>class</span> <span>MyDate</span> <span>extends</span> <span>Date</span> <span>{</span>\n  <span>test</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span><span>getTime</span><span>(</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> myDate <span>=</span> <span>new</span> <span>MyDate</span><span>(</span><span>)</span>\nmyDate<span>.</span><span>test</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>但是 <code>ES6</code> 不是所有浏览器都兼容，所以我们需要使用 <code>Babel</code> 来编译这段代码。</li>\n<li>如果你使用编译过得代码调用 <code>myDate.test()</code>你会惊奇地发现出现了报错</li>\n</ul>\n<blockquote>\n<p>因为在 <code>JS</code> 底层有限制，如果不是由 <code>Date</code>构造出来的实例的话，是不能调用 <code>Date</code> 里的函数的。所以这也侧面的说明了：<code>ES6</code> 中的 <code>class</code> 继承与 <code>ES5</code> 中的一般继承写法是不同的。</p>\n</blockquote>\n<ul>\n<li>既然底层限制了实例必须由 <code>Date</code> 构造出来，那么我们可以改变下思路实现继承</li>\n</ul>\n<div><pre><code><span>function</span> <span>MyData</span><span>(</span><span>)</span> <span>{</span>\n\n<span>}</span>\n<span>MyData</span><span>.</span>prototype<span>.</span><span>test</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span><span>getTime</span><span>(</span><span>)</span>\n<span>}</span>\n<span>let</span> d <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span>\nObject<span>.</span><span>setPrototypeOf</span><span>(</span>d<span>,</span> <span>MyData</span><span>.</span>prototype<span>)</span>\nObject<span>.</span><span>setPrototypeOf</span><span>(</span><span>MyData</span><span>.</span>prototype<span>,</span> <span>Date</span><span>.</span>prototype<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 <code>_proto__</code>转而连接到子类的 <code>prototype</code>=&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</li>\n<li>通过以上方法实现的继承就可以完美解决 <code>JS</code> 底层的这个限制</li>\n</ul>\n<h3 id=\"_15-call-apply-bind\"> 15 call, apply, bind</h3>\n<ul>\n<li><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</li>\n<li>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组</li>\n</ul>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  value<span>:</span> <span>1</span>\n<span>}</span>\n<span>function</span> <span>getValue</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>name<span>)</span>\n  console<span>.</span><span>log</span><span>(</span>age<span>)</span>\n  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>value<span>)</span>\n<span>}</span>\n<span>getValue</span><span>.</span><span>call</span><span>(</span>a<span>,</span> <span>'yck'</span><span>,</span> <span>'24'</span><span>)</span>\n<span>getValue</span><span>.</span><span>apply</span><span>(</span>a<span>,</span> <span>[</span><span>'yck'</span><span>,</span> <span>'24'</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_16-promise-实现\"> 16 Promise 实现</h3>\n<ul>\n<li>可以把 <code>Promise</code> 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code>和 <code>reject</code> ，将状态转变为 <code>resolved</code>或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</li>\n<li><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。</li>\n<li>对于 <code>then</code>来说，本质上可以把它看成是 <code>flatMap</code></li>\n</ul>\n<div><pre><code><span>// 三种状态</span>\n<span>const</span> <span>PENDING</span> <span>=</span> <span>\"pending\"</span><span>;</span>\n<span>const</span> <span>RESOLVED</span> <span>=</span> <span>\"resolved\"</span><span>;</span>\n<span>const</span> <span>REJECTED</span> <span>=</span> <span>\"rejected\"</span><span>;</span>\n<span>// promise 接收一个函数参数，该函数会立即执行</span>\n<span>function</span> <span>MyPromise</span><span>(</span><span>fn</span><span>)</span> <span>{</span>\n  <span>let</span> _this <span>=</span> <span>this</span><span>;</span>\n  _this<span>.</span>currentState <span>=</span> <span>PENDING</span><span>;</span>\n  _this<span>.</span>value <span>=</span> <span>undefined</span><span>;</span>\n  <span>// 用于保存 then 中的回调，只有当 promise</span>\n  <span>// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span>\n  _this<span>.</span>resolvedCallbacks <span>=</span> <span>[</span><span>]</span><span>;</span>\n  _this<span>.</span>rejectedCallbacks <span>=</span> <span>[</span><span>]</span><span>;</span>\n\n  _this<span>.</span><span>resolve</span> <span>=</span> <span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>value <span>instanceof</span> <span>MyPromise</span><span>)</span> <span>{</span>\n      <span>// 如果 value 是个 Promise，递归执行</span>\n      <span>return</span> value<span>.</span><span>then</span><span>(</span>_this<span>.</span>resolve<span>,</span> _this<span>.</span>reject<span>)</span>\n    <span>}</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>// 异步执行，保证执行顺序</span>\n      <span>if</span> <span>(</span>_this<span>.</span>currentState <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        _this<span>.</span>currentState <span>=</span> <span>RESOLVED</span><span>;</span>\n        _this<span>.</span>value <span>=</span> value<span>;</span>\n        _this<span>.</span>resolvedCallbacks<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>cb</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span><span>;</span>\n\n  _this<span>.</span><span>reject</span> <span>=</span> <span>function</span> <span>(</span><span>reason</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>// 异步执行，保证执行顺序</span>\n      <span>if</span> <span>(</span>_this<span>.</span>currentState <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n        _this<span>.</span>currentState <span>=</span> <span>REJECTED</span><span>;</span>\n        _this<span>.</span>value <span>=</span> reason<span>;</span>\n        _this<span>.</span>rejectedCallbacks<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>cb</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n  <span>// 用于解决以下问题</span>\n  <span>// new Promise(() => throw Error('error))</span>\n  <span>try</span> <span>{</span>\n    <span>fn</span><span>(</span>_this<span>.</span>resolve<span>,</span> _this<span>.</span>reject<span>)</span><span>;</span>\n  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n    _this<span>.</span><span>reject</span><span>(</span>e<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>MyPromise</span><span>.</span>prototype<span>.</span><span>then</span> <span>=</span> <span>function</span> <span>(</span><span>onResolved<span>,</span> onRejected</span><span>)</span> <span>{</span>\n  <span>var</span> self <span>=</span> <span>this</span><span>;</span>\n  <span>// 规范 2.2.7，then 必须返回一个新的 promise</span>\n  <span>var</span> promise2<span>;</span>\n  <span>// 规范 2.2.onResolved 和 onRejected 都为可选参数</span>\n  <span>// 如果类型不是函数需要忽略，同时也实现了透传</span>\n  <span>// Promise.resolve(4).then().then((value) => console.log(value))</span>\n  onResolved <span>=</span> <span>typeof</span> onResolved <span>===</span> <span>'function'</span> <span>?</span> <span>onResolved</span> <span>:</span> <span>v</span> <span>=></span> v<span>;</span>\n  onRejected <span>=</span> <span>typeof</span> onRejected <span>===</span> <span>'function'</span> <span>?</span> <span>onRejected</span> <span>:</span> <span>r</span> <span>=></span> <span>throw</span> r<span>;</span>\n\n  <span>if</span> <span>(</span>self<span>.</span>currentState <span>===</span> <span>RESOLVED</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n      <span>// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span>\n      <span>// 所以用了 setTimeout 包裹下</span>\n      <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>var</span> x <span>=</span> <span>onResolved</span><span>(</span>self<span>.</span>value<span>)</span><span>;</span>\n          <span>resolutionProcedure</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>reason<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>reason<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>if</span> <span>(</span>self<span>.</span>currentState <span>===</span> <span>REJECTED</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n      <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>// 异步执行onRejected</span>\n        <span>try</span> <span>{</span>\n          <span>var</span> x <span>=</span> <span>onRejected</span><span>(</span>self<span>.</span>value<span>)</span><span>;</span>\n          <span>resolutionProcedure</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>reason<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>reason<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>if</span> <span>(</span>self<span>.</span>currentState <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>promise2 <span>=</span> <span>new</span> <span>MyPromise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n      self<span>.</span>resolvedCallbacks<span>.</span><span>push</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>// 考虑到可能会有报错，所以使用 try/catch 包裹</span>\n        <span>try</span> <span>{</span>\n          <span>var</span> x <span>=</span> <span>onResolved</span><span>(</span>self<span>.</span>value<span>)</span><span>;</span>\n          <span>resolutionProcedure</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>r<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>r<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span><span>)</span><span>;</span>\n\n      self<span>.</span>rejectedCallbacks<span>.</span><span>push</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>var</span> x <span>=</span> <span>onRejected</span><span>(</span>self<span>.</span>value<span>)</span><span>;</span>\n          <span>resolutionProcedure</span><span>(</span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span>r<span>)</span> <span>{</span>\n          <span>reject</span><span>(</span>r<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n<span>// 规范 2.3</span>\n<span>function</span> <span>resolutionProcedure</span><span>(</span><span>promise2<span>,</span> x<span>,</span> resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span>\n  <span>if</span> <span>(</span>promise2 <span>===</span> x<span>)</span> <span>{</span>\n    <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>\"Error\"</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>// 规范 2.3.2</span>\n  <span>// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span>\n  <span>if</span> <span>(</span>x <span>instanceof</span> <span>MyPromise</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>x<span>.</span>currentState <span>===</span> <span>PENDING</span><span>)</span> <span>{</span>\n      x<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n        <span>// 再次调用该函数是为了确认 x resolve 的</span>\n        <span>// 参数是什么类型，如果是基本类型就再次 resolve</span>\n        <span>// 把值传给下个 then</span>\n        <span>resolutionProcedure</span><span>(</span>promise2<span>,</span> value<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n      <span>}</span><span>,</span> reject<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      x<span>.</span><span>then</span><span>(</span>resolve<span>,</span> reject<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span><span>;</span>\n  <span>}</span>\n  <span>// 规范 2.3.3.3.3</span>\n  <span>// reject 或者 resolve 其中一个执行过得话，忽略其他的</span>\n  <span>let</span> called <span>=</span> <span>false</span><span>;</span>\n  <span>// 规范 2.3.3，判断 x 是否为对象或者函数</span>\n  <span>if</span> <span>(</span>x <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span><span>typeof</span> x <span>===</span> <span>\"object\"</span> <span>||</span> <span>typeof</span> x <span>===</span> <span>\"function\"</span><span>)</span><span>)</span> <span>{</span>\n    <span>// 规范 2.3.3.2，如果不能取出 then，就 reject</span>\n    <span>try</span> <span>{</span>\n      <span>// 规范 2.3.3.1</span>\n      <span>let</span> then <span>=</span> x<span>.</span>then<span>;</span>\n      <span>// 如果 then 是函数，调用 x.then</span>\n      <span>if</span> <span>(</span><span>typeof</span> then <span>===</span> <span>\"function\"</span><span>)</span> <span>{</span>\n        <span>// 规范 2.3.3.3</span>\n        <span>then</span><span>.</span><span>call</span><span>(</span>\n          x<span>,</span>\n          <span>y</span> <span>=></span> <span>{</span>\n            <span>if</span> <span>(</span>called<span>)</span> <span>return</span><span>;</span>\n            called <span>=</span> <span>true</span><span>;</span>\n            <span>// 规范 2.3.3.3.1</span>\n            <span>resolutionProcedure</span><span>(</span>promise2<span>,</span> y<span>,</span> resolve<span>,</span> reject<span>)</span><span>;</span>\n          <span>}</span><span>,</span>\n          <span>e</span> <span>=></span> <span>{</span>\n            <span>if</span> <span>(</span>called<span>)</span> <span>return</span><span>;</span>\n            called <span>=</span> <span>true</span><span>;</span>\n            <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>// 规范 2.3.3.4</span>\n        <span>resolve</span><span>(</span>x<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>called<span>)</span> <span>return</span><span>;</span>\n      called <span>=</span> <span>true</span><span>;</span>\n      <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>// 规范 2.3.4，x 为基本类型</span>\n    <span>resolve</span><span>(</span>x<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br></div></div><h3 id=\"_17-generator-实现\"> 17 Generator 实现</h3>\n<blockquote>\n<p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p>\n</blockquote>\n<div><pre><code><span>// 使用 * 表示这是一个 Generator 函数</span>\n<span>// 内部可以通过 yield 暂停代码</span>\n<span>// 通过调用 next 恢复执行</span>\n<span>function</span><span>*</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> a <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>;</span>\n  <span>yield</span> <span>2</span><span>;</span>\n  <span>yield</span> <span>3</span><span>;</span>\n<span>}</span>\n<span>let</span> b <span>=</span> <span>test</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// >  { value: 2, done: false }</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// >  { value: 3, done: false }</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// >  { value: undefined, done: true }</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>\n<p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code>函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code>函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p>\n</blockquote>\n<div><pre><code><span>// cb 也就是编译过的 test 函数</span>\n<span>function</span> <span>generator</span><span>(</span><span>cb</span><span>)</span> <span>{</span>\n  <span>return</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>var</span> object <span>=</span> <span>{</span>\n      next<span>:</span> <span>0</span><span>,</span>\n      <span>stop</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n    <span>}</span><span>;</span>\n\n    <span>return</span> <span>{</span>\n      <span>next</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n        <span>var</span> ret <span>=</span> <span>cb</span><span>(</span>object<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>ret <span>===</span> <span>undefined</span><span>)</span> <span>return</span> <span>{</span> value<span>:</span> <span>undefined</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span><span>;</span>\n        <span>return</span> <span>{</span>\n          value<span>:</span> ret<span>,</span>\n          done<span>:</span> <span>false</span>\n        <span>}</span><span>;</span>\n      <span>}</span>\n    <span>}</span><span>;</span>\n  <span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span>\n<span>function</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n  <span>var</span> a<span>;</span>\n  <span>return</span> <span>generator</span><span>(</span><span>function</span><span>(</span><span>_context</span><span>)</span> <span>{</span>\n    <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{</span>\n      <span>switch</span> <span>(</span><span>(</span>_context<span>.</span>prev <span>=</span> _context<span>.</span>next<span>)</span><span>)</span> <span>{</span>\n        <span>// 可以发现通过 yield 将代码分割成几块</span>\n        <span>// 每次执行 next 函数就执行一块代码</span>\n        <span>// 并且表明下次需要执行哪块代码</span>\n        <span>case</span> <span>0</span><span>:</span>\n          a <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>;</span>\n          _context<span>.</span>next <span>=</span> <span>4</span><span>;</span>\n          <span>return</span> <span>2</span><span>;</span>\n        <span>case</span> <span>4</span><span>:</span>\n          _context<span>.</span>next <span>=</span> <span>6</span><span>;</span>\n          <span>return</span> <span>3</span><span>;</span>\n        <span>// 执行完毕</span>\n        <span>case</span> <span>6</span><span>:</span>\n        <span>case</span> <span>\"end\"</span><span>:</span>\n          <span>return</span> _context<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id=\"_18-proxy\"> 18 Proxy</h3>\n<blockquote>\n<p><code>Proxy</code> 是 <code>ES6</code> 中新增的功能，可以用来自定义对象中的操作</p>\n</blockquote>\n<div><pre><code><span>let</span> p <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handler<span>)</span><span>;</span>\n<span>// `target` 代表需要添加代理的对象</span>\n<span>// `handler` 用来自定义对象中的操作</span>\n可以很方便的使用 Proxy 来实现一个数据绑定和监听\n\n<span>let</span> <span>onWatch</span> <span>=</span> <span>(</span><span>obj<span>,</span> setBind<span>,</span> getLogger</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> handler <span>=</span> <span>{</span>\n    <span>get</span><span>(</span>target<span>,</span> property<span>,</span> receiver<span>)</span> <span>{</span>\n      <span>getLogger</span><span>(</span>target<span>,</span> property<span>)</span>\n      <span>return</span> Reflect<span>.</span><span>get</span><span>(</span>target<span>,</span> property<span>,</span> receiver<span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n    <span>set</span><span>(</span>target<span>,</span> property<span>,</span> value<span>,</span> receiver<span>)</span> <span>{</span>\n      <span>setBind</span><span>(</span>value<span>)</span><span>;</span>\n      <span>return</span> Reflect<span>.</span><span>set</span><span>(</span>target<span>,</span> property<span>,</span> value<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span><span>;</span>\n  <span>return</span> <span>new</span> <span>Proxy</span><span>(</span>obj<span>,</span> handler<span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>let</span> obj <span>=</span> <span>{</span> a<span>:</span> <span>1</span> <span>}</span>\n<span>let</span> value\n<span>let</span> p <span>=</span> <span>onWatch</span><span>(</span>obj<span>,</span> <span>(</span><span>v</span><span>)</span> <span>=></span> <span>{</span>\n  value <span>=</span> v\n<span>}</span><span>,</span> <span>(</span><span>target<span>,</span> property</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>Get '</span><span><span>${</span>property<span>}</span></span><span>' = </span><span><span>${</span>target<span>[</span>property<span>]</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\np<span>.</span>a <span>=</span> <span>2</span> <span>// bind `value` to `2`</span>\np<span>.</span>a <span>// -> Get 'a' = 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>",
      "image": "https://github.com/letme350/javaScriptBase/prototype.png",
      "date_published": "2021-07-29T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.015Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "JavaScript"
      ]
    },
    {
      "title": "JavaScript上",
      "url": "https://github.com/letme350/javaScript/baseOne/",
      "id": "https://github.com/letme350/javaScript/baseOne/",
      "content_html": "<h1 id=\"javascript上\"> JavaScript上</h1>\n<h2 id=\"javascript基础\"> JavaScript基础</h2>\n<h3 id=\"_1-闭包\"> 1 闭包</h3>\n<ul>\n<li>闭包就是能够读取其他函数内部变量的函数</li>\n<li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li>\n<li>闭包的特性：\n<ul>\n<li>函数内再嵌套函数</li>\n<li>内部函数可以引用外层的参数和变量</li>\n<li>参数和变量不会被垃圾回收机制回收</li>\n</ul>\n</li>\n</ul>\n<p><strong>说说你对闭包的理解！</strong></p>\n<ul>\n<li>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li>\n<li>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li>\n<li>闭包的另一个用处，是封装对象的私有属性和私有方法</li>\n<li><strong>好处</strong>：能够实现封装和缓存等；</li>\n<li><strong>坏处</strong>：就是消耗内存、不正当使用会造成内存溢出的问题</li>\n</ul>\n<p><strong>使用闭包的注意点！</strong></p>\n<ul>\n<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</li>\n<li>解决方法是，在退出函数之前，将不使用的局部变量全部删除</li>\n</ul>\n<h3 id=\"_2-说说你对作用域链的理解\"> 2 说说你对作用域链的理解</h3>\n<ul>\n<li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li>\n<li>简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li>\n</ul>\n<h3 id=\"_3-javascript原型-原型链-有什么特点\"> 3 JavaScript原型，原型链 ? 有什么特点？</h3>\n<ul>\n<li>每个对象都会在其内部初始化一个属性，就是<code>prototype</code>(原型)，当我们访问一个对象的属性时</li>\n<li>如果这个对象内部不存在这个属性，那么他就会去<code>prototype</code>里找这个属性，这个<code>prototype</code>又会有自己的<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li>\n<li>关系：<code>instance.constructor.prototype = instance.__proto__</code></li>\n<li>特点：\n<ul>\n<li><code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li>\n</ul>\n</li>\n<li>当我们需要一个属性的时，<code>Javascript</code>引擎会先看当前对象中是否有这个属性， 如果没有的</li>\n<li>就会查找他的<code>Prototype</code>对象是否有这个属性，如此递推下去，一直检索到 <code>Object</code> 内建对象</li>\n<li><strong>原型：</strong>\n<ul>\n<li><code>JavaScript</code>的所有对象中都包含了一个 <code>[__proto__]</code> 内部属性，这个属性所对应的就是该对象的原型</li>\n<li>JavaScript的函数对象，除了原型 <code>[__proto__]</code> 之外，还预置了 <code>prototype</code> 属性</li>\n<li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 <code>[__proto__]</code>。</li>\n</ul>\n</li>\n<li><strong>原型链：</strong>\n<ul>\n<li>当一个对象调用的属性/方法自身不存在时，就会去自己 <code>[__proto__]</code> 关联的前辈 <code>prototype</code> 对象上去找</li>\n<li>如果没找到，就会去该 <code>prototype</code> 原型 <code>[__proto__]</code> 关联的前辈 <code>prototype</code> 去找。依次类推，直到找到属性/方法或 <code>undefined</code> 为止。从而形成了所谓的“原型链”</li>\n</ul>\n</li>\n<li><strong>原型特点：</strong>\n<ul>\n<li><code>JavaScript</code>对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_4-请解释什么是事件代理\"> 4 请解释什么是事件代理</h3>\n<ul>\n<li>事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>\n<li>可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li>\n<li>可以实现当新增子对象时无需再次对其绑定</li>\n</ul>\n<h3 id=\"_5-javascript如何实现继承\"> 5 Javascript如何实现继承？</h3>\n<ul>\n<li>构造继承</li>\n<li>原型继承</li>\n<li>实例继承</li>\n<li>拷贝继承</li>\n<li>原型<code>prototype</code>机制或<code>apply</code>和<code>call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li>\n</ul>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'wang'</span><span>;</span>\n<span>}</span>\n\n<span>function</span> <span>Child</span><span>(</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>age <span>=</span> <span>28</span><span>;</span>\n<span>}</span>\n    \n<span>Child</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>)</span><span>;</span><span>//继承了Parent，通过原型</span>\n\n<span>var</span> demo <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>)</span><span>;</span>\n<span>alert</span><span>(</span>demo<span>.</span>age<span>)</span><span>;</span>\n<span>alert</span><span>(</span>demo<span>.</span>name<span>)</span><span>;</span><span>//得到被继承的属性</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_6-谈谈this对象的理解\"> 6 谈谈This对象的理解</h3>\n<ul>\n<li><code>this</code>总是指向函数的直接调用者（而非间接调用者）</li>\n<li>如果有<code>new</code>关键字，<code>this</code>指向<code>new</code>出来的那个对象</li>\n<li>在事件中，<code>this</code>指向触发这个事件的对象，特殊的是，<code>IE</code>中的<code>attachEvent</code>中的<code>this</code>总是指向全局对象<code>Window</code></li>\n</ul>\n<h3 id=\"_7-事件模型\"> 7 事件模型</h3>\n<blockquote>\n<p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>\n</blockquote>\n<ul>\n<li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>\n<li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>\n<li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>\n<li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li>\n<li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li>\n</ul>\n<h3 id=\"_8-new操作符具体干了什么呢\"> 8 new操作符具体干了什么呢?</h3>\n<ul>\n<li>创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型</li>\n<li>属性和方法被加入到 <code>this</code> 引用的对象中</li>\n<li>新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code></li>\n</ul>\n<h3 id=\"_9-ajax原理\"> 9 Ajax原理</h3>\n<ul>\n<li><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>\n<li><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</li>\n</ul>\n<div><pre><code><span>/** 1. 创建连接 **/</span>\n<span>var</span> xhr <span>=</span> <span>null</span><span>;</span>\nxhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span>\n<span>/** 2. 连接服务器 **/</span>\nxhr<span>.</span><span>open</span><span>(</span><span>'get'</span><span>,</span> url<span>,</span> <span>true</span><span>)</span>\n<span>/** 3. 发送请求 **/</span>\nxhr<span>.</span><span>send</span><span>(</span><span>null</span><span>)</span><span>;</span>\n<span>/** 4. 接受请求 **/</span>\nxhr<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>if</span><span>(</span>xhr<span>.</span>readyState <span>==</span> <span>4</span><span>)</span><span>{</span>\n    <span>if</span><span>(</span>xhr<span>.</span>status <span>==</span> <span>200</span><span>)</span><span>{</span>\n      <span>success</span><span>(</span>xhr<span>.</span>responseText<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span> \n      <span>/** false **/</span>\n      fail <span>&amp;&amp;</span> <span>fail</span><span>(</span>xhr<span>.</span>status<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>ajax 有那些优缺点?</strong></p>\n<ul>\n<li>优点：\n<ul>\n<li>通过异步模式，提升了用户体验.</li>\n<li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li>\n<li><code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>\n<li><code>Ajax</code>可以实现动态不刷新（局部刷新）</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>安全问题 <code>AJAX</code>暴露了与服务器交互的细节。</li>\n<li>对搜索引擎的支持比较弱。</li>\n<li>不容易调试。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_10-如何解决跨域问题\"> 10 如何解决跨域问题?</h3>\n<blockquote>\n<p>首先了解下浏览器的同源策略 同源策略<code>/SOP（Same origin policy）</code>是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。所谓同源是指&quot;<strong>协议+域名+端口</strong>&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源</p>\n</blockquote>\n<p><strong>那么怎样解决跨域问题的呢？</strong></p>\n<ul>\n<li><strong>通过jsonp跨域</strong></li>\n</ul>\n<div><pre><code><span>var</span> script <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'script'</span><span>)</span><span>;</span>\nscript<span>.</span>type <span>=</span> <span>'text/javascript'</span><span>;</span>\n\n<span>// 传参并指定回调执行函数为onBack</span>\nscript<span>.</span>src <span>=</span> <span>'http://www.....:8080/login?user=admin&amp;callback=onBack'</span><span>;</span>\ndocument<span>.</span>head<span>.</span><span>appendChild</span><span>(</span>script<span>)</span><span>;</span>\n\n<span>// 回调执行函数</span>\n<span>function</span> <span>onBack</span><span>(</span><span>res</span><span>)</span> <span>{</span>\n  <span>alert</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>res<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li><strong>document.domain + iframe跨域</strong></li>\n</ul>\n<blockquote>\n<p>此方案仅限主域相同，子域不同的跨域应用场景</p>\n</blockquote>\n<p>1.）父窗口：</p>\n<div><pre><code><span><span><span>&lt;</span>iframe</span> <span>id</span><span><span>=</span><span>\"</span>iframe<span>\"</span></span> <span>src</span><span><span>=</span><span>\"</span>http://child.domain.com/b.html<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>iframe</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n    document<span>.</span>domain <span>=</span> <span>'domain.com'</span><span>;</span>\n    <span>var</span> user <span>=</span> <span>'admin'</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2.）子窗口：</p>\n<div><pre><code>document<span>.</span>domain <span>=</span> <span>'domain.com'</span><span>;</span>\n<span>// 获取父窗口中变量</span>\n<span>alert</span><span>(</span><span>'get js data from parent ---> '</span> <span>+</span> window<span>.</span>parent<span>.</span>user<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li><strong>nginx代理跨域</strong>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_46872121/article/details/111700983\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/weixin_46872121/article/details/111700983</a></li>\n</ul>\n</li>\n<li><strong>nodejs中间件代理跨域</strong>\n<ul>\n<li><a href=\"https://blog.csdn.net/sumengyzy/article/details/105521314\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/sumengyzy/article/details/105521314</a></li>\n</ul>\n</li>\n<li><strong>后端在头部信息里面设置安全域名</strong>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/e4d0e573c95c\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/e4d0e573c95c</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_11-模块化开发怎么做\"> 11 模块化开发怎么做？</h3>\n<ul>\n<li>立即执行函数,不暴露私有成员</li>\n</ul>\n<div><pre><code><span>var</span> module1 <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>var</span> _count <span>=</span> <span>0</span><span>;</span>\n  <span>var</span> <span>m1</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>//...</span>\n  <span>}</span><span>;</span>\n  <span>var</span> <span>m2</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>//...</span>\n  <span>}</span><span>;</span>\n  <span>return</span> <span>{</span>\n    m1 <span>:</span> m1<span>,</span>\n    m2 <span>:</span> m2\n  <span>}</span><span>;</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_12-异步加载js的方式有哪些\"> 12 异步加载JS的方式有哪些？</h3>\n<ul>\n<li>设置<code>&lt;script&gt;</code>属性 async=&quot;async&quot; （一旦脚本可用，则会异步执行）</li>\n<li>动态创建 <code>script DOM</code>：<code>document.createElement('script');</code></li>\n<li><code>XmlHttpRequest</code> 脚本注入</li>\n<li>异步加载库 <code>LABjs</code></li>\n<li>模块加载器 <code>Sea.js</code></li>\n</ul>\n<h3 id=\"_13-那些操作会造成内存泄漏\"> 13 那些操作会造成内存泄漏？</h3>\n<blockquote>\n<p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>\n</blockquote>\n<ul>\n<li>未使用 var 声明的全局变量</li>\n<li>闭包函数(Closures)</li>\n<li>循环引用(两个对象相互引用)</li>\n<li>控制台日志(console.log)</li>\n<li>移除存在绑定事件的DOM元素(IE)</li>\n<li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>\n</ul>\n<h3 id=\"_14-xml和json的区别\"> 14 XML和JSON的区别？</h3>\n<ul>\n<li>数据体积方面\n<ul>\n<li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>\n</ul>\n</li>\n<li>数据交互方面\n<ul>\n<li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>\n</ul>\n</li>\n<li>数据描述方面\n<ul>\n<li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li>\n</ul>\n</li>\n<li>传输速度方面\n<ul>\n<li><code>JSON</code>的速度要远远快于<code>XML</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_15-谈谈你对webpack的看法\"> 15 谈谈你对webpack的看法</h3>\n<ul>\n<li><code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包<code>Web</code>开发中所用到的<code>HTML</code>、<code>Javascript</code>、<code>CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源</li>\n</ul>\n<h3 id=\"_16-说说你对amd和commonjs的理解\"> 16 说说你对AMD和Commonjs的理解</h3>\n<ul>\n<li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>\n<li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>\n</ul>\n<h3 id=\"_17-常见web安全及防护原理\"> 17 常见web安全及防护原理</h3>\n<ul>\n<li><code>sql</code>注入原理\n<ul>\n<li>就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li>\n</ul>\n</li>\n<li>总的来说有以下几点\n<ul>\n<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li>\n<li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li>\n<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>\n<li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li>\n</ul>\n</li>\n</ul>\n<p><strong>XSS原理及防范：</strong></p>\n<ul>\n<li><code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li>\n</ul>\n<p><strong>XSS防范方法：</strong></p>\n<ul>\n<li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li>\n</ul>\n<p><strong>XSS与CSRF有什么区别吗？</strong></p>\n<ul>\n<li><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</li>\n<li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li>\n<li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li>\n</ul>\n<p><strong>CSRF的防御：</strong></p>\n<ul>\n<li>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li>\n<li>通过验证码的方法</li>\n</ul>\n<h3 id=\"_18-用过哪些设计模式\"> 18 用过哪些设计模式？</h3>\n<ul>\n<li>工厂模式：\n<ul>\n<li>工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法</li>\n<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是<code>new</code>关键字</li>\n</ul>\n</li>\n<li>构造函数模式\n<ul>\n<li>使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>\n<li>直接将属性和方法赋值给 <code>this</code>对象;</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_19-为什么要有同源限制\"> 19 为什么要有同源限制？</h3>\n<ul>\n<li>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>\n<li>举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</li>\n</ul>\n<h3 id=\"_20-offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别\"> 20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3>\n<ul>\n<li><code>offsetWidth/offsetHeight</code>返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li>\n<li><code>clientWidth/clientHeight</code>返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li>\n<li><code>scrollWidth/scrollHeight</code>返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li>\n</ul>\n<h3 id=\"_21-javascript有哪些方法定义对象\"> 21 javascript有哪些方法定义对象</h3>\n<ul>\n<li>对象字面量： <code>var obj = {};</code></li>\n<li>构造函数： <code>var obj = new Object();</code></li>\n<li>Object.create(): <code>var obj = Object.create(Object.prototype);</code></li>\n</ul>\n<h3 id=\"_22-常见兼容性问题\"> 22 常见兼容性问题？</h3>\n<ul>\n<li><code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></li>\n<li>浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*{margin:0;padding:0;}</code>来统一,，但是全局效率很低，一般是如下这样解决：</li>\n</ul>\n<div><pre><code><span>body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p</span><span>{</span>\n<span>margin</span><span>:</span>0<span>;</span>\n<span>padding</span><span>:</span>0<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li><code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</li>\n<li><code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</li>\n</ul>\n<h3 id=\"_23-说说你对promise的了解\"> 23 说说你对promise的了解</h3>\n<ul>\n<li>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：\n<ul>\n<li><code>pending:</code> 初始状态, 非 <code>fulfilled</code> 或 <code>rejected.</code></li>\n<li><code>fulfilled:</code> 成功的操作.</li>\n<li><code>rejected:</code> 失败的操作.</li>\n<li><code>settled: Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li>\n</ul>\n</li>\n<li>另外， <code>fulfilled</code>与 <code>rejected</code>一起合称 <code>settled</code></li>\n<li><code>Promise</code> 对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code>) 计算</li>\n</ul>\n<p><strong>Promise 的构造函数：</strong></p>\n<ul>\n<li>构造一个 <code>Promise</code>，最基本的用法如下：</li>\n</ul>\n<div><pre><code><span>var</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>...</span><span>)</span> <span>{</span>  <span>// succeed</span>\n\n    <span>resolve</span><span>(</span>result<span>)</span><span>;</span>\n\n  <span>}</span> <span>else</span> <span>{</span>   <span>// fails</span>\n\n    <span>reject</span><span>(</span><span>Error</span><span>(</span>errMessage<span>)</span><span>)</span><span>;</span>\n\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为<code>thenable</code>）。它的使用方法如下：</li>\n</ul>\n<div><pre><code>promise.then(onFulfilled, onRejected)\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是 <code>future</code>，<code>onFulfilled</code> 对应<code>resolve</code>, <code>onRejected</code>对应 <code>reject</code></li>\n</ul>\n<h3 id=\"_24-你觉得jquery源码有哪些写的好的地方\"> 24 你觉得jQuery源码有哪些写的好的地方</h3>\n<ul>\n<li><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li>\n<li><code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li>\n<li>有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li>\n<li><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>\n</ul>\n<h3 id=\"_25-vue、react、angular\"> 25 vue、react、angular</h3>\n<ul>\n<li><code>Vue.js</code> 一个用于创建 <code>web</code> 交互界面的库，是一个精简的 <code>MVVM</code>。它通过双向数据绑定把 <code>View</code> 层和 <code>Model</code> 层连接了起来。实际的 <code>DOM</code> 封装和输出格式都被抽象为了<code>Directives</code> 和 <code>Filters</code></li>\n<li><code>AngularJS</code> 是一个比较完善的前端<code>MVVM</code>框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 <code>Angular</code>指令</li>\n<li><code>react</code> <code>React</code> 仅仅是 <code>VIEW</code> 层是<code>facebook</code>公司。推出的一个用于构建<code>UI</code>的一个库，能够实现服务器端的渲染。用了<code>virtual dom</code>，所以性能很好。</li>\n</ul>\n<h3 id=\"_26-node的应用场景\"> 26 Node的应用场景</h3>\n<ul>\n<li>特点：\n<ul>\n<li>1、它是一个<code>Javascript</code>运行环境</li>\n<li>2、依赖于<code>Chrome V8</code>引擎进行代码解释</li>\n<li>3、事件驱动</li>\n<li>4、非阻塞<code>I/O</code></li>\n<li>5、单进程，单线程</li>\n</ul>\n</li>\n<li>优点：\n<ul>\n<li>高并发（最重要的优点）</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>1、只支持单核<code>CPU</code>，不能充分利用<code>CPU</code></li>\n<li>2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_27-谈谈你对amd、cmd的理解\"> 27 谈谈你对AMD、CMD的理解</h3>\n<ul>\n<li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>\n<li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>\n</ul>\n<p><strong>es6模块 CommonJS、AMD、CMD：</strong></p>\n<ul>\n<li><code>CommonJS</code> 的规范中，每个 <code>JavaScript</code> 文件就是一个独立的模块上下文（<code>module context</code>），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</li>\n<li><code>CommonJS</code>是同步加载模块,在浏览器中会出现堵塞情况，所以不适用</li>\n<li><code>AMD</code> 异步，需要定义回调<code>define</code>方式</li>\n<li><code>es6</code> 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量 <code>es6</code>还可以导出类、方法，自动适用严格模式</li>\n</ul>\n<h3 id=\"_28-那些操作会造成内存泄漏\"> 28 那些操作会造成内存泄漏</h3>\n<ul>\n<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>\n</ul>\n<h3 id=\"_29-web开发中会话跟踪的方法有哪些\"> 29 web开发中会话跟踪的方法有哪些</h3>\n<ul>\n<li><code>cookie</code></li>\n<li><code>session</code></li>\n<li><code>url</code>重写</li>\n<li>隐藏<code>input</code></li>\n<li><code>ip</code>地址</li>\n</ul>\n<h3 id=\"_30-js的基本数据类型和引用数据类型\"> 30 JS的基本数据类型和引用数据类型</h3>\n<ul>\n<li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></li>\n<li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></li>\n</ul>\n<h3 id=\"_31-介绍js有哪些内置对象\"> 31 介绍js有哪些内置对象</h3>\n<ul>\n<li><code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li>\n<li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code></li>\n<li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>\n</ul>\n<h3 id=\"_32-说几条写javascript的基本规范\"> 32 说几条写JavaScript的基本规范</h3>\n<ul>\n<li>不要在同一行声明多个变量</li>\n<li>请使用<code>===/!==</code>来比较<code>true/false</code>或者数值</li>\n<li>使用对象字面量替代<code>new Array</code>这种形式</li>\n<li>不要使用全局函数</li>\n<li><code>Switch</code>语句必须带有<code>default</code>分支</li>\n<li><code>If</code>语句必须使用大括号</li>\n<li><code>for-in</code>循环中的变量 应该使用<code>var</code>关键字明确限定作用域，从而避免作用域污</li>\n</ul>\n<h3 id=\"_33-javascript有几种类型的值\"> 33 JavaScript有几种类型的值</h3>\n<ul>\n<li>栈：原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）</li>\n<li>堆：引用数据类型（对象、数组和函数）</li>\n<li>两种类型的区别是：存储位置不同；</li>\n<li>原始数据类型直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>\n<li>引用数据类型存储在堆(<code>heap</code>)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</li>\n<li>在栈中的地址，取得地址后从堆中获得实体</li>\n</ul>\n<h3 id=\"_34-javascript创建对象的几种方式\"> 34 javascript创建对象的几种方式</h3>\n<blockquote>\n<p><code>javascript</code>创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用<code>JSON</code>；但写法有很多种，也能混合使用</p>\n</blockquote>\n<ul>\n<li>对象字面量的方式</li>\n</ul>\n<div><pre><code>person<span>=</span><span>{</span>firstname<span>:</span><span>\"Mark\"</span><span>,</span>lastname<span>:</span><span>\"Yun\"</span><span>,</span>age<span>:</span><span>25</span><span>,</span>eyecolor<span>:</span><span>\"black\"</span><span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>用<code>function</code>来模拟无参的构造函数</li>\n</ul>\n<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>)</span><span>{</span>\n\n<span>}</span> \n<span>var</span> person<span>=</span><span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span> <span>//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class        </span>\nperson<span>.</span>name<span>=</span><span>\"Mark\"</span><span>;</span>        \nperson<span>.</span>age<span>=</span><span>\"25\"</span><span>;</span>        \nperson<span>.</span><span>work</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>alert</span><span>(</span>person<span>.</span>name<span>+</span><span>\" hello...\"</span><span>)</span><span>;</span>\n<span>}</span>\nperson<span>.</span><span>work</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>用<code>function</code>来模拟参构造函数来实现（用<code>this</code>关键字定义构造的上下文属性）</li>\n</ul>\n<div><pre><code><span>function</span> <span>Pet</span><span>(</span><span>name<span>,</span>age<span>,</span>hobby</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name<span>=</span>name<span>;</span><span>//this作用域：当前对象       </span>\n  <span>this</span><span>.</span>age<span>=</span>age<span>;</span>       \n  <span>this</span><span>.</span>hobby<span>=</span>hobby<span>;</span>       \n  <span>this</span><span>.</span><span>eat</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>alert</span><span>(</span><span>\"我叫\"</span><span>+</span><span>this</span><span>.</span>name<span>+</span><span>\",我喜欢\"</span><span>+</span><span>this</span><span>.</span>hobby<span>+</span><span>\",是个程序员\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>var</span> maidou <span>=</span><span>new</span> <span>Pet</span><span>(</span><span>\"麦兜\"</span><span>,</span><span>25</span><span>,</span><span>\"coding\"</span><span>)</span><span>;</span><span>//实例化、创建对象</span>\nmaidou<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span><span>//调用eat方法</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>用工厂方式来创建（内置对象）</li>\n</ul>\n<div><pre><code><span>var</span> wcDog <span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>     \nwcDog<span>.</span>name<span>=</span><span>\"旺财\"</span><span>;</span>     \nwcDog<span>.</span>age<span>=</span><span>3</span><span>;</span>     \nwcDog<span>.</span><span>work</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>alert</span><span>(</span><span>\"我是\"</span><span>+</span>wcDog<span>.</span>name<span>+</span><span>\",汪汪汪......\"</span><span>)</span><span>;</span>\n<span>}</span>     \nwcDog<span>.</span><span>work</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>用原型方式来创建</li>\n</ul>\n<div><pre><code><span>function</span> <span>Dog</span><span>(</span><span>)</span><span>{</span><span>}</span>\n<span>Dog</span><span>.</span>prototype<span>.</span>name<span>=</span><span>\"旺财\"</span><span>;</span>\n<span>Dog</span><span>.</span>prototype<span>.</span><span>eat</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>alert</span><span>(</span><span>this</span><span>.</span>name<span>+</span><span>\"是个吃货\"</span><span>)</span><span>;</span>\n<span>}</span><span>var</span> \nwangcai <span>=</span><span>new</span> <span>Dog</span><span>(</span><span>)</span><span>;</span>\nwangcai<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>用混合方式来创建</li>\n</ul>\n<div><pre><code><span>function</span> <span>Car</span><span>(</span><span>name<span>,</span>price</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name<span>=</span>name<span>;</span><span>this</span><span>.</span>price<span>=</span>price<span>;</span>\n<span>}</span>\n<span>Car</span><span>.</span>prototype<span>.</span><span>sell</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>alert</span><span>(</span><span>\"我是\"</span><span>+</span><span>this</span><span>.</span>name<span>+</span><span>\"，我现在卖\"</span><span>+</span><span>this</span><span>.</span>price<span>+</span><span>\"万元\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>var</span> camry <span>=</span><span>new</span> <span>Car</span><span>(</span><span>\"凯美瑞\"</span><span>,</span><span>27</span><span>)</span><span>;</span>\ncamry<span>.</span><span>sell</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_35-eval是做什么的\"> 35 eval是做什么的</h3>\n<ul>\n<li>它的功能是把对应的字符串解析成<code>JS</code>代码并运行</li>\n<li>应该避免使用<code>eval</code>，不安全，非常耗性能（<code>2</code>次，一次解析成<code>js</code>语句，一次执行）</li>\n<li>由<code>JSON</code>字符串转换为JSON对象的时候可以用<code>eval，var obj =eval('('+ str +')')</code></li>\n</ul>\n<h3 id=\"_36-null-undefined-的区别\"> 36 null，undefined 的区别</h3>\n<ul>\n<li><code>undefined</code> 表示不存在这个值。</li>\n<li><code>undefined</code> :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></li>\n<li>例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li>\n<li><code>null</code> 表示一个对象被定义了，值为“空值”</li>\n<li><code>null</code> : 是一个对象(空对象, 没有任何属性和方法)</li>\n<li>例如作为函数的参数，表示该函数的参数不是对象；</li>\n<li>在验证<code>null</code>时，一定要使用　<code>===</code> ，因为 <code>==</code>无法分别<code>null</code> 和　<code>undefined</code></li>\n</ul>\n<h3 id=\"_37-1-2-3-map-parseint-答案是多少\"> 37 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少</h3>\n<ul>\n<li><code>[1, NaN, NaN]</code>因为 <code>parseInt</code> 需要两个参数 <code>(val, radix)</code>，其中<code>radix</code> 表示解析时用的基数。</li>\n<li><code>map</code>传了 <code>3</code>个<code>(element, index, array)</code>，对应的 <code>radix</code> 不合法导致解析失败。</li>\n</ul>\n<h3 id=\"_38-javascript-代码中的-use-strict-是什么意思\"> 38 javascript 代码中的&quot;use strict&quot;;是什么意思</h3>\n<ul>\n<li><code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>\n</ul>\n<h3 id=\"_39-json-的了解\"> 39 JSON 的了解</h3>\n<ul>\n<li><code>JSON(JavaScript Object Notation)</code> 是一种轻量级的数据交换格式</li>\n<li>它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li>\n<li><code>JSON</code>字符串转换为JSON对象:</li>\n</ul>\n<div><pre><code><span>var</span> obj <span>=</span><span>eval</span><span>(</span><span>'('</span><span>+</span> str <span>+</span><span>')'</span><span>)</span><span>;</span><span>var</span> obj <span>=</span> str<span>.</span><span>parseJSON</span><span>(</span><span>)</span><span>;</span><span>var</span> obj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>str<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>JSON</code>对象转换为JSON字符串：</li>\n</ul>\n<div><pre><code>var last=obj.toJSONString();var last=JSON.stringify(obj);\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_40-js延迟加载的方式有哪些\"> 40 js延迟加载的方式有哪些</h3>\n<ul>\n<li>设置<code>&lt;script&gt;</code>属性 <code>defer=&quot;defer&quot;</code> （脚本将在页面完成解析时执行）</li>\n<li>动态创建 <code>script DOM</code>：<code>document.createElement('script');</code></li>\n<li><code>XmlHttpRequest</code> 脚本注入</li>\n<li>延迟加载工具 <code>LazyLoad</code></li>\n</ul>\n<h3 id=\"_41-同步和异步的区别\"> 41 同步和异步的区别</h3>\n<ul>\n<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>\n<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>\n</ul>\n<h3 id=\"_42-渐进增强和优雅降级\"> 42 渐进增强和优雅降级</h3>\n<ul>\n<li>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>\n<li>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li>\n</ul>\n<h3 id=\"_43-defer和async\"> 43 defer和async</h3>\n<ul>\n<li><code>defer</code>并行加载<code>js</code>文件，会按照页面上<code>script</code>标签的顺序执行</li>\n<li><code>async</code>并行加载<code>js</code>文件，下载完成立即执行，不会按照页面上<code>script</code>标签的顺序执行</li>\n</ul>\n<h3 id=\"_44-说说严格模式的限制\"> 44 说说严格模式的限制</h3>\n<ul>\n<li>变量必须声明后再使用</li>\n<li>函数的参数不能有同名属性，否则报错</li>\n<li>不能使用with语句</li>\n<li>不能对只读属性赋值，否则报错</li>\n<li>不能使用前缀0表示八进制数，否则报错</li>\n<li>不能删除不可删除的属性，否则报错</li>\n<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>\n<li><code>eval</code>不会在它的外层作用域引入变量</li>\n<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>\n<li><code>arguments</code>不会自动反映函数参数的变化</li>\n<li>不能使用<code>arguments.callee</code></li>\n<li>不能使用<code>arguments.caller</code></li>\n<li>禁止<code>this</code>指向全局对象</li>\n<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>\n<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>\n</ul>\n<h3 id=\"_45-attribute和property的区别是什么\"> 45 attribute和property的区别是什么</h3>\n<ul>\n<li><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</li>\n<li><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</li>\n<li>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的</li>\n<li>但是对于自定义的属性来说，他们是不同步的</li>\n</ul>\n<h3 id=\"_46-谈谈你对es6的理解\"> 46 谈谈你对ES6的理解</h3>\n<ul>\n<li>新增模板字符串（为<code>JavaScript</code>提供了简单的字符串插值功能）</li>\n<li>箭头函数</li>\n<li><code>for-of</code>（用来遍历数据—例如数组中的值。）</li>\n<li><code>arguments</code>对象可被不定参数和默认参数完美代替。</li>\n<li><code>ES6</code>将p<code>romise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。</li>\n<li>增加了<code>let</code>和<code>const</code>命令，用来声明变量。</li>\n<li>增加了块级作用域。</li>\n<li><code>let</code>命令实际上就增加了块级作用域。</li>\n<li>还有就是引入<code>module</code>模块的概念</li>\n</ul>\n<h3 id=\"_47-ecmascript6-怎么写class么\"> 47 ECMAScript6 怎么写class么</h3>\n<ul>\n<li>这个语法糖可以让有<code>OOP</code>基础的人更快上手<code>js</code>，至少是一个官方的实现了</li>\n<li>但对熟悉<code>js</code>的人来说，这个东西没啥大影响；一个<code>Object.creat()</code>搞定继承，比<code>class</code>简洁清晰的多</li>\n</ul>\n<h3 id=\"_48-什么是面向对象编程及面向过程编程-它们的异同和优缺点\"> 48 什么是面向对象编程及面向过程编程，它们的异同和优缺点</h3>\n<ul>\n<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</li>\n<li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li>\n<li>面向对象是以功能来划分问题，而不是步骤</li>\n</ul>\n<h3 id=\"_49-面向对象编程思想\"> 49 面向对象编程思想</h3>\n<ul>\n<li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li>\n<li>优点\n<ul>\n<li>易维护\n<ul>\n<li>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的</li>\n</ul>\n</li>\n<li>易扩展</li>\n<li>开发工作的重用性、继承性高，降低重复工作量。</li>\n<li>缩短了开发周期</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_50-对web标准、可用性、可访问性的理解\"> 50 对web标准、可用性、可访问性的理解</h3>\n<ul>\n<li>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</li>\n<li>可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性</li>\n<li>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</li>\n</ul>\n<h3 id=\"_51-如何通过js判断一个数组\"> 51 如何通过JS判断一个数组</h3>\n<ul>\n<li>instanceof方法\n<ul>\n<li><code>instanceof</code> 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>\narr <span>instanceof</span> <span>Array</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>constructor方法\n<ul>\n<li><code>constructor</code>属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>\narr<span>.</span>constructor <span>==</span> Array<span>;</span> <span>//true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>最简单的方法\n<ul>\n<li>这种写法，是 <code>jQuery</code> 正在使用的</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>value<span>)</span> <span>==</span> <span>'[object Array]'</span><span>// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) {     return Object.prototype.toString.call(obj).slice(8,-1);}</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>ES5</code>新增方法<code>isArray()</code></li>\n</ul>\n<div><pre><code><span>var</span> a <span>=</span> <span>new</span> <span>Array</span><span>(</span><span>123</span><span>)</span><span>;</span>\n<span>var</span> b <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>Array<span>.</span><span>isArray</span><span>(</span>a<span>)</span><span>)</span><span>;</span> <span>//trueconsole.log(Array.isArray(b)); //false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_52-谈一谈let与var的区别\"> 52 谈一谈let与var的区别</h3>\n<ul>\n<li><code>let</code>命令不存在变量提升，如果在<code>let</code>前使用，会导致报错</li>\n<li>如果块区中存在<code>let</code>和<code>const</code>命令，就会形成封闭作用域</li>\n<li>不允许重复声明，因此，不能在函数内部重新声明参数</li>\n</ul>\n<h3 id=\"_53-map与foreach的区别\"> 53 map与forEach的区别</h3>\n<ul>\n<li><code>forEach</code>方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容<code>item</code>、数组索引<code>index</code>、和当前遍历数组<code>Array</code></li>\n<li><code>map</code>方法，基本用法与<code>forEach</code>一致，但是不同的，它会返回一个新的数组，所以在callback需要有<code>return</code>值，如果没有，会返回<code>undefined</code></li>\n</ul>\n<h3 id=\"_54-谈一谈你理解的函数式编程\"> 54 谈一谈你理解的函数式编程</h3>\n<ul>\n<li>简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论</li>\n<li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;</li>\n</ul>\n<h3 id=\"_55-谈一谈箭头函数与普通函数的区别\"> 55 谈一谈箭头函数与普通函数的区别？</h3>\n<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>\n<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</li>\n</ul>\n<h3 id=\"_56-谈一谈函数中this的指向\"> 56 谈一谈函数中this的指向</h3>\n<ul>\n<li>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</li>\n<li>《javascript语言精髓》中大概概括了4种调用方式：</li>\n<li>方法调用模式</li>\n<li>函数调用模式</li>\n<li>构造器调用模式</li>\n</ul>\n<div><pre><code>graph <span>LRA</span><span>--</span><span>></span><span>B</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>apply/call调用模式</li>\n</ul>\n<h3 id=\"_57-异步编程的实现方式\"> 57 异步编程的实现方式</h3>\n<ul>\n<li>回调函数\n<ul>\n<li>优点：简单、容易理解</li>\n<li>缺点：不利于维护，代码耦合高</li>\n</ul>\n</li>\n<li>事件监听(采用时间驱动模式，取决于某个事件是否发生)：\n<ul>\n<li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>\n<li>缺点：事件驱动型，流程不够清晰</li>\n</ul>\n</li>\n<li>发布/订阅(观察者模式)\n<ul>\n<li>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li>\n</ul>\n</li>\n<li>Promise对象\n<ul>\n<li>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li>\n<li>缺点：编写和理解，相对比较难</li>\n</ul>\n</li>\n<li>Generator函数\n<ul>\n<li>优点：函数体内外的数据交换、错误处理机制</li>\n<li>缺点：流程管理不方便</li>\n</ul>\n</li>\n<li>async函数\n<ul>\n<li>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li>\n<li>缺点：错误处理机制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_58-对原生javascript了解程度\"> 58 对原生Javascript了解程度</h3>\n<ul>\n<li>数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、<code>RegExp</code>、<code>JSON</code>、<code>Ajax</code>、<code>DOM</code>、<code>BOM</code>、内存泄漏、跨域、异步装载、模板引擎、前端<code>MVC</code>、路由、模块化、<code>Canvas</code>、<code>ECMAScript</code></li>\n</ul>\n<h3 id=\"_59-js动画与css动画区别及相应实现\"> 59 Js动画与CSS动画区别及相应实现</h3>\n<ul>\n<li>\n<p>CSS3的动画的优点</p>\n<ul>\n<li>在性能上会稍微好一些，浏览器会对<code>CSS3</code>的动画做一些优化</li>\n<li>代码相对简单</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>在动画控制上不够灵活</li>\n<li>兼容性不好</li>\n</ul>\n</li>\n<li>\n<p><code>JavaScript</code>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容<code>IE6</code>，并且功能强大。对于一些复杂控制的动画，使用<code>javascript</code>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑<code>CSS</code>吧</p>\n</li>\n</ul>\n<h3 id=\"_60-js-数组和对象的遍历方式-以及几种方式的比较\"> 60 JS 数组和对象的遍历方式，以及几种方式的比较</h3>\n<blockquote>\n<p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历</p>\n</blockquote>\n<ul>\n<li><code>for in</code>循环</li>\n<li><code>for</code>循环</li>\n<li><code>forEach</code>\n<ul>\n<li>这里的 <code>forEach</code>回调中两个参数分别为 <code>value</code>，<code>index</code></li>\n<li><code>forEach</code> 无法遍历对象</li>\n<li>IE不支持该方法；<code>Firefox</code> 和 <code>chrome</code> 支持</li>\n<li><code>forEach</code> 无法使用 <code>break</code>，<code>continue</code> 跳出循环，且使用 <code>return</code> 是跳过本次循环</li>\n</ul>\n</li>\n<li>这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题</li>\n<li>在方式一中，<code>for-in</code>需要分析出<code>array</code>的每个属性，这个操作性能开销很大。用在 <code>key</code> 已知的数组上是非常不划算的。所以尽量不要用<code>for-in</code>，除非你不清楚要处理哪些属性，例如 <code>JSON</code>对象这样的情况</li>\n<li>在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 <code>array</code> 里存放的都是 <code>DOM</code> 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li>\n</ul>\n<h3 id=\"_61-gulp是什么\"> 61 gulp是什么</h3>\n<ul>\n<li><code>gulp</code>是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成</li>\n<li>Gulp的核心概念：流</li>\n<li>流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向</li>\n<li>gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作</li>\n<li>Gulp的特点：\n<ul>\n<li><strong>易于使用</strong>：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理</li>\n<li><strong>构建快速</strong> 利用 <code>Node.js</code> 流的威力，你可以快速构建项目并减少频繁的 <code>IO</code> 操作</li>\n<li><strong>易于学习</strong> 通过最少的 <code>API</code>，掌握 <code>gulp</code> 毫不费力，构建工作尽在掌握：如同一系列流管道</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_62-说一下vue的双向绑定数据的原理\"> 62 说一下Vue的双向绑定数据的原理</h3>\n<ul>\n<li><code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调</li>\n</ul>\n<h3 id=\"_63-事件的各个阶段\"> 63 事件的各个阶段</h3>\n<ul>\n<li>\n<p>1：捕获阶段 ---&gt; 2：目标阶段 ---&gt; 3：冒泡阶段</p>\n</li>\n<li>\n<p><code>document</code> ---&gt; <code>target</code>目标 ----&gt; <code>document</code></p>\n</li>\n<li>\n<p>由此，addEventListener的第三个参数设置为true和false的区别已经非常清晰了</p>\n<ul>\n<li><code>true</code>表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件</li>\n<li><code>false</code>表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_64-let-var-const\"> 64 let var const</h3>\n<p><strong>let:</strong></p>\n<ul>\n<li>允许你声明一个作用域被限制在块级中的变量、语句或者表达式</li>\n<li>let绑定不受变量提升的约束，这意味着let声明不会被提升到当前</li>\n<li>该变量处于从块开始到初始化处理的“暂存死区”</li>\n</ul>\n<p><strong>var:</strong></p>\n<ul>\n<li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li>\n<li>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</li>\n</ul>\n<p><strong>const:</strong></p>\n<ul>\n<li>声明创建一个值的只读引用 (即指针)</li>\n<li>基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 <code>const</code>申明基本数据类型时</li>\n<li>再将其值改变时，将会造成报错， 例如 <code>const a = 3</code> ; <code>a = 5</code>时 将会报错</li>\n<li>但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</li>\n</ul>\n<h3 id=\"_65-快速的让一个数组乱序\"> 65 快速的让一个数组乱序</h3>\n<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>]</span><span>;</span>\narr<span>.</span><span>sort</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span><span>return</span> Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>-</span> <span>0.5</span><span>;</span><span>}</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>arr<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_66-如何渲染几万条数据并不卡住界面\"> 66 如何渲染几万条数据并不卡住界面</h3>\n<blockquote>\n<p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 <code>DOM</code>，那么就可以通过 <code>requestAnimationFrame</code> 来每 <code>16 ms</code> 刷新一次</p>\n</blockquote>\n<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>\"</span>en<span>\"</span></span><span>></span></span>\n  <span><span><span>&lt;</span>head</span><span>></span></span>  \n    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>\"</span>UTF-8<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>\"</span>viewport<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>width=device-width, initial-scale=1.0<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>\"</span>X-UA-Compatible<span>\"</span></span> <span>content</span><span><span>=</span><span>\"</span>ie=edge<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>\n  <span><span><span>&lt;/</span>head</span><span>></span></span>\n  <span><span><span>&lt;</span>body</span><span>></span></span>\n    <span><span><span>&lt;</span>ul</span><span>></span></span>控件<span><span><span>&lt;/</span>ul</span><span>></span></span>\n    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>      \n        <span>// 插入十万条数据      </span>\n        <span>const</span> total <span>=</span> <span>100000</span>      \n        <span>// 一次插入 20 条，如果觉得性能不好就减少      </span>\n        <span>const</span> once <span>=</span> <span>20</span>      \n        <span>// 渲染数据总共需要几次      </span>\n        <span>const</span> loopCount <span>=</span> total <span>/</span> once      \n        <span>let</span> countOfRender <span>=</span> <span>0</span>      \n        <span>let</span> ul <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>\"ul\"</span><span>)</span><span>;</span>      \n        <span>function</span> <span>add</span><span>(</span><span>)</span> <span>{</span>        \n          <span>// 优化性能，插入不会造成回流        </span>\n          <span>const</span> fragment <span>=</span> document<span>.</span><span>createDocumentFragment</span><span>(</span><span>)</span><span>;</span>        \n          <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> once<span>;</span> i<span>++</span><span>)</span> <span>{</span>          \n            <span>const</span> li <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>\"li\"</span><span>)</span><span>;</span>          \n            li<span>.</span>innerText <span>=</span> Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> total<span>)</span><span>;</span>          \n            fragment<span>.</span><span>appendChild</span><span>(</span>li<span>)</span><span>;</span>        \n          <span>}</span>        \n          ul<span>.</span><span>appendChild</span><span>(</span>fragment<span>)</span><span>;</span>        \n          countOfRender <span>+=</span> <span>1</span><span>;</span>        \n          <span>loop</span><span>(</span><span>)</span><span>;</span>      \n        <span>}</span>      \n        <span>function</span> <span>loop</span><span>(</span><span>)</span> <span>{</span>        \n          <span>if</span> <span>(</span>countOfRender <span>&lt;</span> loopCount<span>)</span> <span>{</span>          \n            window<span>.</span><span>requestAnimationFrame</span><span>(</span>add<span>)</span><span>;</span>        \n          <span>}</span>      \n        <span>}</span>      \n        <span>loop</span><span>(</span><span>)</span><span>;</span>    \n      <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>  \n    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n  <span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id=\"_67-希望获取到页面中所有的checkbox怎么做\"> 67 希望获取到页面中所有的checkbox怎么做？</h3>\n<blockquote>\n<p>不使用第三方框架</p>\n</blockquote>\n<div><pre><code> <span>var</span> domList <span>=</span> document<span>.</span><span>getElementsByTagName</span><span>(</span>‘input’<span>)</span> \n <span>var</span> checkBoxList <span>=</span> <span>[</span><span>]</span><span>;</span> \n <span>var</span> len <span>=</span> domList<span>.</span>length<span>;</span>　　\n <span>//缓存到局部变量 </span>\n <span>while</span> <span>(</span>len<span>--</span><span>)</span> <span>{</span>　　\n    <span>//使用while的效率会比for循环更高 　　</span>\n    <span>if</span> <span>(</span>domList<span>[</span>len<span>]</span><span>.</span>type <span>==</span> ‘checkbox’<span>)</span> <span>{</span>     　　\n      checkBoxList<span>.</span><span>push</span><span>(</span>domList<span>[</span>len<span>]</span><span>)</span><span>;</span> 　　\n    <span>}</span> \n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_68-怎样添加、移除、移动、复制、创建和查找节点\"> 68 怎样添加、移除、移动、复制、创建和查找节点</h3>\n<p><strong>创建新节点:</strong></p>\n<div><pre><code><span>createDocumentFragment</span><span>(</span><span>)</span>    <span>//创建一个DOM片段</span>\n<span>createElement</span><span>(</span><span>)</span>   <span>//创建一个具体的元素</span>\n<span>createTextNode</span><span>(</span><span>)</span>   <span>//创建一个文本节点</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>添加、移除、替换、插入:</strong></p>\n<div><pre><code><span>appendChild</span><span>(</span><span>)</span>      <span>//添加</span>\n<span>removeChild</span><span>(</span><span>)</span>      <span>//移除</span>\n<span>replaceChild</span><span>(</span><span>)</span>      <span>//替换</span>\n<span>insertBefore</span><span>(</span><span>)</span>      <span>//插入</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>查找:</strong></p>\n<div><pre><code><span>getElementsByTagName</span><span>(</span><span>)</span>    <span>//通过标签名称</span>\n<span>getElementsByName</span><span>(</span><span>)</span>     <span>//通过元素的Name属性的值</span>\n<span>getElementById</span><span>(</span><span>)</span>        <span>//通过元素Id，唯一性</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_69-正则表达式\"> 69 正则表达式</h3>\n<blockquote>\n<p>正则表达式构造函数<code>var reg=new RegExp(“xxx”)</code>与正则表达字面量<code>var reg=//</code>有什么不同？匹配邮箱的正则表达式？</p>\n</blockquote>\n<ul>\n<li>当使用<code>RegExp()</code>构造函数的时候，不仅需要转义引号（即<code>\\</code>”表示”），并且还需要双反斜杠（即<code>\\\\</code>表示一个<code>\\</code>）。使用正则表达字面量的效率更高</li>\n</ul>\n<p>邮箱的正则匹配：</p>\n<div><pre><code><span>var</span> regMail <span>=</span> <span><span>/</span><span>^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$</span><span>/</span></span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_70-javascript中callee和caller的作用\"> 70 Javascript中callee和caller的作用？</h3>\n<ul>\n<li><code>caller</code>是返回一个对函数的引用，该函数调用了当前函数；</li>\n<li><code>callee</code>是返回正在被执行的<code>function</code>函数，也就是所指定的<code>function</code>对象的正文</li>\n</ul>\n<blockquote>\n<p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用<code>callee</code>完成）</p>\n</blockquote>\n<div><pre><code><span>var</span> result<span>=</span><span>[</span><span>]</span><span>;</span>\n<span>function</span> <span>fn</span><span>(</span><span>n</span><span>)</span><span>{</span>\n  <span>//典型的斐波那契数列     </span>\n  <span>if</span><span>(</span>n<span>==</span><span>1</span><span>)</span><span>{</span>\n    <span>return</span> <span>1</span><span>;</span>     \n  <span>}</span><span>else</span> <span>if</span><span>(</span>n<span>==</span><span>2</span><span>)</span><span>{</span>             \n    <span>return</span> <span>1</span><span>;</span>     \n  <span>}</span><span>else</span><span>{</span>          \n    <span>if</span><span>(</span>result<span>[</span>n<span>]</span><span>)</span><span>{</span>                  \n      <span>return</span> result<span>[</span>n<span>]</span><span>;</span>         \n    <span>}</span><span>else</span><span>{</span>                 \n      <span>//argument.callee()表示fn()                 </span>\n      result<span>[</span>n<span>]</span><span>=</span>arguments<span>.</span><span>callee</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>+</span>arguments<span>.</span><span>callee</span><span>(</span>n<span>-</span><span>2</span><span>)</span><span>;</span>                 \n      <span>return</span> result<span>[</span>n<span>]</span><span>;</span>         \n    <span>}</span>    \n  <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>已完结~~~</p>\n",
      "date_published": "2021-07-26T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.027Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "JavaScript"
      ]
    },
    {
      "title": "高频手写题目(不会手撕实现还好意思说自己是程序员？)",
      "url": "https://github.com/letme350/programming/handTear/",
      "id": "https://github.com/letme350/programming/handTear/",
      "content_html": "<h1 id=\"高频手写题目-不会手撕实现还好意思说自己是程序员\"> 高频手写题目(不会手撕实现还好意思说自己是程序员？)</h1>\n<blockquote>\n<p>面试高频手写题目</p>\n</blockquote>\n<h2 id=\"_1-实现防抖函数-debounce\"> 1 实现防抖函数（debounce）</h2>\n<blockquote>\n<p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p>\n</blockquote>\n<p><strong>手写简化版:</strong></p>\n<div><pre><code><span>// func是用户传入需要防抖的函数</span>\n<span>// wait是等待时间</span>\n<span>const</span> <span>debounce</span> <span>=</span> <span>(</span><span>func<span>,</span> wait <span>=</span> <span>50</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 缓存一个定时器id</span>\n  <span>let</span> timer <span>=</span> <span>0</span>\n  <span>// 这里返回的函数是每次用户实际调用的防抖函数</span>\n  <span>// 如果已经设定过定时器了就清空上一次的定时器</span>\n  <span>// 开始一个新的定时器，延迟执行用户传入的方法</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>timer<span>)</span> <span>clearTimeout</span><span>(</span>timer<span>)</span>\n    timer <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>func</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>\n    <span>}</span><span>,</span> wait<span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>适用场景：</strong></p>\n<blockquote>\n<p>按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</p>\n</blockquote>\n<h2 id=\"_2-实现节流函数-throttle\"> 2 实现节流函数（throttle）</h2>\n<blockquote>\n<p>节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p>\n</blockquote>\n<p><strong>手写简版：</strong></p>\n<div><pre><code><span>// func是用户传入需要防抖的函数</span>\n<span>// wait是等待时间</span>\n<span>const</span> <span>throttle</span> <span>=</span> <span>(</span><span>func<span>,</span> wait <span>=</span> <span>50</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 上一次执行该函数的时间</span>\n  <span>let</span> lastTime <span>=</span> <span>0</span>\n  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n    <span>// 当前时间</span>\n    <span>let</span> now <span>=</span> <span>+</span><span>new</span> <span>Date</span><span>(</span><span>)</span>\n    <span>// 将当前时间和上一次执行函数时间对比</span>\n    <span>// 如果差值大于设置的等待时间就执行函数</span>\n    <span>if</span> <span>(</span>now <span>-</span> lastTime <span>></span> wait<span>)</span> <span>{</span>\n      lastTime <span>=</span> now\n      <span>func</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>setInterval</span><span>(</span>\n  <span>throttle</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>\n  <span>}</span><span>,</span> <span>500</span><span>)</span><span>,</span>\n  <span>1</span>\n<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>适用场景：</strong></p>\n<ul>\n<li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li>\n<li>缩放场景：监控浏览器<code>resize</code></li>\n<li>动画场景：避免短时间内多次触发动画引起性能问题</li>\n</ul>\n<h2 id=\"_3-深克隆-deepclone\"> 3 深克隆（deepclone）</h2>\n<p><strong>简单版：</strong></p>\n<div><pre><code><span>const</span> newObj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>oldObj<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>局限性：</strong></p>\n<ul>\n<li>他无法实现对函数 、RegExp等特殊对象的克隆</li>\n<li>会抛弃对象的constructor,所有的构造函数会指向Object</li>\n<li>对象有循环引用,会报错</li>\n</ul>\n<p><strong>面试够用版：</strong></p>\n<div><pre><code><span>function</span> <span>deepCopy</span><span>(</span><span>obj</span><span>)</span><span>{</span>\n  <span>//判断是否是简单数据类型，</span>\n  <span>if</span><span>(</span><span>typeof</span> obj <span>==</span> <span>\"object\"</span><span>)</span><span>{</span>\n    <span>//复杂数据类型</span>\n    <span>var</span> result <span>=</span> obj<span>.</span>constructor <span>==</span> Array <span>?</span> <span>[</span><span>]</span> <span>:</span> <span>{</span><span>}</span><span>;</span>\n    <span>for</span><span>(</span><span>let</span> i <span>in</span> obj<span>)</span><span>{</span>\n      result<span>[</span>i<span>]</span> <span>=</span> <span>typeof</span> obj<span>[</span>i<span>]</span> <span>==</span> <span>\"object\"</span> <span>?</span> <span>deepCopy</span><span>(</span>obj<span>[</span>i<span>]</span><span>)</span> <span>:</span> obj<span>[</span>i<span>]</span><span>;</span>\n    <span>}</span>\n  <span>}</span><span>else</span> <span>{</span>\n    <span>//简单数据类型 直接 == 赋值</span>\n    <span>var</span> result <span>=</span> obj<span>;</span>\n  <span>}</span>\n  <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"_4-实现event-event-bus\"> 4 实现Event(event bus)</h2>\n<blockquote>\n<p>event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础</p>\n</blockquote>\n<p><strong>简单版：</strong></p>\n<div><pre><code><span>class</span> <span>EventEmeitter</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_events <span>=</span> <span>this</span><span>.</span>_events <span>||</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span> <span>// 储存事件/回调键值对</span>\n    <span>this</span><span>.</span>_maxListeners <span>=</span> <span>this</span><span>.</span>_maxListeners <span>||</span> <span>10</span><span>;</span> <span>// 设立监听上限</span>\n  <span>}</span>\n<span>}</span>\n\n\n<span>// 触发名为type的事件</span>\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>emit</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>let</span> handler<span>;</span>\n  <span>// 从储存事件键值对的this._events中获取对应事件回调函数</span>\n  handler <span>=</span> <span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>;</span>\n  <span>if</span> <span>(</span>args<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n    <span>handler</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>handler</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> <span>true</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>// 监听名为type的事件</span>\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>addListener</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>// 将type事件以及对应的fn函数放入this._events中储存</span>\n  <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_events<span>.</span><span>set</span><span>(</span>type<span>,</span> fn<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>面试版：</strong></p>\n<div><pre><code><span>class</span> <span>EventEmeitter</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_events <span>=</span> <span>this</span><span>.</span>_events <span>||</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span> <span>// 储存事件/回调键值对</span>\n    <span>this</span><span>.</span>_maxListeners <span>=</span> <span>this</span><span>.</span>_maxListeners <span>||</span> <span>10</span><span>;</span> <span>// 设立监听上限</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 触发名为type的事件</span>\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>emit</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>let</span> handler<span>;</span>\n  <span>// 从储存事件键值对的this._events中获取对应事件回调函数</span>\n  handler <span>=</span> <span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>;</span>\n  <span>if</span> <span>(</span>args<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n    <span>handler</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>handler</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> <span>true</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>// 监听名为type的事件</span>\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>addListener</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>// 将type事件以及对应的fn函数放入this._events中储存</span>\n  <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_events<span>.</span><span>set</span><span>(</span>type<span>,</span> fn<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>// 触发名为type的事件</span>\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>emit</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>let</span> handler<span>;</span>\n  handler <span>=</span> <span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>;</span>\n  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>handler<span>)</span><span>)</span> <span>{</span>\n    <span>// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span>\n    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> handler<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>args<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n        handler<span>[</span>i<span>]</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        handler<span>[</span>i<span>]</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>// 单个函数的情况我们直接触发即可</span>\n    <span>if</span> <span>(</span>args<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n      <span>handler</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>handler</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>return</span> <span>true</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>// 监听名为type的事件</span>\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>addListener</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>const</span> handler <span>=</span> <span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>;</span> <span>// 获取对应事件名称的函数清单</span>\n  <span>if</span> <span>(</span><span>!</span>handler<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_events<span>.</span><span>set</span><span>(</span>type<span>,</span> fn<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>handler <span>&amp;&amp;</span> <span>typeof</span> handler <span>===</span> <span>\"function\"</span><span>)</span> <span>{</span>\n    <span>// 如果handler是函数说明只有一个监听者</span>\n    <span>this</span><span>.</span>_events<span>.</span><span>set</span><span>(</span>type<span>,</span> <span>[</span>handler<span>,</span> fn<span>]</span><span>)</span><span>;</span> <span>// 多个监听者我们需要用数组储存</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    handler<span>.</span><span>push</span><span>(</span>fn<span>)</span><span>;</span> <span>// 已经有多个监听者,那么直接往数组里push函数即可</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>EventEmeitter</span><span>.</span>prototype<span>.</span><span>removeListener</span> <span>=</span> <span>function</span><span>(</span><span>type<span>,</span> fn</span><span>)</span> <span>{</span>\n  <span>const</span> handler <span>=</span> <span>this</span><span>.</span>_events<span>.</span><span>get</span><span>(</span>type<span>)</span><span>;</span> <span>// 获取对应事件名称的函数清单</span>\n\n  <span>// 如果是函数,说明只被监听了一次</span>\n  <span>if</span> <span>(</span>handler <span>&amp;&amp;</span> <span>typeof</span> handler <span>===</span> <span>\"function\"</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>_events<span>.</span><span>delete</span><span>(</span>type<span>,</span> fn<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>let</span> postion<span>;</span>\n    <span>// 如果handler是数组,说明被监听多次要找到对应的函数</span>\n    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> handler<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>handler<span>[</span>i<span>]</span> <span>===</span> fn<span>)</span> <span>{</span>\n        postion <span>=</span> i<span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        postion <span>=</span> <span>-</span><span>1</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>// 如果找到匹配的函数,从数组中清除</span>\n    <span>if</span> <span>(</span>postion <span>!==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n      <span>// 找到数组对应的位置,直接清除此回调</span>\n      handler<span>.</span><span>splice</span><span>(</span>postion<span>,</span> <span>1</span><span>)</span><span>;</span>\n      <span>// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span>\n      <span>if</span> <span>(</span>handler<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>_events<span>.</span><span>set</span><span>(</span>type<span>,</span> handler<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> <span>this</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br></div></div><h2 id=\"_5-实现instanceof\"> 5 实现instanceOf</h2>\n<blockquote>\n<p>核心要点：原型链的向上查找</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>myInstanceof</span><span>(</span><span>left<span>,</span> right</span><span>)</span> <span>{</span>\n  <span>let</span> proto <span>=</span> Object<span>.</span><span>getPrototypeOf</span><span>(</span>left<span>)</span><span>;</span>\n  <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n    <span>if</span><span>(</span>proto <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>\n    <span>if</span><span>(</span>proto <span>==</span> right<span>.</span>prototype<span>)</span> <span>return</span> <span>true</span><span>;</span>\n    proto <span>=</span> Object<span>.</span><span>getPrototypeof</span><span>(</span>proto<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_6-模拟new\"> 6 模拟new</h2>\n<p><strong>new操作符做了这些事：</strong></p>\n<ul>\n<li>创建一个全新的对象，这个对象的<code>__proto__</code>要指向构造函数的原型对象</li>\n<li>执行构造函数</li>\n<li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象</li>\n</ul>\n<div><pre><code><span>function</span> <span>myNew</span><span>(</span><span>fn<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>let</span> instance <span>=</span> Object<span>.</span><span>create</span><span>(</span>fn<span>.</span>prototype<span>)</span><span>;</span>\n  <span>let</span> res <span>=</span> <span>fn</span><span>.</span><span>apply</span><span>(</span>instance<span>,</span> args<span>)</span><span>;</span>\n  <span>return</span> <span>typeof</span> res <span>===</span> <span>'object'</span> <span>?</span> res<span>:</span> instance<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_7-实现一个call\"> 7 实现一个call</h2>\n<p><strong>call做了什么:</strong></p>\n<ul>\n<li>将函数设为对象的属性</li>\n<li>执行&amp;删除这个函数</li>\n<li>指定<code>this</code>到函数并传入给定参数执行函数</li>\n<li>如果不传入参数，默认指向为 <code>window</code></li>\n</ul>\n<div><pre><code><span>// 模拟 call bar.mycall(null);</span>\n<span>//实现一个call方法：</span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>myCall</span> <span>=</span> <span>function</span><span>(</span><span>context</span><span>)</span> <span>{</span>\n  <span>//此处没有考虑context非object情况</span>\n  context<span>.</span>fn <span>=</span> <span>this</span><span>;</span>\n  <span>let</span> args <span>=</span> <span>[</span><span>]</span><span>;</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>,</span> len <span>=</span> arguments<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    args<span>.</span><span>push</span><span>(</span>arguments<span>[</span>i<span>]</span><span>)</span><span>;</span>\n  <span>}</span>\n  context<span>.</span><span>fn</span><span>(</span><span>...</span>args<span>)</span><span>;</span>\n  <span>let</span> result <span>=</span> context<span>.</span><span>fn</span><span>(</span><span>...</span>args<span>)</span><span>;</span>\n  <span>delete</span> context<span>.</span>fn<span>;</span>\n  <span>return</span> result<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"_8-实现apply方法\"> 8 实现apply方法</h2>\n<blockquote>\n<p>思路: 利用<code>this</code>的上下文特性。</p>\n</blockquote>\n<div><pre><code><span>//实现apply只要把下一行中的...args换成args即可 </span>\n<span>Function</span><span>.</span>prototype<span>.</span><span>myCall</span> <span>=</span> <span>function</span><span>(</span><span>context <span>=</span> window<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>let</span> func <span>=</span> <span>this</span><span>;</span>\n  <span>let</span> fn <span>=</span> <span>Symbol</span><span>(</span><span>\"fn\"</span><span>)</span><span>;</span>\n  context<span>[</span>fn<span>]</span> <span>=</span> func<span>;</span>\n\n  <span>let</span> res <span>=</span> context<span>[</span>fn<span>]</span><span>(</span><span>...</span>args<span>)</span><span>;</span><span>//重点代码，利用this指向，相当于context.caller(...args)</span>\n\n  <span>delete</span> context<span>[</span>fn<span>]</span><span>;</span>\n  <span>return</span> res<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_9-实现bind\"> 9 实现bind</h2>\n<blockquote>\n<p>bind 的实现对比其他两个函数略微地复杂了一点，因为 bind 需要返回一个函数，需要判断一些边界问题，以下是 bind 的实现</p>\n</blockquote>\n<ul>\n<li>bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式</li>\n<li>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments)</li>\n<li>最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this</li>\n</ul>\n<div><pre><code><span>Function</span><span>.</span>prototype<span>.</span><span>myBind</span> <span>=</span> <span>function</span> <span>(</span><span>context</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>typeof</span> <span>this</span> <span>!==</span> <span>'function'</span><span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span>'Error'</span><span>)</span>\n  <span>}</span>\n  <span>const</span> _this <span>=</span> <span>this</span>\n  <span>const</span> args <span>=</span> <span>[</span><span>...</span>arguments<span>]</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>\n  <span>// 返回一个函数</span>\n  <span>return</span> <span>function</span> <span>F</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 因为返回了一个函数，我们可以 new F()，所以需要判断</span>\n    <span>if</span> <span>(</span><span>this</span> <span>instanceof</span> <span>F</span><span>)</span> <span>{</span>\n      <span>return</span> <span>new</span> <span>_this</span><span>(</span><span>...</span>args<span>,</span> <span>...</span>arguments<span>)</span>\n    <span>}</span>\n    <span>return</span> <span>_this</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>.</span><span>concat</span><span>(</span><span>...</span>arguments<span>)</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_10-模拟object-create\"> 10 模拟Object.create</h2>\n<blockquote>\n<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</p>\n</blockquote>\n<div><pre><code><span>// 模拟 Object.create</span>\n\n<span>function</span> <span>create</span><span>(</span><span>proto</span><span>)</span> <span>{</span>\n  <span>function</span> <span>F</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>F</span><span>.</span>prototype <span>=</span> proto<span>;</span>\n\n  <span>return</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_11-实现类的继承-简版\"> 11 实现类的继承-简版</h2>\n<blockquote>\n<p>类的继承在几年前是重点内容，有n种继承方式各有优劣，es6普及后越来越不重要，那么多种写法有点『回字有四样写法』的意思，如果还想深入理解的去看红宝书即可，我们目前只实现一种最理想的继承方式。</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>Parent</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>parent <span>=</span> name\n<span>}</span>\n<span>Parent</span><span>.</span>prototype<span>.</span><span>say</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span><span>this</span><span>.</span>parent<span>}</span></span><span>: 你打篮球的样子像kunkun</span><span>`</span></span><span>)</span>\n<span>}</span>\n<span>function</span> <span>Child</span><span>(</span><span>name<span>,</span> parent</span><span>)</span> <span>{</span>\n  <span>// 将父类的构造函数绑定在子类上</span>\n  <span>Parent</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> parent<span>)</span>\n  <span>this</span><span>.</span>child <span>=</span> name\n<span>}</span>\n\n<span>/** \n 1. 这一步不用Child.prototype =Parent.prototype的原因是怕共享内存，修改父类原型对象就会影响子类\n 2. 不用Child.prototype = new Parent()的原因是会调用2次父类的构造方法（另一次是call），会存在一份多余的父类实例属性\n3. Object.create是创建了父类原型的副本，与父类原型完全隔离\n*/</span>\n<span>Child</span><span>.</span>prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>Parent</span><span>.</span>prototype<span>)</span><span>;</span>\n<span>Child</span><span>.</span>prototype<span>.</span><span>say</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span><span>this</span><span>.</span>parent<span>}</span></span><span>好，我是练习时长两年半的</span><span><span>${</span><span>this</span><span>.</span>child<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 注意记得把子类的构造指向子类本身</span>\n<span>Child</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Child<span>;</span>\n\n<span>var</span> parent <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>'father'</span><span>)</span><span>;</span>\nparent<span>.</span><span>say</span><span>(</span><span>)</span> <span>// father: 你打篮球的样子像kunkun</span>\n\n<span>var</span> child <span>=</span> <span>new</span> <span>Child</span><span>(</span><span>'cxk'</span><span>,</span> <span>'father'</span><span>)</span><span>;</span>\nchild<span>.</span><span>say</span><span>(</span><span>)</span> <span>// father好，我是练习时长两年半的cxk</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_12-es5实现继承的那些事-详细\"> 12 ES5实现继承的那些事-详细</h2>\n<p><strong>第一种方式是借助call实现继承：</strong></p>\n<div><pre><code><span>function</span> <span>Parent1</span><span>(</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'parent1'</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>Child1</span><span>(</span><span>)</span><span>{</span>\n  <span>Parent1</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>this</span><span>.</span>type <span>=</span> <span>'child1'</span>    \n<span>}</span>\nconsole<span>.</span><span>log</span><span>(</span><span>new</span> <span>Child1</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类中一旦存在方法那么子类无法继承。那么引出下面的方法</p>\n</blockquote>\n<p><strong>第二种方式借助原型链实现继承：</strong></p>\n<div><pre><code><span>function</span> <span>Parent2</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'parent2'</span><span>;</span>\n  <span>this</span><span>.</span>play <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>\n<span>}</span>\n<span>function</span> <span>Child2</span><span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>type <span>=</span> <span>'child2'</span><span>;</span>\n<span>}</span>\n<span>Child2</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent2</span><span>(</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>new</span> <span>Child2</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：</p>\n<div><pre><code><span>var</span> s1 <span>=</span> <span>new</span> <span>Child2</span><span>(</span><span>)</span><span>;</span>\n<span>var</span> s2 <span>=</span> <span>new</span> <span>Child2</span><span>(</span><span>)</span><span>;</span>\ns1<span>.</span>play<span>.</span><span>push</span><span>(</span><span>4</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>s1<span>.</span>play<span>,</span> s2<span>.</span>play<span>)</span><span>;</span> <span>// [1,2,3,4] [1,2,3,4]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象</p>\n<p><strong>第三种方式：将前两种组合：</strong></p>\n<div><pre><code><span>function</span> <span>Parent3</span> <span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'parent3'</span><span>;</span>\n  <span>this</span><span>.</span>play <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>Child3</span><span>(</span><span>)</span> <span>{</span>\n  <span>Parent3</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>this</span><span>.</span>type <span>=</span> <span>'child3'</span><span>;</span>\n<span>}</span>\n<span>Child3</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Parent3</span><span>(</span><span>)</span><span>;</span>\n<span>var</span> s3 <span>=</span> <span>new</span> <span>Child3</span><span>(</span><span>)</span><span>;</span>\n<span>var</span> s4 <span>=</span> <span>new</span> <span>Child3</span><span>(</span><span>)</span><span>;</span>\ns3<span>.</span>play<span>.</span><span>push</span><span>(</span><span>4</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>s3<span>.</span>play<span>,</span> s4<span>.</span>play<span>)</span><span>;</span> <span>// [1,2,3,4] [1,2,3]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（<code>Child3.prototype = new Parent3()</code>;）。这是我们不愿看到的。那么如何解决这个问题？</p>\n</blockquote>\n<p><strong>第四种方式: 组合继承的优化1：</strong></p>\n<div><pre><code><span>function</span> <span>Parent4</span> <span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'parent4'</span><span>;</span>\n  <span>this</span><span>.</span>play <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>Child4</span><span>(</span><span>)</span> <span>{</span>\n  <span>Parent4</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>this</span><span>.</span>type <span>=</span> <span>'child4'</span><span>;</span>\n<span>}</span>\n<span>Child4</span><span>.</span>prototype <span>=</span> <span>Parent4</span><span>.</span>prototype<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下</p>\n</blockquote>\n<div><pre><code><span>var</span> s3 <span>=</span> <span>new</span> <span>Child4</span><span>(</span><span>)</span><span>;</span>\n<span>var</span> s4 <span>=</span> <span>new</span> <span>Child4</span><span>(</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>s3<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。</p>\n</blockquote>\n<p><strong>第五种方式(最推荐使用)：优化2：</strong></p>\n<div><pre><code><span>function</span> <span>Parent5</span> <span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> <span>'parent5'</span><span>;</span>\n  <span>this</span><span>.</span>play <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>\n<span>}</span>\n<span>function</span> <span>Child5</span><span>(</span><span>)</span> <span>{</span>\n  <span>Parent5</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>this</span><span>.</span>type <span>=</span> <span>'child5'</span><span>;</span>\n<span>}</span>\n<span>Child5</span><span>.</span>prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>Parent5</span><span>.</span>prototype<span>)</span><span>;</span>\n<span>Child5</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Child5<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<p>这是最推荐的一种方式，接近完美的继承。</p>\n</blockquote>\n<h2 id=\"_13-实现一个json-stringify\"> 13 实现一个JSON.stringify</h2>\n<div><pre><code><span>JSON</span><span>.</span><span>stringify</span><span>(</span>value<span>[</span><span>,</span> replacer <span>[</span><span>,</span> space<span>]</span><span>]</span><span>)</span>：\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>Boolean | Number| String</code>类型会自动转换成对应的原始值。</li>\n<li><code>undefined</code>、任意函数以及<code>symbol</code>，会被忽略（出现在非数组对象的属性值中时），或者被转换成 <code>null</code>（出现在数组中时）。</li>\n<li>不可枚举的属性会被忽略如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略</li>\n<li>如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略</li>\n</ul>\n<div><pre><code><span>function</span> <span>jsonStringify</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n  <span>let</span> type <span>=</span> <span>typeof</span> obj<span>;</span>\n  <span>if</span> <span>(</span>type <span>!==</span> <span>\"object\"</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span><span>/</span><span>string|undefined|function</span><span>/</span></span><span>.</span><span>test</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n      obj <span>=</span> <span>'\"'</span> <span>+</span> obj <span>+</span> <span>'\"'</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>String</span><span>(</span>obj<span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>let</span> json <span>=</span> <span>[</span><span>]</span>\n    <span>let</span> arr <span>=</span> Array<span>.</span><span>isArray</span><span>(</span>obj<span>)</span>\n    <span>for</span> <span>(</span><span>let</span> k <span>in</span> obj<span>)</span> <span>{</span>\n      <span>let</span> v <span>=</span> obj<span>[</span>k<span>]</span><span>;</span>\n      <span>let</span> type <span>=</span> <span>typeof</span> v<span>;</span>\n      <span>if</span> <span>(</span><span><span>/</span><span>string|undefined|function</span><span>/</span></span><span>.</span><span>test</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n        v <span>=</span> <span>'\"'</span> <span>+</span> v <span>+</span> <span>'\"'</span><span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>===</span> <span>\"object\"</span><span>)</span> <span>{</span>\n        v <span>=</span> <span>jsonStringify</span><span>(</span>v<span>)</span><span>;</span>\n      <span>}</span>\n      json<span>.</span><span>push</span><span>(</span><span>(</span>arr <span>?</span> <span>\"\"</span> <span>:</span> <span>'\"'</span> <span>+</span> k <span>+</span> <span>'\":'</span><span>)</span> <span>+</span> <span>String</span><span>(</span>v<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>(</span>arr <span>?</span> <span>\"[\"</span> <span>:</span> <span>\"{\"</span><span>)</span> <span>+</span> <span>String</span><span>(</span>json<span>)</span> <span>+</span> <span>(</span>arr <span>?</span> <span>\"]\"</span> <span>:</span> <span>\"}\"</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n<span>jsonStringify</span><span>(</span><span>{</span>x <span>:</span> <span>5</span><span>}</span><span>)</span> <span>// \"{\"x\":5}\"</span>\n<span>jsonStringify</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>\"false\"</span><span>,</span> <span>false</span><span>]</span><span>)</span> <span>// \"[1,\"false\",false]\"</span>\n<span>jsonStringify</span><span>(</span><span>{</span>b<span>:</span> <span>undefined</span><span>}</span><span>)</span> <span>// \"{\"b\":\"undefined\"}\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"_14-实现一个json-parse\"> 14 实现一个JSON.parse</h2>\n<div><pre><code><span>JSON</span><span>.</span><span>parse</span><span>(</span>text<span>[</span><span>,</span> reviver<span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)</p>\n</blockquote>\n<p><strong>第一种：直接调用 eval：</strong></p>\n<div><pre><code><span>function</span> <span>jsonParse</span><span>(</span><span>opt</span><span>)</span> <span>{</span>\n  <span>return</span> <span>eval</span><span>(</span><span>'('</span> <span>+</span> opt <span>+</span> <span>')'</span><span>)</span><span>;</span>\n<span>}</span>\n<span>jsonParse</span><span>(</span><span>jsonStringify</span><span>(</span><span>{</span>x <span>:</span> <span>5</span><span>}</span><span>)</span><span>)</span>\n<span>// Object { x: 5}</span>\n<span>jsonParse</span><span>(</span><span>jsonStringify</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>\"false\"</span><span>,</span> <span>false</span><span>]</span><span>)</span><span>)</span>\n<span>// [1, \"false\", falsr]</span>\n<span>jsonParse</span><span>(</span><span>jsonStringify</span><span>(</span><span>{</span>b<span>:</span> <span>undefined</span><span>}</span><span>)</span><span>)</span>\n<span>// Object { b: \"undefined\"}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>避免在不必要的情况下使用 <code>eval</code>，<code>eval()</code> 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用<code>eval()</code>运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。</p>\n</blockquote>\n<p>如果你只想记这个方法，就得对参数json做校验。</p>\n<div><pre><code><span>var</span> rx_one <span>=</span> <span><span>/</span><span>^[\\],:{}\\s]*$</span><span>/</span></span><span>;</span>\n<span>var</span> rx_two <span>=</span> <span><span>/</span><span>\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})</span><span>/</span><span>g</span></span><span>;</span>\n<span>var</span> rx_three <span>=</span> <span><span>/</span><span>\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?</span><span>/</span><span>g</span></span><span>;</span>\n<span>var</span> rx_four <span>=</span> <span><span>/</span><span>(?:^|:|,)(?:\\s*\\[)+</span><span>/</span><span>g</span></span><span>;</span>\n<span>if</span> <span>(</span>\n  rx_one<span>.</span><span>test</span><span>(</span>\n    json\n    <span>.</span><span>replace</span><span>(</span>rx_two<span>,</span> <span>\"@\"</span><span>)</span>\n    <span>.</span><span>replace</span><span>(</span>rx_three<span>,</span> <span>\"]\"</span><span>)</span>\n    <span>.</span><span>replace</span><span>(</span>rx_four<span>,</span> <span>\"\"</span><span>)</span>\n  <span>)</span>\n<span>)</span> <span>{</span>\n  <span>var</span> obj <span>=</span> <span>eval</span><span>(</span><span>\"(\"</span> <span>+</span>json <span>+</span> <span>\")\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>第二种：Function：</strong></p>\n<blockquote>\n<p>核心：Function与eval有相同的字符串参数特性</p>\n</blockquote>\n<div><pre><code><span>var</span> func <span>=</span> <span>new</span> <span>Function</span><span>(</span>arg1<span>,</span> arg2<span>,</span> <span>...</span><span>,</span> functionBody<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>在转换JSON的实际应用中，只需要这么做</p>\n<div><pre><code><span>var</span> jsonStr <span>=</span> <span>'{ \"age\": 20, \"name\": \"jack\" }'</span><span>var</span> json <span>=</span> <span>(</span><span>new</span> <span>Function</span><span>(</span><span>'return '</span> <span>+</span> jsonStr<span>)</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p><code>eval</code> 与 <code>Function</code>都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用</p>\n</blockquote>\n<h2 id=\"_15-promise的简单实现\"> 15 Promise的简单实现</h2>\n<div><pre><code><span>// 使用</span>\n<span>var</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span>reject</span><span>)</span> <span>=></span> <span>{</span>\n    <span>if</span> <span>(</span>操作成功<span>)</span> <span>{</span>\n        <span>resolve</span><span>(</span>value<span>)</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>reject</span><span>(</span>error<span>)</span>\n    <span>}</span>\n<span>}</span><span>)</span>\npromise<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>// success</span>\n<span>}</span><span>,</span><span>function</span> <span>(</span><span>value</span><span>)</span> <span>{</span>\n    <span>// failure</span>\n<span>}</span><span>)</span>\n<span>function</span> <span>myPromise</span><span>(</span><span>constructor</span><span>)</span> <span>{</span>\n    <span>let</span> self <span>=</span> <span>this</span><span>;</span>\n    self<span>.</span>status <span>=</span> <span>\"pending\"</span>   <span>// 定义状态改变前的初始状态</span>\n    self<span>.</span>value <span>=</span> <span>undefined</span><span>;</span>   <span>// 定义状态为resolved的时候的状态</span>\n    self<span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>  <span>// 定义状态为rejected的时候的状态</span>\n    <span>function</span> <span>resolve</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n       <span>if</span><span>(</span>self<span>.</span>status <span>===</span> <span>\"pending\"</span><span>)</span> <span>{</span>\n          self<span>.</span>value <span>=</span> value<span>;</span>\n          self<span>.</span>status <span>=</span> <span>\"resolved\"</span><span>;</span>\n       <span>}</span>\n    <span>}</span>\n    <span>function</span> <span>reject</span><span>(</span><span>reason</span><span>)</span> <span>{</span>\n       <span>if</span><span>(</span>self<span>.</span>status <span>===</span> <span>\"pending\"</span><span>)</span> <span>{</span>\n          self<span>.</span>reason <span>=</span> reason<span>;</span>\n          self<span>.</span>status <span>=</span> <span>\"rejected\"</span><span>;</span>\n       <span>}</span>\n    <span>}</span>\n    <span>// 捕获构造异常</span>\n    <span>try</span> <span>{</span>\n       <span>constructor</span><span>(</span>resolve<span>,</span>reject<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span><span>(</span>e<span>)</span> <span>{</span>\n       <span>reject</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>// 添加 then 方法</span>\nmyPromise<span>.</span>prototype<span>.</span><span>then</span> <span>=</span> <span>function</span><span>(</span><span>onFullfilled<span>,</span>onRejected</span><span>)</span> <span>{</span>\n  <span>let</span> self <span>=</span> <span>this</span><span>;</span>\n  <span>switch</span><span>(</span>self<span>.</span>status<span>)</span> <span>{</span>\n    <span>case</span> <span>\"resolved\"</span><span>:</span>\n      <span>onFullfilled</span><span>(</span>self<span>.</span>value<span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> <span>\"rejected\"</span><span>:</span>\n      <span>onRejected</span><span>(</span>self<span>.</span>reason<span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>default</span><span>:</span>       \n  <span>}</span>\n<span>}</span>\n\n<span>var</span> p <span>=</span> <span>new</span> <span>myPromise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span>reject</span><span>)</span> <span>{</span>\n  <span>resolve</span><span>(</span><span>1</span><span>)</span>\n<span>}</span><span>)</span><span>;</span>\np<span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>x</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>x<span>)</span> <span>// 1</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id=\"_16-解析-url-params-为对象\"> 16 解析 URL Params 为对象</h2>\n<div><pre><code><span>let</span> url <span>=</span> <span>'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled'</span><span>;</span>\n<span>parseParam</span><span>(</span>url<span>)</span>\n<span>/* 结果\n{ user: 'anonymous',\n  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京', // 中文需解码\n  enabled: true, // 未指定值得 key 约定为 true\n}\n*/</span>\n<span>function</span> <span>parseParam</span><span>(</span><span>url</span><span>)</span> <span>{</span>\n  <span>const</span> paramsStr <span>=</span> <span><span>/</span><span>.+\\?(.+)$</span><span>/</span></span><span>.</span><span>exec</span><span>(</span>url<span>)</span><span>[</span><span>1</span><span>]</span><span>;</span> <span>// 将 ? 后面的字符串取出来</span>\n  <span>const</span> paramsArr <span>=</span> paramsStr<span>.</span><span>split</span><span>(</span><span>'&amp;'</span><span>)</span><span>;</span> <span>// 将字符串以 &amp; 分割后存到数组中</span>\n  <span>let</span> paramsObj <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>// 将 params 存到对象中</span>\n  paramsArr<span>.</span><span>forEach</span><span>(</span><span>param</span> <span>=></span> <span>{</span>\n    <span>if</span> <span>(</span><span><span>/</span><span>=</span><span>/</span></span><span>.</span><span>test</span><span>(</span>param<span>)</span><span>)</span> <span>{</span> <span>// 处理有 value 的参数</span>\n      <span>let</span> <span>[</span>key<span>,</span> val<span>]</span> <span>=</span> param<span>.</span><span>split</span><span>(</span><span>'='</span><span>)</span><span>;</span> <span>// 分割 key 和 value</span>\n      val <span>=</span> <span>decodeURIComponent</span><span>(</span>val<span>)</span><span>;</span> <span>// 解码</span>\n      val <span>=</span> <span><span>/</span><span>^\\d+$</span><span>/</span></span><span>.</span><span>test</span><span>(</span>val<span>)</span> <span>?</span> <span>parseFloat</span><span>(</span>val<span>)</span> <span>:</span> val<span>;</span> <span>// 判断是否转为数字</span>\n\n      <span>if</span> <span>(</span>paramsObj<span>.</span><span>hasOwnProperty</span><span>(</span>key<span>)</span><span>)</span> <span>{</span> <span>// 如果对象有 key，则添加一个值</span>\n        paramsObj<span>[</span>key<span>]</span> <span>=</span> <span>[</span><span>]</span><span>.</span><span>concat</span><span>(</span>paramsObj<span>[</span>key<span>]</span><span>,</span> val<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span> <span>// 如果对象没有这个 key，创建 key 并设置值</span>\n        paramsObj<span>[</span>key<span>]</span> <span>=</span> val<span>;</span>\n      <span>}</span>\n    <span>}</span> <span>else</span> <span>{</span> <span>// 处理没有 value 的参数</span>\n      paramsObj<span>[</span>param<span>]</span> <span>=</span> <span>true</span><span>;</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n\n  <span>return</span> paramsObj<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id=\"_17-模板引擎实现\"> 17 模板引擎实现</h2>\n<div><pre><code><span>let</span> template <span>=</span> <span>'我是{{name}}，年龄{{age}}，性别{{sex}}'</span><span>;</span>\n<span>let</span> data <span>=</span> <span>{</span>\n  name<span>:</span> <span>'姓名'</span><span>,</span>\n  age<span>:</span> <span>18</span>\n<span>}</span>\n<span>render</span><span>(</span>template<span>,</span> data<span>)</span><span>;</span> <span>// 我是姓名，年龄18，性别undefined</span>\n<span>function</span> <span>render</span><span>(</span><span>template<span>,</span> data</span><span>)</span> <span>{</span>\n  <span>const</span> reg <span>=</span> <span><span>/</span><span>\\{\\{(\\w+)\\}\\}</span><span>/</span></span><span>;</span> <span>// 模板字符串正则</span>\n  <span>if</span> <span>(</span>reg<span>.</span><span>test</span><span>(</span>template<span>)</span><span>)</span> <span>{</span> <span>// 判断模板里是否有模板字符串</span>\n    <span>const</span> name <span>=</span> reg<span>.</span><span>exec</span><span>(</span>template<span>)</span><span>[</span><span>1</span><span>]</span><span>;</span> <span>// 查找当前模板里第一个模板字符串的字段</span>\n    template <span>=</span> template<span>.</span><span>replace</span><span>(</span>reg<span>,</span> data<span>[</span>name<span>]</span><span>)</span><span>;</span> <span>// 将第一个模板字符串渲染</span>\n    <span>return</span> <span>render</span><span>(</span>template<span>,</span> data<span>)</span><span>;</span> <span>// 递归的渲染并返回渲染后的结构</span>\n  <span>}</span>\n  <span>return</span> template<span>;</span> <span>// 如果模板没有模板字符串直接返回</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_18-转化为驼峰命名\"> 18 转化为驼峰命名</h2>\n<div><pre><code><span>var</span> s1 <span>=</span> <span>\"get-element-by-id\"</span>\n\n<span>// 转化为 getElementById</span>\n\n<span>var</span> <span>f</span> <span>=</span> <span>function</span><span>(</span><span>s</span><span>)</span> <span>{</span>\n  <span>return</span> s<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>-\\w</span><span>/</span><span>g</span></span><span>,</span> <span>function</span><span>(</span><span>x</span><span>)</span> <span>{</span>\n    <span>return</span> x<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"_19-查找字符串中出现最多的字符和个数\"> 19 查找字符串中出现最多的字符和个数</h2>\n<blockquote>\n<p>例: abbcccddddd -&gt; 字符最多的是d，出现了5次</p>\n</blockquote>\n<div><pre><code><span>let</span> str <span>=</span> <span>\"abcabcabcbbccccc\"</span><span>;</span>\n<span>let</span> num <span>=</span> <span>0</span><span>;</span>\n<span>let</span> char <span>=</span> <span>''</span><span>;</span>\n\n<span>// 使其按照一定的次序排列</span>\nstr <span>=</span> str<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>sort</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>''</span><span>)</span><span>;</span>\n<span>// \"aaabbbbbcccccccc\"</span>\n\n<span>// 定义正则表达式</span>\n<span>let</span> re <span>=</span> <span><span>/</span><span>(\\w)\\1+</span><span>/</span><span>g</span></span><span>;</span>\nstr<span>.</span><span>replace</span><span>(</span>re<span>,</span><span>(</span><span>$<span>0</span><span>,</span>$<span>1</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span><span>(</span>num <span>&lt;</span> $<span>0.</span>length<span>)</span><span>{</span>\n    num <span>=</span> $<span>0.</span>length<span>;</span>\n    char <span>=</span> $<span>1</span><span>;</span>        \n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>`</span><span>字符最多的是</span><span><span>${</span>char<span>}</span></span><span>，出现了</span><span><span>${</span>num<span>}</span></span><span>次</span><span>`</span></span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_20-字符串查找\"> 20 字符串查找</h2>\n<blockquote>\n<p>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</p>\n</blockquote>\n<div><pre><code>a<span>=</span><span>'34'</span><span>;</span>b<span>=</span><span>'1234567'</span><span>;</span> <span>// 返回 2</span>\na<span>=</span><span>'35'</span><span>;</span>b<span>=</span><span>'1234567'</span><span>;</span> <span>// 返回 -1</span>\na<span>=</span><span>'355'</span><span>;</span>b<span>=</span><span>'12354355'</span><span>;</span> <span>// 返回 5</span>\n<span>isContain</span><span>(</span>a<span>,</span>b<span>)</span><span>;</span>\n<span>function</span> <span>isContain</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>in</span> b<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>a<span>[</span><span>0</span><span>]</span> <span>===</span> b<span>[</span>i<span>]</span><span>)</span> <span>{</span>\n      <span>let</span> tmp <span>=</span> <span>true</span><span>;</span>\n      <span>for</span> <span>(</span><span>let</span> j <span>in</span> a<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>a<span>[</span>j<span>]</span> <span>!==</span> b<span>[</span><span>~</span><span>~</span>i <span>+</span> <span>~</span><span>~</span>j<span>]</span><span>)</span> <span>{</span>\n          tmp <span>=</span> <span>false</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n      <span>if</span> <span>(</span>tmp<span>)</span> <span>{</span>\n        <span>return</span> i<span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"_21-实现千位分隔符\"> 21 实现千位分隔符</h2>\n<div><pre><code><span>// 保留三位小数</span>\n<span>parseToMoney</span><span>(</span><span>1234.56</span><span>)</span><span>;</span> <span>// return '1,234.56'</span>\n<span>parseToMoney</span><span>(</span><span>123456789</span><span>)</span><span>;</span> <span>// return '123,456,789'</span>\n<span>parseToMoney</span><span>(</span><span>1087654.321</span><span>)</span><span>;</span> <span>// return '1,087,654.321'</span>\n<span>function</span> <span>parseToMoney</span><span>(</span><span>num</span><span>)</span> <span>{</span>\n  num <span>=</span> <span>parseFloat</span><span>(</span>num<span>.</span><span>toFixed</span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>\n  <span>let</span> <span>[</span>integer<span>,</span> decimal<span>]</span> <span>=</span> <span>String</span><span>.</span>prototype<span>.</span><span>split</span><span>.</span><span>call</span><span>(</span>num<span>,</span> <span>'.'</span><span>)</span><span>;</span>\n  integer <span>=</span> integer<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\\d(?=(\\d{3})+$)</span><span>/</span><span>g</span></span><span>,</span> <span>'$&amp;,'</span><span>)</span><span>;</span>\n  <span>return</span> integer <span>+</span> <span>'.'</span> <span>+</span> <span>(</span>decimal <span>?</span> decimal <span>:</span> <span>''</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_22-判断是否是电话号码\"> 22 判断是否是电话号码</h2>\n<div><pre><code><span>function</span> <span>isPhone</span><span>(</span><span>tel</span><span>)</span> <span>{</span>\n  <span>var</span> regx <span>=</span> <span><span>/</span><span>^1[34578]\\d{9}$</span><span>/</span></span><span>;</span>\n  <span>return</span> regx<span>.</span><span>test</span><span>(</span>tel<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_23-验证是否是邮箱\"> 23 验证是否是邮箱</h2>\n<div><pre><code><span>function</span> <span>isEmail</span><span>(</span><span>email</span><span>)</span> <span>{</span>\n  <span>var</span> regx <span>=</span> <span><span>/</span><span>^([a-zA-Z0-9_\\-])+@([a-zA-Z0-9_\\-])+(\\.[a-zA-Z0-9_\\-])+$</span><span>/</span></span><span>;</span>\n  <span>return</span> regx<span>.</span><span>test</span><span>(</span>email<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_24-验证是否是身份证\"> 24 验证是否是身份证</h2>\n<div><pre><code><span>function</span> <span>isCardNo</span><span>(</span><span>number</span><span>)</span> <span>{</span>\n  <span>var</span> regx <span>=</span> <span><span>/</span><span>(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)</span><span>/</span></span><span>;</span>\n  <span>return</span> regx<span>.</span><span>test</span><span>(</span>number<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_25-用es5实现数组的map方法\"> 25 用ES5实现数组的map方法</h2>\n<ul>\n<li>回调函数的参数有哪些，返回值如何处理</li>\n<li>不修改原来的数组</li>\n</ul>\n<div><pre><code><span>Array</span><span>.</span>prototype<span>.</span><span>MyMap</span> <span>=</span> <span>function</span><span>(</span><span>fn<span>,</span> context</span><span>)</span><span>{</span>\n  <span>var</span> arr <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span><span>//由于是ES5所以就不用...展开符了</span>\n  <span>var</span> mappedArr <span>=</span> <span>[</span><span>]</span><span>;</span>\n  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span> <span>)</span><span>{</span>\n    mappedArr<span>.</span><span>push</span><span>(</span><span>fn</span><span>.</span><span>call</span><span>(</span>context<span>,</span> arr<span>[</span>i<span>]</span><span>,</span> i<span>,</span> <span>this</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> mappedArr<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_26-用es5实现数组的reduce方法\"> 26 用ES5实现数组的reduce方法</h2>\n<ul>\n<li>初始值不传怎么处理</li>\n<li>回调函数的参数有哪些，返回值如何处理。</li>\n</ul>\n<div><pre><code><span>Array</span><span>.</span>prototype<span>.</span><span>myReduce</span> <span>=</span> <span>function</span><span>(</span><span>fn<span>,</span> initialValue</span><span>)</span> <span>{</span>\n  <span>var</span> arr <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>\n  <span>var</span> res<span>,</span> startIndex<span>;</span>\n  res <span>=</span> initialValue <span>?</span> initialValue <span>:</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>\n  startIndex <span>=</span> initialValue <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>;</span>\n  <span>for</span><span>(</span><span>var</span> i <span>=</span> startIndex<span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    res <span>=</span> <span>fn</span><span>.</span><span>call</span><span>(</span><span>null</span><span>,</span> res<span>,</span> arr<span>[</span>i<span>]</span><span>,</span> i<span>,</span> <span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> res<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li>对于普通函数，绑定this指向</li>\n<li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li>\n</ul>\n<div><pre><code><span>Function</span><span>.</span>prototype<span>.</span><span>bind</span> <span>=</span> <span>function</span><span>(</span><span>context<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>\n  <span>let</span> self <span>=</span> <span>this</span><span>;</span><span>//谨记this表示调用bind的函数</span>\n  <span>let</span> <span>fBound</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>//this instanceof fBound为true表示构造函数的情况。如new func.bind(obj)</span>\n    <span>return</span> <span>self</span><span>.</span><span>apply</span><span>(</span><span>this</span> <span>instanceof</span> <span>fBound</span> <span>?</span> <span>this</span> <span>:</span> context <span>||</span> window<span>,</span> args<span>.</span><span>concat</span><span>(</span><span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n  fBound<span>.</span>prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>this</span><span>.</span>prototype<span>)</span><span>;</span><span>//保证原函数的原型对象上的属性不丢失</span>\n  <span>return</span> fBound<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>大家平时说的手写bind，其实就这么简单</p>\n<h2 id=\"_27-实现单例模式\"> 27 实现单例模式</h2>\n<blockquote>\n<p>核心要点: 用闭包和Proxy属性拦截</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>proxy</span><span>(</span><span>func</span><span>)</span> <span>{</span>\n  <span>let</span> instance<span>;</span>\n  <span>let</span> handler <span>=</span> <span>{</span>\n    <span>constructor</span><span>(</span><span>target<span>,</span> args</span><span>)</span> <span>{</span>\n      <span>if</span><span>(</span><span>!</span>instance<span>)</span> <span>{</span>\n        instance <span>=</span> <span>Reflect</span><span>.</span><span>constructor</span><span>(</span>fun<span>,</span> args<span>)</span><span>;</span>\n      <span>}</span>\n      <span>return</span> instance<span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> <span>new</span> <span>Proxy</span><span>(</span>func<span>,</span> handler<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_28-实现数组的flat\"> 28 实现数组的flat</h2>\n<p>需求:多维数组=&gt;一维数组</p>\n<div><pre><code><span>let</span> ary <span>=</span> <span>[</span><span>1</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>[</span><span>4</span><span>,</span> <span>5</span><span>]</span><span>]</span><span>]</span><span>,</span> <span>6</span><span>]</span><span>;</span>\n<span>let</span> str <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>ary<span>)</span><span>;</span>\n<span>//第0种处理:直接的调用</span>\narr_flat <span>=</span> arr<span>.</span><span>flat</span><span>(</span><span>Infinity</span><span>)</span><span>;</span>\n<span>//第一种处理</span>\nary <span>=</span> str<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>(\\[|\\])</span><span>/</span><span>g</span></span><span>,</span> <span>''</span><span>)</span><span>.</span><span>split</span><span>(</span><span>','</span><span>)</span><span>;</span>\n<span>//第二种处理</span>\nstr <span>=</span> str<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>(\\[\\]))</span><span>/</span><span>g</span></span><span>,</span> <span>''</span><span>)</span><span>;</span>\nstr <span>=</span> <span>'['</span> <span>+</span> str <span>+</span> <span>']'</span><span>;</span>\nary <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>str<span>)</span><span>;</span>\n<span>//第三种处理：递归处理</span>\n<span>let</span> result <span>=</span> <span>[</span><span>]</span><span>;</span>\n<span>let</span> <span>fn</span> <span>=</span> <span>function</span><span>(</span><span>ary</span><span>)</span> <span>{</span>\n  <span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> ary<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>}</span><span>{</span>\n    <span>let</span> item <span>=</span> ary<span>[</span>i<span>]</span><span>;</span>\n    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>ary<span>[</span>i<span>]</span><span>)</span><span>)</span><span>{</span>\n      <span>fn</span><span>(</span>item<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      result<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n<span>//第四种处理：用 reduce 实现数组的 flat 方法</span>\n<span>function</span> <span>flatten</span><span>(</span><span>ary</span><span>)</span> <span>{</span>\n    <span>return</span> ary<span>.</span><span>reduce</span><span>(</span><span>(</span><span>pre<span>,</span> cur</span><span>)</span> <span>=></span> <span>{</span>\n        <span>return</span> pre<span>.</span><span>concat</span><span>(</span>Array<span>.</span><span>isArray</span><span>(</span>cur<span>)</span> <span>?</span> <span>flatten</span><span>(</span>cur<span>)</span> <span>:</span> cur<span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>\n<span>}</span>\n<span>let</span> ary <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>]</span><span>,</span> <span>[</span><span>5</span><span>,</span> <span>[</span><span>6</span><span>,</span> <span>7</span><span>]</span><span>]</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span><span>flatten</span><span>(</span>ary<span>)</span><span>)</span>\n<span>//第五种处理：扩展运算符</span>\n<span>while</span> <span>(</span>ary<span>.</span><span>some</span><span>(</span>Array<span>.</span>isArray<span>)</span><span>)</span> <span>{</span>\n  ary <span>=</span> <span>[</span><span>]</span><span>.</span><span>concat</span><span>(</span><span>...</span>ary<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"_29-请实现一个-add-函数-满足以下功能\"> 29 请实现一个 add 函数，满足以下功能</h2>\n<div><pre><code><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span>       <span>// 1</span>\n<span>add</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>;</span>    <span>// 3</span>\n<span>add</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>)</span>；<span>// 6</span>\n<span>add</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span> <span>// 6</span>\n<span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>(</span><span>3</span><span>)</span><span>;</span> <span>// 6</span>\n<span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span> <span>// 6</span>\n<span>function</span> <span>add</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> args <span>=</span> <span>[</span><span>]</span><span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>\n  \n  <span>let</span> <span>fn</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>let</span> fn_args <span>=</span> <span>[</span><span>]</span><span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span>\n    <span>return</span> <span>add</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span>args<span>.</span><span>concat</span><span>(</span>fn_args<span>)</span><span>)</span>\n  <span>}</span>\n  \n  fn<span>.</span><span>toString</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>return</span> args<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span>b</span><span>)</span><span>=></span>a<span>+</span>b<span>)</span>\n  <span>}</span>\n  \n  <span>return</span> fn\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"_30-实现一个-sleep-函数-比如-sleep-1000-意味着等待1000毫秒\"> 30 实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒</h2>\n<div><pre><code><span>const</span> <span>sleep</span> <span>=</span> <span>(</span><span>time</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>setTimeout</span><span>(</span>resolve<span>,</span> time<span>)</span><span>)</span>\n<span>}</span>\n\n<span>sleep</span><span>(</span><span>1000</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 这里写你的骚操作</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_31-实现-5-add-3-minus-2-功能\"> 31 实现 (5).add(3).minus(2) 功能</h2>\n<blockquote>\n<p>例： 5 + 3 - 2，结果为 6</p>\n</blockquote>\n<div><pre><code><span>Number</span><span>.</span>prototype<span>.</span><span>add</span> <span>=</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span><span>valueOf</span><span>(</span><span>)</span> <span>+</span> n<span>;</span>\n<span>}</span><span>;</span>\n<span>Number</span><span>.</span>prototype<span>.</span><span>minus</span> <span>=</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span>\n  <span>return</span> <span>this</span><span>.</span><span>valueOf</span><span>(</span><span>)</span> <span>-</span> n<span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_32-给定两个数组-写一个方法来计算它们的交集\"> 32 给定两个数组，写一个方法来计算它们的交集</h2>\n<blockquote>\n<p>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>union</span> <span>(</span><span>arr1<span>,</span> arr2</span><span>)</span> <span>{</span>\n  <span>return</span> arr1<span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> <span>{</span>\n    <span>return</span> arr2<span>.</span><span>indexOf</span><span>(</span>item<span>)</span> <span>></span> <span>-</span> <span>1</span><span>;</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n <span>const</span> a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span><span>;</span>\n <span>const</span> b <span>=</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>]</span><span>;</span>\n console<span>.</span><span>log</span><span>(</span><span>union</span><span>(</span>a<span>,</span> b<span>)</span><span>)</span><span>;</span> <span>// [2, 2]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_33-实现一个js函数柯里化\"> 33 实现一个JS函数柯里化</h2>\n<blockquote>\n<p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术</p>\n</blockquote>\n<p><strong>通用版：</strong></p>\n<div><pre><code><span>function</span> <span>curry</span><span>(</span><span>fn<span>,</span> args</span><span>)</span> <span>{</span>\n  <span>var</span> length <span>=</span> fn<span>.</span>length<span>;</span>\n  <span>var</span> args <span>=</span> args <span>||</span> <span>[</span><span>]</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    newArgs <span>=</span> args<span>.</span><span>concat</span><span>(</span><span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>newArgs<span>.</span>length <span>&lt;</span> length<span>)</span> <span>{</span>\n      <span>return</span> <span>curry</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span>fn<span>,</span>newArgs<span>)</span><span>;</span>\n    <span>}</span><span>else</span><span>{</span>\n      <span>return</span> <span>fn</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span>newArgs<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n<span>function</span> <span>multiFn</span><span>(</span><span>a<span>,</span> b<span>,</span> c</span><span>)</span> <span>{</span>\n  <span>return</span> a <span>*</span> b <span>*</span> c<span>;</span>\n<span>}</span>\n\n<span>var</span> multi <span>=</span> <span>curry</span><span>(</span>multiFn<span>)</span><span>;</span>\n\n<span>multi</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>)</span><span>(</span><span>4</span><span>)</span><span>;</span>\n<span>multi</span><span>(</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>)</span><span>;</span>\n<span>multi</span><span>(</span><span>2</span><span>)</span><span>(</span><span>3</span><span>,</span><span>4</span><span>)</span><span>;</span>\n<span>multi</span><span>(</span><span>2</span><span>,</span><span>3</span><span>)</span><span>(</span><span>4</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>ES6写法：</strong></p>\n<div><pre><code><span>const</span> <span>curry</span> <span>=</span> <span>(</span><span>fn<span>,</span> arr <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>=></span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>(</span>\n  <span>arg</span> <span>=></span> arg<span>.</span>length <span>===</span> fn<span>.</span>length\n    <span>?</span> <span>fn</span><span>(</span><span>...</span>arg<span>)</span>\n    <span>:</span> <span>curry</span><span>(</span>fn<span>,</span> arg<span>)</span>\n<span>)</span><span>(</span><span>[</span><span>...</span>arr<span>,</span> <span>...</span>args<span>]</span><span>)</span>\n\n<span>let</span> curryTest<span>=</span><span>curry</span><span>(</span><span>(</span><span>a<span>,</span>b<span>,</span>c<span>,</span>d</span><span>)</span><span>=></span>a<span>+</span>b<span>+</span>c<span>+</span>d<span>)</span>\n<span>curryTest</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>)</span><span>(</span><span>4</span><span>)</span> <span>//返回10</span>\n<span>curryTest</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>(</span><span>4</span><span>)</span><span>(</span><span>3</span><span>)</span> <span>//返回10</span>\n<span>curryTest</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>(</span><span>3</span><span>,</span><span>4</span><span>)</span> <span>//返回10</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_34-实现一个双向绑定\"> 34 实现一个双向绑定</h2>\n<p><strong>defineProperty 版本：</strong></p>\n<div><pre><code><span>// 数据</span>\n<span>const</span> data <span>=</span> <span>{</span>\n  text<span>:</span> <span>'default'</span>\n<span>}</span><span>;</span>\n<span>const</span> input <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'input'</span><span>)</span><span>;</span>\n<span>const</span> span <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'span'</span><span>)</span><span>;</span>\n<span>// 数据劫持</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span> <span>'text'</span><span>,</span> <span>{</span>\n  <span>// 数据变化 --> 修改视图</span>\n  <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>\n    input<span>.</span>value <span>=</span> newVal<span>;</span>\n    span<span>.</span>innerHTML <span>=</span> newVal<span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n<span>// 视图更改 --> 数据变化</span>\ninput<span>.</span><span>addEventListener</span><span>(</span><span>'keyup'</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  data<span>.</span>text <span>=</span> e<span>.</span>target<span>.</span>value<span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>proxy 版本：</strong></p>\n<div><pre><code><span>// 数据</span>\n<span>const</span> data <span>=</span> <span>{</span>\n  text<span>:</span> <span>'default'</span>\n<span>}</span><span>;</span>\n<span>const</span> input <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'input'</span><span>)</span><span>;</span>\n<span>const</span> span <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'span'</span><span>)</span><span>;</span>\n<span>// 数据劫持</span>\n<span>const</span> handler <span>=</span> <span>{</span>\n  <span>set</span><span>(</span>target<span>,</span> key<span>,</span> value<span>)</span> <span>{</span>\n    target<span>[</span>key<span>]</span> <span>=</span> value<span>;</span>\n    <span>// 数据变化 --> 修改视图</span>\n    input<span>.</span>value <span>=</span> value<span>;</span>\n    span<span>.</span>innerHTML <span>=</span> value<span>;</span>\n    <span>return</span> value<span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n<span>const</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>data<span>,</span> handler<span>)</span><span>;</span>\n\n<span>// 视图更改 --> 数据变化</span>\ninput<span>.</span><span>addEventListener</span><span>(</span><span>'keyup'</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  proxy<span>.</span>text <span>=</span> e<span>.</span>target<span>.</span>value<span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_35-array-isarray-实现\"> 35 Array.isArray 实现</h2>\n<div><pre><code>Array<span>.</span><span>myIsArray</span> <span>=</span> <span>function</span><span>(</span><span>o</span><span>)</span> <span>{</span>\n  <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>Object</span><span>(</span>o<span>)</span><span>)</span> <span>===</span> <span>'[object Array]'</span><span>;</span>\n<span>}</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span>Array<span>.</span><span>myIsArray</span><span>(</span><span>[</span><span>]</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_36-对象数组如何去重\"> 36 对象数组如何去重</h2>\n<blockquote>\n<p>根据每个对象的某一个具体属性来进行去重</p>\n</blockquote>\n<div><pre><code><span>const</span> responseList <span>=</span> <span>[</span>\n  <span>{</span> id<span>:</span> <span>1</span><span>,</span> a<span>:</span> <span>1</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>2</span><span>,</span> a<span>:</span> <span>2</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>3</span><span>,</span> a<span>:</span> <span>3</span> <span>}</span><span>,</span>\n  <span>{</span> id<span>:</span> <span>1</span><span>,</span> a<span>:</span> <span>4</span> <span>}</span><span>,</span>\n<span>]</span><span>;</span>\n<span>const</span> result <span>=</span> responseList<span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc<span>,</span> cur</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> ids <span>=</span> acc<span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> item<span>.</span>id<span>)</span><span>;</span>\n  <span>return</span> ids<span>.</span><span>includes</span><span>(</span>cur<span>.</span>id<span>)</span> <span>?</span> acc <span>:</span> <span>[</span><span>...</span>acc<span>,</span> cur<span>]</span><span>;</span>\n<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span> <span>// -> [ { id: 1, a: 1}, {id: 2, a: 2}, {id: 3, a: 3} ]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_37-实现一个函数判断数据类型\"> 37 实现一个函数判断数据类型</h2>\n<div><pre><code><span>function</span> <span>getType</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>obj <span>===</span> <span>null</span><span>)</span> <span>return</span> <span>String</span><span>(</span>obj<span>)</span><span>;</span>\n  <span>return</span> <span>typeof</span> obj <span>===</span> <span>'object'</span> \n  <span>?</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>obj<span>)</span><span>.</span><span>replace</span><span>(</span><span>'[object '</span><span>,</span> <span>''</span><span>)</span><span>.</span><span>replace</span><span>(</span><span>']'</span><span>,</span> <span>''</span><span>)</span><span>.</span><span>toLowerCase</span><span>(</span><span>)</span>\n  <span>:</span> <span>typeof</span> obj<span>;</span>\n<span>}</span>\n\n<span>// 调用</span>\n<span>getType</span><span>(</span><span>null</span><span>)</span><span>;</span> <span>// -> null</span>\n<span>getType</span><span>(</span><span>undefined</span><span>)</span><span>;</span> <span>// -> undefined</span>\n<span>getType</span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span> <span>// -> object</span>\n<span>getType</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span> <span>// -> array</span>\n<span>getType</span><span>(</span><span>123</span><span>)</span><span>;</span> <span>// -> number</span>\n<span>getType</span><span>(</span><span>true</span><span>)</span><span>;</span> <span>// -> boolean</span>\n<span>getType</span><span>(</span><span>'123'</span><span>)</span><span>;</span> <span>// -> string</span>\n<span>getType</span><span>(</span><span><span>/</span><span>123</span><span>/</span></span><span>)</span><span>;</span> <span>// -> regexp</span>\n<span>getType</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// -> date</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_38-查找字符串中出现最多的字符和个数\"> 38 查找字符串中出现最多的字符和个数</h2>\n<div><pre><code><span>// 例: abbcccddddd -> 字符最多的是d，出现了5次</span>\n\n<span>let</span> str <span>=</span> <span>\"abcabcabcbbccccc\"</span><span>;</span>\n<span>let</span> num <span>=</span> <span>0</span><span>;</span>\n<span>let</span> char <span>=</span> <span>''</span><span>;</span>\n\n<span>// 使其按照一定的次序排列</span>\nstr <span>=</span> str<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>sort</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>''</span><span>)</span><span>;</span>\n<span>// \"aaabbbbbcccccccc\"</span>\n\n<span>// 定义正则表达式</span>\n<span>let</span> re <span>=</span> <span><span>/</span><span>(\\w)\\1+</span><span>/</span><span>g</span></span><span>;</span>\nstr<span>.</span><span>replace</span><span>(</span>re<span>,</span><span>(</span><span>$<span>0</span><span>,</span>$<span>1</span></span><span>)</span> <span>=></span> <span>{</span>\n  <span>if</span><span>(</span>num <span>&lt;</span> $<span>0.</span>length<span>)</span><span>{</span>\n    num <span>=</span> $<span>0.</span>length<span>;</span>\n    char <span>=</span> $<span>1</span><span>;</span>        \n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\nconsole<span>.</span><span>log</span><span>(</span><span><span>`</span><span>字符最多的是</span><span><span>${</span>char<span>}</span></span><span>，出现了</span><span><span>${</span>num<span>}</span></span><span>次</span><span>`</span></span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_39-数组去重问题\"> 39 数组去重问题</h2>\n<blockquote>\n<p>首先:我知道多少种去重方式</p>\n</blockquote>\n<h3 id=\"双层-for-循环\"> 双层 for 循环</h3>\n<div><pre><code><span>function</span> <span>distinct</span><span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>let</span> i<span>=</span><span>0</span><span>,</span> len<span>=</span>arr<span>.</span>length<span>;</span> i<span>&lt;</span>len<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>let</span> j<span>=</span>i<span>+</span><span>1</span><span>;</span> j<span>&lt;</span>len<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>==</span> arr<span>[</span>j<span>]</span><span>)</span> <span>{</span>\n        arr<span>.</span><span>splice</span><span>(</span>j<span>,</span> <span>1</span><span>)</span><span>;</span>\n        <span>// splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一</span>\n        len<span>--</span><span>;</span>\n        j<span>--</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> arr<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>思想: 双重 <code>for</code> 循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是<code>O(n^2)</code>，如果数组长度很大，效率会很低</p>\n</blockquote>\n<h3 id=\"array-filter-加-indexof-includes\"> Array.filter() 加 indexOf/includes</h3>\n<div><pre><code><span>function</span> <span>distinct</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  <span>let</span> arr <span>=</span> a<span>.</span><span>concat</span><span>(</span>b<span>)</span><span>;</span>\n  <span>return</span> arr<span>.</span><span>filter</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span><span>=></span> <span>{</span>\n    <span>//return arr.indexOf(item) === index</span>\n    <span>return</span> arr<span>.</span><span>includes</span><span>(</span>item<span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>思想: 利用<code>indexOf</code>检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素</p>\n</blockquote>\n<h3 id=\"es6-中的-set-去重\"> ES6 中的 Set 去重</h3>\n<div><pre><code><span>function</span> <span>distinct</span><span>(</span><span>array</span><span>)</span> <span>{</span>\n  <span>return</span> Array<span>.</span><span>from</span><span>(</span><span>new</span> <span>Set</span><span>(</span>array<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>思想: ES6 提供了新的数据结构 Set，Set 结构的一个特性就是成员值都是唯一的，没有重复的值。</p>\n</blockquote>\n<h3 id=\"reduce-实现对象数组去重复\"> reduce 实现对象数组去重复</h3>\n<div><pre><code><span>var</span> resources <span>=</span> <span>[</span>    <span>{</span> name<span>:</span> <span>\"张三\"</span><span>,</span> age<span>:</span> <span>\"18\"</span> <span>}</span><span>,</span>    <span>{</span> name<span>:</span> <span>\"张三\"</span><span>,</span> age<span>:</span> <span>\"19\"</span> <span>}</span><span>,</span>    <span>{</span> name<span>:</span> <span>\"张三\"</span><span>,</span> age<span>:</span> <span>\"20\"</span> <span>}</span><span>,</span>    <span>{</span> name<span>:</span> <span>\"李四\"</span><span>,</span> age<span>:</span> <span>\"19\"</span> <span>}</span><span>,</span>    <span>{</span> name<span>:</span> <span>\"王五\"</span><span>,</span> age<span>:</span> <span>\"20\"</span> <span>}</span><span>,</span>    <span>{</span> name<span>:</span> <span>\"赵六\"</span><span>,</span> age<span>:</span> <span>\"21\"</span> <span>}</span><span>]</span><span>var</span> temp <span>=</span> <span>{</span><span>}</span><span>;</span>resources <span>=</span> resources<span>.</span><span>reduce</span><span>(</span><span>(</span><span>prev<span>,</span> curv</span><span>)</span> <span>=></span> <span>{</span> <span>// 如果临时对象中有这个名字，什么都不做 if (temp[curv.name]) {  }else {    // 如果临时对象没有就把这个名字加进去，同时把当前的这个对象加入到prev中    temp[curv.name] = true;    prev.push(curv); } return prev}, []);console.log(\"结果\", resources);</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>这种方法是利用高阶函数 <code>reduce</code> 进行去重， 这里只需要注意<code>initialValue</code>得放一个空数组[]，不然没法<code>push</code></p>\n</blockquote>\n",
      "date_published": "2021-07-29T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.049Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "手撸实现"
      ]
    },
    {
      "title": "Blog Home",
      "url": "https://github.com/letme350/",
      "id": "https://github.com/letme350/",
      "content_html": "",
      "date_modified": "2021-07-30T15:17:57.064Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript下",
      "url": "https://github.com/letme350/javaScript/baseTwo/",
      "id": "https://github.com/letme350/javaScript/baseTwo/",
      "content_html": "<h1 id=\"javascript下\"> JavaScript下</h1>\n<h2 id=\"javascript基础\"> JavaScript基础</h2>\n<h3 id=\"_71-window-onload和-document-ready\"> 71 window.onload和$(document).ready</h3>\n<blockquote>\n<p>原生<code>JS</code>的<code>window.onload</code>与<code>Jquery</code>的<code>$(document).ready(function(){})</code>有什么不同？如何用原生JS实现Jq的<code>ready</code>方法？</p>\n</blockquote>\n<ul>\n<li><code>window.onload()</code>方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</li>\n<li><code>$(document).ready()</code>是<code>DOM</code>结构绘制完毕后就执行，不必等到加载完毕</li>\n</ul>\n<div><pre><code><span>function</span> <span>ready</span><span>(</span><span>fn</span><span>)</span><span>{</span>\n  <span>if</span><span>(</span>document<span>.</span>addEventListener<span>)</span> <span>{</span>        <span>//标准浏览器</span>\n    document<span>.</span><span>addEventListener</span><span>(</span><span>'DOMContentLoaded'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>//注销事件, 避免反复触发</span>\n      document<span>.</span><span>removeEventListener</span><span>(</span><span>'DOMContentLoaded'</span><span>,</span>arguments<span>.</span>callee<span>,</span> <span>false</span><span>)</span><span>;</span>\n      <span>fn</span><span>(</span><span>)</span><span>;</span>            <span>//执行函数</span>\n    <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span><span>else</span> <span>if</span><span>(</span>document<span>.</span>attachEvent<span>)</span> <span>{</span>        <span>//IE</span>\n    document<span>.</span><span>attachEvent</span><span>(</span><span>'onreadystatechange'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>if</span><span>(</span>document<span>.</span>readyState <span>==</span> <span>'complete'</span><span>)</span> <span>{</span>\n        document<span>.</span><span>detachEvent</span><span>(</span><span>'onreadystatechange'</span><span>,</span> arguments<span>.</span>callee<span>)</span><span>;</span>\n        <span>fn</span><span>(</span><span>)</span><span>;</span>        <span>//函数执行</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n  <span>}</span>\n <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_72-addeventlistener-和attachevent-的区别\"> 72 addEventListener()和attachEvent()的区别</h3>\n<ul>\n<li><code>addEventListener()</code>是符合W3C规范的标准方法; <code>attachEvent()</code>是IE低版本的非标准方法</li>\n<li><code>addEventListener()</code>支持事件冒泡和事件捕获; - 而<code>attachEvent()</code>只支持事件冒泡</li>\n<li><code>addEventListener()</code>的第一个参数中,事件类型不需要添加<code>on</code>; <code>attachEvent()</code>需要添加<code>'on'</code></li>\n<li>如果为同一个元素绑定多个事件, <code>addEventListener()</code>会按照事件绑定的顺序依次执行, <code>attachEvent()</code>会按照事件绑定的顺序倒序执行</li>\n</ul>\n<h3 id=\"_73-获取页面所有的checkbox\"> 73 获取页面所有的checkbox</h3>\n<div><pre><code><span>var</span> resultArr<span>=</span> <span>[</span><span>]</span><span>;</span>\n<span>var</span> input <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span>'input'</span><span>)</span><span>;</span>\n<span>for</span><span>(</span> <span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> input<span>.</span>length<span>;</span> i<span>++</span> <span>)</span> <span>{</span>\n  <span>if</span><span>(</span> input<span>[</span>i<span>]</span><span>.</span>type <span>==</span> <span>'checkbox'</span> <span>)</span> <span>{</span>\n    resultArr<span>.</span><span>push</span><span>(</span> input<span>[</span>i<span>]</span> <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>//resultArr即中获取到了页面中的所有checkbox</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_74-数组去重方法总结\"> 74 数组去重方法总结</h3>\n<p><strong>方法一、利用ES6 Set去重（ES6中最常用）：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>return</span> Array<span>.</span><span>from</span><span>(</span><span>new</span> <span>Set</span><span>(</span>arr<span>)</span><span>)</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}]</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>方法二、利用for嵌套for，然后splice去重（ES5中最常用）：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span><span>{</span>            \n  <span>for</span><span>(</span><span>var</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>\n    <span>for</span><span>(</span><span>var</span> j<span>=</span>i<span>+</span><span>1</span><span>;</span> j<span>&lt;</span>arr<span>.</span>length<span>;</span> j<span>++</span><span>)</span><span>{</span>\n      <span>if</span><span>(</span>arr<span>[</span>i<span>]</span><span>==</span>arr<span>[</span>j<span>]</span><span>)</span><span>{</span>         <span>//第一个等同于第二个，splice方法删除第二个</span>\n        arr<span>.</span><span>splice</span><span>(</span>j<span>,</span><span>1</span><span>)</span><span>;</span>\n        j<span>--</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> arr<span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>\n<li>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</li>\n<li>想快速学习更多常用的<code>ES6</code>语法</li>\n</ul>\n<p><strong>方法三、利用indexOf去重：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>arr<span>)</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'type error!'</span><span>)</span>\n    <span>return</span>\n  <span>}</span>\n  <span>var</span> array <span>=</span> <span>[</span><span>]</span><span>;</span>\n  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>array <span>.</span><span>indexOf</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span> <span>===</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n      array <span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> array<span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>// [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}]  //NaN、{}没有去重</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>\n<p>新建一个空的结果数组，<code>for</code> 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则<code>push</code>进数组</p>\n</blockquote>\n<p><strong>方法四、利用sort()：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>arr<span>)</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'type error!'</span><span>)</span>\n    <span>return</span><span>;</span>\n  <span>}</span>\n  arr <span>=</span> arr<span>.</span><span>sort</span><span>(</span><span>)</span>\n  <span>var</span> arrry<span>=</span> <span>[</span>arr<span>[</span><span>0</span><span>]</span><span>]</span><span>;</span>\n  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>!==</span> arr<span>[</span>i<span>-</span><span>1</span><span>]</span><span>)</span> <span>{</span>\n      arrry<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> arrry<span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>// [0, 1, 15, \"NaN\", NaN, NaN, {…}, {…}, \"a\", false, null, true, \"true\", undefined]      //NaN、{}没有去重</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>\n<p>利用<code>sort()</code>排序方法，然后根据排序后的结果进行遍历及相邻元素比对</p>\n</blockquote>\n<p><strong>方法五、利用对象的属性不能相同的特点进行去重：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>arr<span>)</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'type error!'</span><span>)</span>\n    <span>return</span>\n  <span>}</span>\n  <span>var</span> arrry<span>=</span> <span>[</span><span>]</span><span>;</span>\n    <span>var</span>  obj <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>!</span>obj<span>[</span>arr<span>[</span>i<span>]</span><span>]</span><span>)</span> <span>{</span>\n      arrry<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span>\n      obj<span>[</span>arr<span>[</span>i<span>]</span><span>]</span> <span>=</span> <span>1</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      obj<span>[</span>arr<span>[</span>i<span>]</span><span>]</span><span>++</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> arrry<span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"true\", 15, false, undefined, null, NaN, 0, \"a\", {…}]    //两个true直接去掉了，NaN和{}去重</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>方法六、利用includes：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>arr<span>)</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'type error!'</span><span>)</span>\n    <span>return</span>\n  <span>}</span>\n  <span>var</span> array <span>=</span><span>[</span><span>]</span><span>;</span>\n  <span>for</span><span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span><span>(</span> <span>!</span>array<span>.</span><span>includes</span><span>(</span> arr<span>[</span>i<span>]</span><span>)</span> <span>)</span> <span>{</span><span>//includes 检测数组是否有某个值</span>\n      array<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> array\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}]     //{}没有去重</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>方法七、利用hasOwnProperty：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>    \n  <span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>    \n  <span>return</span> arr<span>.</span><span>filter</span><span>(</span><span>function</span><span>(</span><span>item<span>,</span> index<span>,</span> arr</span><span>)</span><span>{</span>        \n    <span>return</span> obj<span>.</span><span>hasOwnProperty</span><span>(</span><span>typeof</span> item <span>+</span> item<span>)</span> <span>?</span> <span>false</span> <span>:</span> <span>(</span>obj<span>[</span><span>typeof</span> item <span>+</span> item<span>]</span> <span>=</span> <span>true</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>   \n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>        \n<span>//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}]   //所有的都去重了</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>利用<code>hasOwnProperty</code> 判断是否存在对象属性</p>\n</blockquote>\n<p><strong>方法八、利用filter：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>  \n  <span>return</span> arr<span>.</span><span>filter</span><span>(</span><span>function</span><span>(</span><span>item<span>,</span> index<span>,</span> arr</span><span>)</span> <span>{</span>\n    <span>//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素    </span>\n    <span>return</span> arr<span>.</span><span>indexOf</span><span>(</span>item<span>,</span> <span>0</span><span>)</span> <span>===</span> index<span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}]</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>方法九、利用递归去重：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span> <span>{</span>    \n  <span>var</span> array<span>=</span> arr<span>;</span>    \n  <span>var</span> len <span>=</span> array<span>.</span>length<span>;</span>\n  array<span>.</span><span>sort</span><span>(</span><span>function</span><span>(</span><span>a<span>,</span>b</span><span>)</span><span>{</span>   \n    <span>//排序后更加方便去重</span>\n    <span>return</span> a <span>-</span> b<span>;</span>\n  <span>}</span><span>)</span>\n  <span>function</span> <span>loop</span><span>(</span><span>index</span><span>)</span><span>{</span>        \n    <span>if</span><span>(</span>index <span>>=</span> <span>1</span><span>)</span><span>{</span>            \n      <span>if</span><span>(</span>array<span>[</span>index<span>]</span> <span>===</span> array<span>[</span>index<span>-</span><span>1</span><span>]</span><span>)</span><span>{</span>            \n        array<span>.</span><span>splice</span><span>(</span>index<span>,</span><span>1</span><span>)</span><span>;</span>            \n      <span>}</span>            \n      <span>loop</span><span>(</span>index <span>-</span> <span>1</span><span>)</span><span>;</span>    \n      <span>//递归loop，然后数组去重        </span>\n    <span>}</span>\n  <span>}</span>\n  <span>loop</span><span>(</span>len<span>-</span><span>1</span><span>)</span><span>;</span>\n  <span>return</span> array<span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined]</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>方法十、利用Map数据结构去重：</strong></p>\n<div><pre><code><span>function</span> <span>arrayNonRepeatfy</span><span>(</span><span>arr</span><span>)</span> <span>{</span>\n  <span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>\n  <span>let</span> array <span>=</span> <span>new</span> <span>Array</span><span>(</span><span>)</span><span>;</span>  <span>// 数组用于返回结果</span>\n  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span><span>(</span>map <span>.</span><span>has</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>  <span>// 如果有该key值</span>\n      map <span>.</span><span>set</span><span>(</span>arr<span>[</span>i<span>]</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      map <span>.</span><span>set</span><span>(</span>arr<span>[</span>i<span>]</span><span>,</span> <span>false</span><span>)</span><span>;</span>   <span>// 如果没有该key值</span>\n      array <span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>return</span> array <span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>//[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined]</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>\n<p>创建一个空<code>Map</code>数据结构，遍历需要去重的数组，把数组的每一个元素作为<code>key</code>存到<code>Map</code>中。由于<code>Map</code>中不会出现相同的<code>key</code>值，所以最终得到的就是去重后的结果</p>\n</blockquote>\n<p><strong>方法十一、利用reduce+includes：</strong></p>\n<div><pre><code><span>function</span> <span>unique</span><span>(</span><span>arr</span><span>)</span><span>{</span>\n  <span>return</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span><span>prev<span>,</span>cur</span><span>)</span> <span>=></span> prev<span>.</span><span>includes</span><span>(</span>cur<span>)</span> <span>?</span> prev <span>:</span> <span>[</span><span>...</span>prev<span>,</span>cur<span>]</span><span>,</span><span>[</span><span>]</span><span>)</span><span>;</span>\n<span>}</span>\n<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>'true'</span><span>,</span><span>'true'</span><span>,</span><span>true</span><span>,</span><span>true</span><span>,</span><span>15</span><span>,</span><span>15</span><span>,</span><span>false</span><span>,</span><span>false</span><span>,</span> <span>undefined</span><span>,</span><span>undefined</span><span>,</span> <span>null</span><span>,</span><span>null</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span><span>'NaN'</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span><span>{</span><span>}</span><span>,</span><span>{</span><span>}</span><span>]</span><span>;</span>\n<span>// [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}]</span>\nconsole<span>.</span><span>log</span><span>(</span><span>unique</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>方法十二、[...new Set(arr)]：</strong></p>\n<div><pre><code><span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>arr<span>)</span><span>]</span><span>//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_75-设计题-想实现一个对页面某个节点的拖曳-如何做-使用原生js\"> 75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h3>\n<ul>\n<li>给需要拖拽的节点绑定<code>mousedown</code>, <code>mousemove</code>, <code>mouseup</code>事件</li>\n<li><code>mousedown</code>事件触发后，开始拖拽</li>\n<li><code>mousemove</code>时，需要通过<code>event.clientX</code>和<code>clientY</code>获取拖拽位置，并实时更新位置</li>\n<li><code>mouseup</code>时，拖拽结束</li>\n<li>需要注意浏览器边界的情况</li>\n</ul>\n<h3 id=\"_76-javascript全局函数和全局变量\"> 76 Javascript全局函数和全局变量</h3>\n<p><strong>全局变量：</strong></p>\n<ul>\n<li><code>Infinity</code> 代表正的无穷大的数值。</li>\n<li><code>NaN</code> 指示某个值是不是数字值。</li>\n<li><code>undefined</code> 指示未定义的值。</li>\n</ul>\n<p><strong>全局函数：</strong></p>\n<ul>\n<li><code>decodeURI()</code> 解码某个编码的 <code>URI</code>。</li>\n<li><code>decodeURIComponent()</code> 解码一个编码的 <code>URI</code> 组件。</li>\n<li><code>encodeURI()</code> 把字符串编码为 URI。</li>\n<li><code>encodeURIComponent()</code> 把字符串编码为 <code>URI</code> 组件。</li>\n<li><code>escape()</code> 对字符串进行编码。</li>\n<li><code>eval()</code> 计算 <code>JavaScript</code> 字符串，并把它作为脚本代码来执行。</li>\n<li><code>isFinite()</code> 检查某个值是否为有穷大的数。</li>\n<li><code>isNaN()</code> 检查某个值是否是数字。</li>\n<li><code>Number()</code> 把对象的值转换为数字。</li>\n<li><code>parseFloat()</code> 解析一个字符串并返回一个浮点数。</li>\n<li><code>parseInt()</code> 解析一个字符串并返回一个整数。</li>\n<li><code>String()</code> 把对象的值转换为字符串。</li>\n<li><code>unescape()</code> 对由<code>escape()</code> 编码的字符串进行解码</li>\n</ul>\n<h3 id=\"_77-使用js实现一个持续的动画效果\"> 77 使用js实现一个持续的动画效果</h3>\n<p><strong>定时器思路：</strong></p>\n<div><pre><code><span>var</span> e <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'e'</span><span>)</span>\n<span>var</span> flag <span>=</span> <span>true</span><span>;</span>\n<span>var</span> left <span>=</span> <span>0</span><span>;</span>\n<span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  left <span>==</span> <span>0</span> <span>?</span> flag <span>=</span> <span>true</span> <span>:</span> left <span>==</span> <span>100</span> <span>?</span> flag <span>=</span> <span>false</span> <span>:</span> <span>''</span>\n  flag <span>?</span> e<span>.</span>style<span>.</span>left <span>=</span> <span><span>`</span><span> </span><span><span>${</span>left<span>++</span><span>}</span></span><span>px</span><span>`</span></span> <span>:</span> e<span>.</span>style<span>.</span>left <span>=</span> <span><span>`</span><span> </span><span><span>${</span>left<span>--</span><span>}</span></span><span>px</span><span>`</span></span>\n<span>}</span><span>,</span> <span>1000</span> <span>/</span> <span>60</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>requestAnimationFrame：</strong></p>\n<div><pre><code><span>//兼容性处理</span>\nwindow<span>.</span>requestAnimFrame <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>return</span> window<span>.</span>requestAnimationFrame <span>||</span>\n    window<span>.</span>webkitRequestAnimationFrame <span>||</span>\n    window<span>.</span>mozRequestAnimationFrame <span>||</span>\n    <span>function</span><span>(</span><span>callback</span><span>)</span><span>{</span>\n      window<span>.</span><span>setTimeout</span><span>(</span>callback<span>,</span> <span>1000</span> <span>/</span> <span>60</span><span>)</span><span>;</span>\n    <span>}</span><span>;</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n\n<span>var</span> e <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>\"e\"</span><span>)</span><span>;</span>\n<span>var</span> flag <span>=</span> <span>true</span><span>;</span>\n<span>var</span> left <span>=</span> <span>0</span><span>;</span>\n\n<span>function</span> <span>render</span><span>(</span><span>)</span> <span>{</span>\n  left <span>==</span> <span>0</span> <span>?</span> flag <span>=</span> <span>true</span> <span>:</span> left <span>==</span> <span>100</span> <span>?</span> flag <span>=</span> <span>false</span> <span>:</span> <span>''</span><span>;</span>\n  flag <span>?</span> e<span>.</span>style<span>.</span>left <span>=</span> <span><span>`</span><span> </span><span><span>${</span>left<span>++</span><span>}</span></span><span>px</span><span>`</span></span> <span>:</span> e<span>.</span>style<span>.</span>left <span>=</span> <span><span>`</span><span> </span><span><span>${</span>left<span>--</span><span>}</span></span><span>px</span><span>`</span></span><span>;</span>\n<span>}</span>\n\n<span>(</span><span>function</span> <span>animloop</span><span>(</span><span>)</span> <span>{</span>\n  <span>render</span><span>(</span><span>)</span><span>;</span>\n  <span>requestAnimFrame</span><span>(</span>animloop<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>使用css实现一个持续的动画效果：</strong></p>\n<div><pre><code><span>animation</span><span>:</span>mymove 5s infinite<span>;</span>\n\n<span><span>@keyframes</span> mymove</span> <span>{</span>\n  <span>from</span> <span>{</span><span>top</span><span>:</span>0px<span>;</span><span>}</span>\n  <span>to</span> <span>{</span><span>top</span><span>:</span>200px<span>;</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li><code>animation-name</code> 规定需要绑定到选择器的 <code>keyframe</code>名称。</li>\n<li><code>animation-duration</code> 规定完成动画所花费的时间，以秒或毫秒计。</li>\n<li><code>animation-timing-function</code> 规定动画的速度曲线。</li>\n<li><code>animation-delay</code> 规定在动画开始之前的延迟。</li>\n<li><code>animation-iteration-count</code> 规定动画应该播放的次数。</li>\n<li><code>animation-direction</code> 规定是否应该轮流反向播放动画</li>\n</ul>\n<h3 id=\"_78-封装一个函数-参数是定时器的时间-then执行回调函数\"> 78 封装一个函数，参数是定时器的时间，.then执行回调函数</h3>\n<div><pre><code><span>function</span> <span>sleep</span> <span>(</span><span>time</span><span>)</span> <span>{</span>\n  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>setTimeout</span><span>(</span>resolve<span>,</span> time<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_79-怎么判断两个对象相等\"> 79 怎么判断两个对象相等？</h3>\n<div><pre><code>obj<span>=</span><span>{</span>    \n  a<span>:</span><span>1</span><span>,</span>    \n  b<span>:</span><span>2</span>\n<span>}</span>\nobj2<span>=</span><span>{</span>    \n  a<span>:</span><span>1</span><span>,</span>    \n  b<span>:</span><span>2</span>\n<span>}</span>\nobj3<span>=</span><span>{</span>    \n  a<span>:</span><span>1</span><span>,</span>    \n  b<span>:</span><span>'2'</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>\n<p>可以转换为字符串来判断</p>\n</blockquote>\n<div><pre><code><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>==</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj2<span>)</span><span>;</span><span>//true</span>\n<span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>==</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj3<span>)</span><span>;</span><span>//false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_80-项目做过哪些性能优化\"> 80 项目做过哪些性能优化？</h3>\n<ul>\n<li>减少 <code>HTTP</code> 请求数</li>\n<li>减少 <code>DNS</code> 查询</li>\n<li>使用 <code>CDN</code></li>\n<li>避免重定向</li>\n<li>图片懒加载</li>\n<li>减少 <code>DOM</code> 元素数量</li>\n<li>减少<code>DOM</code> 操作</li>\n<li>使用外部 <code>JavaScript</code> 和 <code>CSS</code></li>\n<li>压缩 <code>JavaScript</code> 、 <code>CSS</code> 、字体、图片等</li>\n<li>优化 <code>CSS Sprite</code></li>\n<li>使用 <code>iconfont</code></li>\n<li>字体裁剪</li>\n<li>多域名分发划分内容到不同域名</li>\n<li>尽量减少 <code>iframe</code> 使用</li>\n<li>避免图片 <code>src</code> 为空</li>\n<li>把样式表放在<code>link</code> 中</li>\n<li>把<code>JavaScript</code>放在页面底部</li>\n</ul>\n<h3 id=\"_81-浏览器缓存\"> 81 浏览器缓存</h3>\n<blockquote>\n<p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p>\n</blockquote>\n<ul>\n<li>先根据这个资源的一些 <code>http header</code> 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li>\n<li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li>\n<li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li>\n<li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li>\n<li>当 <code>ctrl+f5</code> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>\n<li>当 <code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li>\n</ul>\n<p><strong>强缓存：</strong></p>\n<ul>\n<li><code>Expires</code>（该字段是 <code>http1.0</code> 时的规范，值为一个绝对时间的 <code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间）</li>\n<li><code>Cache-Control:max-age</code>（该字段是 <code>http1.1</code>的规范，强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒）</li>\n</ul>\n<p><strong>协商缓存：</strong></p>\n<ul>\n<li><code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li>\n<li><code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li>\n<li><code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li>\n<li><code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li>\n</ul>\n<h3 id=\"_82-websocket\"> 82 WebSocket</h3>\n<blockquote>\n<p>由于 <code>http</code> 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 <code>WebSocket</code>被发明出来\n相比与 <code>http</code> 具有以下有点</p>\n</blockquote>\n<ul>\n<li>支持双向通信，实时性更强；</li>\n<li>可以发送文本，也可以二进制文件；</li>\n<li>协议标识符是 <code>ws</code>，加密后是 <code>wss</code> ；</li>\n<li>较少的控制开销。连接创建后，<code>ws</code>客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有<code>2~10</code>字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而<code>HTTP</code>协议每次通信都需要携带完整的头部；</li>\n<li>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）</li>\n<li>无跨域问题。</li>\n</ul>\n<blockquote>\n<p>实现比较简单，服务端库如 <code>socket.io</code>、<code>ws</code>，可以很好的帮助我们入门。而客户端也只需要参照 <code>api</code> 实现即可</p>\n</blockquote>\n<h3 id=\"_83-尽可能多的说出你对-electron-的理解\"> 83 尽可能多的说出你对 Electron 的理解</h3>\n<blockquote>\n<p>最最重要的一点，<code>electron</code> 实际上是一个套了 <code>Chrome</code> 的 <code>nodeJS</code>程序</p>\n</blockquote>\n<p><strong>所以应该是从两个方面说开来：</strong></p>\n<ul>\n<li><code>Chrome</code> （无各种兼容性问题）；</li>\n<li><code>NodeJS</code>（<code>NodeJS</code> 能做的它也能做）</li>\n</ul>\n<h3 id=\"_84-深浅拷贝\"> 84 深浅拷贝</h3>\n<p><strong>浅拷贝：</strong></p>\n<ul>\n<li><code>Object.assign</code></li>\n<li>或者展开运算符</li>\n</ul>\n<p><strong>深拷贝：</strong></p>\n<ul>\n<li>可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</li>\n</ul>\n<div><pre><code><span>let</span> a <span>=</span> <span>{</span>\n  age<span>:</span> <span>1</span><span>,</span>\n  jobs<span>:</span> <span>{</span>\n    first<span>:</span> <span>'FE'</span>\n  <span>}</span>\n<span>}</span>\n<span>let</span> b <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>a<span>)</span><span>)</span>\na<span>.</span>jobs<span>.</span>first <span>=</span> <span>'native'</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>.</span>jobs<span>.</span>first<span>)</span> <span>// FE</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>该方法也是有局限性的：</strong></p>\n<ul>\n<li>会忽略 <code>undefined</code></li>\n<li>不能序列化函数</li>\n<li>不能解决循环引用的对象</li>\n</ul>\n<h3 id=\"_85-防抖-节流\"> 85 防抖/节流</h3>\n<p><strong>防抖：</strong></p>\n<blockquote>\n<p>在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现</p>\n</blockquote>\n<div><pre><code><span>// 使用 underscore 的源码来解释防抖动</span>\n\n<span>/**\n * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */</span>\n_<span>.</span><span>debounce</span> <span>=</span> <span>function</span><span>(</span><span>func<span>,</span> wait<span>,</span> immediate</span><span>)</span> <span>{</span>\n  <span>var</span> timeout<span>,</span> args<span>,</span> context<span>,</span> timestamp<span>,</span> result<span>;</span>\n\n  <span>var</span> <span>later</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 现在和上一次时间戳比较</span>\n    <span>var</span> last <span>=</span> _<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> timestamp<span>;</span>\n    <span>// 如果当前间隔时间少于设定时间且大于0就重新设置定时器</span>\n    <span>if</span> <span>(</span>last <span>&lt;</span> wait <span>&amp;&amp;</span> last <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n      timeout <span>=</span> <span>setTimeout</span><span>(</span>later<span>,</span> wait <span>-</span> last<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>// 否则的话就是时间到了执行回调函数</span>\n      timeout <span>=</span> <span>null</span><span>;</span>\n      <span>if</span> <span>(</span><span>!</span>immediate<span>)</span> <span>{</span>\n        result <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>timeout<span>)</span> context <span>=</span> args <span>=</span> <span>null</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>;</span>\n\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    context <span>=</span> <span>this</span><span>;</span>\n    args <span>=</span> arguments<span>;</span>\n    <span>// 获得时间戳</span>\n    timestamp <span>=</span> _<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n    <span>// 如果定时器不存在且立即执行函数</span>\n    <span>var</span> callNow <span>=</span> immediate <span>&amp;&amp;</span> <span>!</span>timeout<span>;</span>\n    <span>// 如果定时器不存在就创建一个</span>\n    <span>if</span> <span>(</span><span>!</span>timeout<span>)</span> timeout <span>=</span> <span>setTimeout</span><span>(</span>later<span>,</span> wait<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>callNow<span>)</span> <span>{</span>\n      <span>// 如果需要立即执行函数的话 通过 apply 执行</span>\n      result <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span><span>;</span>\n      context <span>=</span> args <span>=</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> result<span>;</span>\n  <span>}</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><blockquote>\n<p>整体函数实现</p>\n</blockquote>\n<p>对于按钮防点击来说的实现</p>\n<ul>\n<li>开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了</li>\n<li>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数</li>\n</ul>\n<p><strong>节流：</strong></p>\n<blockquote>\n<p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p>\n</blockquote>\n<div><pre><code><span>/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */</span>\n_<span>.</span><span>throttle</span> <span>=</span> <span>function</span><span>(</span><span>func<span>,</span> wait<span>,</span> options</span><span>)</span> <span>{</span>\n  <span>var</span> context<span>,</span> args<span>,</span> result<span>;</span>\n  <span>var</span> timeout <span>=</span> <span>null</span><span>;</span>\n  <span>// 之前的时间戳</span>\n  <span>var</span> previous <span>=</span> <span>0</span><span>;</span>\n  <span>// 如果 options 没传则设为空对象</span>\n  <span>if</span> <span>(</span><span>!</span>options<span>)</span> options <span>=</span> <span>{</span><span>}</span><span>;</span>\n  <span>// 定时器回调函数</span>\n  <span>var</span> <span>later</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 如果设置了 leading，就将 previous 设为 0</span>\n    <span>// 用于下面函数的第一个 if 判断</span>\n    previous <span>=</span> options<span>.</span>leading <span>===</span> <span>false</span> <span>?</span> <span>0</span> <span>:</span> _<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n    <span>// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span>\n    timeout <span>=</span> <span>null</span><span>;</span>\n    result <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>!</span>timeout<span>)</span> context <span>=</span> args <span>=</span> <span>null</span><span>;</span>\n  <span>}</span><span>;</span>\n  <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 获得当前时间戳</span>\n    <span>var</span> now <span>=</span> _<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n    <span>// 首次进入前者肯定为 true</span>\n    <span>// 如果需要第一次不执行函数</span>\n    <span>// 就将上次时间戳设为当前的</span>\n    <span>// 这样在接下来计算 remaining 的值时会大于0</span>\n    <span>if</span> <span>(</span><span>!</span>previous <span>&amp;&amp;</span> options<span>.</span>leading <span>===</span> <span>false</span><span>)</span> previous <span>=</span> now<span>;</span>\n    <span>// 计算剩余时间</span>\n    <span>var</span> remaining <span>=</span> wait <span>-</span> <span>(</span>now <span>-</span> previous<span>)</span><span>;</span>\n    context <span>=</span> <span>this</span><span>;</span>\n    args <span>=</span> arguments<span>;</span>\n    <span>// 如果当前调用已经大于上次调用时间 + wait</span>\n    <span>// 或者用户手动调了时间</span>\n    <span>// 如果设置了 trailing，只会进入这个条件</span>\n    <span>// 如果没有设置 leading，那么第一次会进入这个条件</span>\n    <span>// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span>\n    <span>// 其实还是会进入的，因为定时器的延时</span>\n    <span>// 并不是准确的时间，很可能你设置了2秒</span>\n    <span>// 但是他需要2.2秒才触发，这时候就会进入这个条件</span>\n    <span>if</span> <span>(</span>remaining <span>&lt;=</span> <span>0</span> <span>||</span> remaining <span>></span> wait<span>)</span> <span>{</span>\n      <span>// 如果存在定时器就清理掉否则会调用二次回调</span>\n      <span>if</span> <span>(</span>timeout<span>)</span> <span>{</span>\n        <span>clearTimeout</span><span>(</span>timeout<span>)</span><span>;</span>\n        timeout <span>=</span> <span>null</span><span>;</span>\n      <span>}</span>\n      previous <span>=</span> now<span>;</span>\n      result <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span>context<span>,</span> args<span>)</span><span>;</span>\n      <span>if</span> <span>(</span><span>!</span>timeout<span>)</span> context <span>=</span> args <span>=</span> <span>null</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>timeout <span>&amp;&amp;</span> options<span>.</span>trailing <span>!==</span> <span>false</span><span>)</span> <span>{</span>\n      <span>// 判断是否设置了定时器和 trailing</span>\n      <span>// 没有的话就开启一个定时器</span>\n      <span>// 并且不能不能同时设置 leading 和 trailing</span>\n      timeout <span>=</span> <span>setTimeout</span><span>(</span>later<span>,</span> remaining<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h3 id=\"_86-谈谈变量提升\"> 86 谈谈变量提升？</h3>\n<blockquote>\n<p>当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境</p>\n</blockquote>\n<ul>\n<li>接下来让我们看一个老生常谈的例子，<code>var</code></li>\n</ul>\n<div><pre><code><span>b</span><span>(</span><span>)</span> <span>// call b</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span> <span>// undefined</span>\n\n<span>var</span> a <span>=</span> <span>'Hello world'</span>\n\n<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'call b'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>变量提升</p>\n<p>这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p>\n</blockquote>\n<p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>\n<div><pre><code><span>b</span><span>(</span><span>)</span> <span>// call b second</span>\n\n<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'call b fist'</span><span>)</span>\n<span>}</span>\n<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'call b second'</span><span>)</span>\n<span>}</span>\n<span>var</span> b <span>=</span> <span>'Hello world'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>复制代码<code>var</code> 会产生很多错误，所以在 <code>ES6</code>中引入了 <code>let</code>。<code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p>\n</blockquote>\n<h3 id=\"_87-什么是单线程-和异步的关系\"> 87 什么是单线程，和异步的关系</h3>\n<ul>\n<li>单线程 - 只有一个线程，只能做一件事</li>\n<li>原因 - 避免DOM渲染的冲突\n<ul>\n<li>浏览器需要渲染 <code>DOM</code></li>\n<li><code>JS</code> 可以修改 <code>DOM</code> 结构</li>\n<li><code>JS</code> 执行的时候，浏览器 <code>DOM</code> 渲染会暂停</li>\n<li>两段 JS 也不能同时执行（都修改 <code>DOM</code> 就冲突了）</li>\n<li><code>webworker</code> 支持多线程，但是不能访问 <code>DOM</code></li>\n</ul>\n</li>\n<li>解决方案 - 异步</li>\n</ul>\n<h3 id=\"_88-是否用过-jquery-的-deferred\"> 88 是否用过 jQuery 的 Deferred</h3>\n<p><img src=\"/javaScriptBase/7.png\" alt=\"7\" /></p>\n<p><img src=\"/javaScriptBase/8.png\" alt=\"8\" /></p>\n<p><img src=\"/javaScriptBase/9.png\" alt=\"9\" /></p>\n<p><img src=\"/javaScriptBase/10.png\" alt=\"10\" /></p>\n<p><img src=\"/javaScriptBase/11.png\" alt=\"11\" /></p>\n<p><img src=\"/javaScriptBase/12.png\" alt=\"12\" /></p>\n<p><img src=\"/javaScriptBase/14.png\" alt=\"14\" /></p>\n<p><img src=\"/javaScriptBase/16.png\" alt=\"16\" /></p>\n<p><img src=\"/javaScriptBase/15.png\" alt=\"15\" /></p>\n<p><img src=\"/javaScriptBase/13.png\" alt=\"13\" /></p>\n<h3 id=\"_89-前端面试之hybrid\"> 89 前端面试之hybrid</h3>\n<blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-hybrid/\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.poetries.top/2018/10/20/fe-interview-hybrid/</a></p>\n</blockquote>\n<h3 id=\"_90-前端面试之组件化\"> 90 前端面试之组件化</h3>\n<blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-component/\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.poetries.top/2018/10/20/fe-interview-component/</a></p>\n</blockquote>\n<h3 id=\"_91-前端面试之mvvm浅析\"> 91 前端面试之MVVM浅析</h3>\n<blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-mvvm/\" target=\"_blank\" rel=\"noopener noreferrer\">http://blog.poetries.top/2018/10/20/fe-interview-mvvm/</a></p>\n</blockquote>\n<h3 id=\"_92-实现效果-点击容器内的图标-图标边框变成border-1px-solid-red-点击空白处重置\"> 92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置</h3>\n<div><pre><code><span>const</span> box <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'box'</span><span>)</span><span>;</span>\n<span>function</span> <span>isIcon</span><span>(</span><span>target</span><span>)</span> <span>{</span>\n  <span>return</span> target<span>.</span>className<span>.</span><span>includes</span><span>(</span><span>'icon'</span><span>)</span><span>;</span>\n<span>}</span>\n\nbox<span>.</span><span>onClick</span> <span>=</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  e<span>.</span><span>stopPropagation</span><span>(</span><span>)</span><span>;</span>\n  <span>const</span> target <span>=</span> e<span>.</span>target<span>;</span>\n  <span>if</span> <span>(</span><span>isIcon</span><span>(</span>target<span>)</span><span>)</span> <span>{</span>\n    target<span>.</span>style<span>.</span>border <span>=</span> <span>'1px solid red'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>const</span> doc <span>=</span> document<span>;</span>\ndoc<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  <span>const</span> children <span>=</span> box<span>.</span>children<span>;</span>\n  <span>for</span><span>(</span><span>let</span> i<span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>isIcon</span><span>(</span>children<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>\n      children<span>[</span>i<span>]</span><span>.</span>style<span>.</span>border <span>=</span> <span>'none'</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_93-请简单实现双向数据绑定mvvm\"> 93 请简单实现双向数据绑定<code>mvvm</code></h3>\n<div><pre><code><span>&lt;</span>input id<span>=</span><span>\"input\"</span><span>/</span><span>></span>\n<span>const</span> data <span>=</span> <span>{</span><span>}</span><span>;</span>\n<span>const</span> input <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'input'</span><span>)</span><span>;</span>\nObject<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span> <span>'text'</span><span>,</span> <span>{</span>\n  <span>set</span><span>(</span>value<span>)</span> <span>{</span>\n    input<span>.</span>value <span>=</span> value<span>;</span>\n    <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\ninput<span>.</span><span>onChange</span> <span>=</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>\n  data<span>.</span>text <span>=</span> e<span>.</span>target<span>.</span>value<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_94-实现storage-使得该对象为单例-并对localstorage进行封装设置值setitem-key-value-和getitem-key\"> 94 实现Storage，使得该对象为单例，并对<code>localStorage</code>进行封装设置值setItem(key,value)和getItem(key)</h3>\n<div><pre><code><span>var</span> instance <span>=</span> <span>null</span><span>;</span>\n<span>class</span> <span>Storage</span> <span>{</span>\n  <span>static</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>!</span>instance<span>)</span> <span>{</span>\n      instance <span>=</span> <span>new</span> <span>Storage</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> instance<span>;</span>\n  <span>}</span>\n  <span>setItem</span> <span>=</span> <span>(</span><span>key<span>,</span> value</span><span>)</span> <span>=></span> localStorage<span>.</span><span>setItem</span><span>(</span>key<span>,</span> value<span>)</span><span>,</span>\n  <span>getItem</span> <span>=</span> <span>key</span> <span>=></span> localStorage<span>.</span><span>getItem</span><span>(</span>key<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_95-说说event-loop\"> 95 说说<code>event loop</code></h3>\n<blockquote>\n<p>首先，<code>js</code>是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应<code>DOM</code>的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被<code>push</code>进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步<code>HTTP</code>请求线程满足特定条件下的回调函数<code>push</code>到事件队列中，等待<code>js</code>引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务<code>microtask（promise）</code>，如果有那就优先执行微任务，如果没有，在去查找宏任务<code>macrotask（setTimeout、setInterval）</code>进行执行\n众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p>\n</blockquote>\n<ul>\n<li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li>\n</ul>\n<p><img src=\"/javaScriptBase/16740fa4cd9c6937.png\" alt=\"img\" /></p>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'script start'</span><span>)</span><span>;</span>\n\n<span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'script end'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p>\n</blockquote>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'script start'</span><span>)</span><span>;</span>\n\n<span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span><span>;</span>\n<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n\n<span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'Promise'</span><span>)</span>\n  <span>resolve</span><span>(</span><span>)</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'promise1'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'promise2'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\nconsole<span>.</span><span>log</span><span>(</span><span>'script end'</span><span>)</span><span>;</span>\n<span>// script start => Promise => script end => promise1 => promise2 => setTimeout</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>\n<p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p>\n</blockquote>\n<p><strong>微任务：</strong></p>\n<ul>\n<li><code>process.nextTick</code></li>\n<li><code>promise</code></li>\n<li><code>Object.observe</code></li>\n<li><code>MutationObserver</code></li>\n</ul>\n<p><strong>宏任务：</strong></p>\n<ul>\n<li><code>script</code></li>\n<li><code>setTimeout</code></li>\n<li><code>setInterval</code></li>\n<li><code>setImmediate</code></li>\n<li><code>I/O</code></li>\n<li><code>UI rendering</code></li>\n</ul>\n<blockquote>\n<p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p>\n</blockquote>\n<p><strong>所以正确的一次 Event loop 顺序是这样的：</strong></p>\n<ul>\n<li>执行同步代码，这属于宏任务</li>\n<li>执行栈为空，查询是否有微任务需要执行</li>\n<li>执行所有微任务</li>\n<li>必要的话渲染 UI</li>\n<li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li>\n</ul>\n<blockquote>\n<p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p>\n</blockquote>\n<h3 id=\"_96-说说事件流\"> 96 说说事件流</h3>\n<p><strong>事件流分为两种，捕获事件流和冒泡事件流：</strong></p>\n<ul>\n<li>捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点</li>\n<li>冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点</li>\n</ul>\n<blockquote>\n<p>事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段</p>\n</blockquote>\n<h3 id=\"_97-javascript-对象生命周期的理解\"> 97 JavaScript 对象生命周期的理解</h3>\n<ul>\n<li>当创建一个对象时，<code>JavaScript</code> 会自动为该对象分配适当的内存</li>\n<li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li>\n<li>如果被引用数量为 <code>0</code>，或惟一引用是循环的，那么该对象的内存即可回收</li>\n</ul>\n<h3 id=\"_98-我现在有一个canvas-上面随机布着一些黑块-请实现方法-计算canvas上有多少个黑块\"> 98 我现在有一个<code>canvas</code>，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块</h3>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/f54d265f7aa4\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/f54d265f7aa4</a></p>\n</blockquote>\n<h3 id=\"_99-请手写实现一个promise\"> 99 请手写实现一个<code>promise</code></h3>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000013396601\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000013396601</a></p>\n</blockquote>\n<h3 id=\"_100-说说从输入url到看到页面发生的全过程-越详细越好\"> 100 说说从输入URL到看到页面发生的全过程，越详细越好</h3>\n<ul>\n<li>首先浏览器主进程接管，开了一个下载线程。</li>\n<li>然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</li>\n<li>将下载完的内容转交给Renderer进程管理。</li>\n<li>Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</li>\n<li>解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</li>\n<li>css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</li>\n<li>绘制结束后，关闭TCP连接，过程有四次挥手</li>\n</ul>\n<h3 id=\"_101-描述一下this\"> 101 描述一下<code>this</code></h3>\n<blockquote>\n<p><code>this</code>，函数执行的上下文，可以通过<code>apply</code>，<code>call</code>，<code>bind</code>改变<code>this</code>的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为<code>global</code>），剩下的函数调用，那就是谁调用它，<code>this</code>就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，<code>this</code>就指向哪里</p>\n</blockquote>\n<h3 id=\"_102-说一下浏览器的缓存机制\"> 102 说一下浏览器的缓存机制</h3>\n<blockquote>\n<p>浏览器缓存机制有两种，一种为强缓存，一种为协商缓存</p>\n</blockquote>\n<ul>\n<li>对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。</li>\n<li>对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存</li>\n</ul>\n<p><strong>协商缓存相关设置：</strong></p>\n<ul>\n<li><code>Exprires</code>：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。<code>Exprires</code>的缺陷是必须保证服务端时间和客户端时间严格同步。</li>\n<li><code>Cache-control：max-age</code>：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，</li>\n<li><code>If-None-Match/ETag</code>：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回<code>If-None-Match</code>标识是否表示匹配。</li>\n<li><code>Last-modified/If-Modified-Since</code>：第一次请求的时候服务端返回<code>Last-modified</code>表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头<code>If-Modified-Since</code>，表示资源上次的修改时间，服务端拿到这两个字段进行对比</li>\n</ul>\n<h3 id=\"_103-现在要你完成一个dialog组件-说说你设计的思路-它应该有什么功能\"> 103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？</h3>\n<ul>\n<li>该组件需要提供<code>hook</code>指定渲染位置，默认渲染在body下面。</li>\n<li>然后改组件可以指定外层样式，如宽度等</li>\n<li>组件外层还需要一层<code>mask</code>来遮住底层内容，点击<code>mask</code>可以执行传进来的<code>onCancel</code>函数关闭<code>Dialog</code>。</li>\n<li>另外组件是可控的，需要外层传入<code>visible</code>表示是否可见。</li>\n<li>然后<code>Dialog</code>可能需要自定义头head和底部<code>footer</code>，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的<code>onOk</code>事件，然后取消按钮会执行外部传进来的<code>onCancel</code>事件。</li>\n<li>当组件的<code>visible</code>为<code>true</code>时候，设置<code>body</code>的<code>overflow</code>为<code>hidden</code>，隐藏<code>body</code>的滚动条，反之显示滚动条。</li>\n<li>组件高度可能大于页面高度，组件内部需要滚动条。</li>\n<li>只有组件的<code>visible</code>有变化且为<code>ture</code>时候，才重渲染组件内的所有内容</li>\n</ul>\n<h3 id=\"_104-caller和callee的区别\"> 104 <code>caller</code>和<code>callee</code>的区别</h3>\n<p><strong>callee：</strong></p>\n<blockquote>\n<p><code>caller</code>返回一个函数的引用，这个函数调用了当前的函数。</p>\n</blockquote>\n<p><strong>使用这个属性要注意：</strong></p>\n<ul>\n<li>这个属性只有当函数在执行时才有用</li>\n<li>如果在<code>javascript</code>程序中，函数是由顶层调用的，则返回<code>null</code></li>\n</ul>\n<blockquote>\n<p><code>functionName.caller: functionName</code>是当前正在执行的函数。</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>a<span>.</span>caller<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>callee：</strong></p>\n<blockquote>\n<p><code>callee</code>放回正在执行的函数本身的引用，它是<code>arguments</code>的一个属性\n使用callee时要注意:</p>\n</blockquote>\n<ul>\n<li>这个属性只有在函数执行时才有效</li>\n<li>它有一个<code>length</code>属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较<code>arguments.length</code>是否等于<code>arguments.callee.length</code></li>\n<li>它可以用来递归匿名函数。</li>\n</ul>\n<div><pre><code><span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span>  \n  console<span>.</span><span>log</span><span>(</span>arguments<span>.</span>callee<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_105-ajax、axios、fetch区别\"> 105 ajax、axios、fetch区别</h3>\n<p><strong>jQuery ajax：</strong></p>\n<div><pre><code>$<span>.</span><span>ajax</span><span>(</span><span>{</span>\n  type<span>:</span> <span>'POST'</span><span>,</span>\n  url<span>:</span> url<span>,</span>\n  data<span>:</span> data<span>,</span>\n  dataType<span>:</span> dataType<span>,</span>\n  <span>success</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>\n  <span>error</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>优缺点：</p>\n<ul>\n<li>本身是针对<code>MVC</code>的编程,不符合现在前端<code>MVVM</code>的浪潮</li>\n<li>基于原生的<code>XHR</code>开发，<code>XHR</code>本身的架构不清晰，已经有了<code>fetch</code>的替代方案</li>\n<li><code>JQuery</code>整个项目太大，单纯使用<code>ajax</code>却要引入整个<code>JQuery</code>非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n</ul>\n<p><strong>axios：</strong></p>\n<div><pre><code><span>axios</span><span>(</span><span>{</span>\n  method<span>:</span> <span>'post'</span><span>,</span>\n  url<span>:</span> <span>'/user/12345'</span><span>,</span>\n  data<span>:</span> <span>{</span>\n    firstName<span>:</span> <span>'Fred'</span><span>,</span>\n    lastName<span>:</span> <span>'Flintstone'</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>response<span>)</span><span>;</span>\n<span>}</span><span>)</span>\n<span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>优缺点：</p>\n<ul>\n<li>从浏览器中创建 <code>XMLHttpRequest</code></li>\n<li>从 <code>node.js</code> 发出 <code>http</code> 请求</li>\n<li>支持 <code>Promise API</code></li>\n<li>拦截请求和响应</li>\n<li>转换请求和响应数据</li>\n<li>取消请求</li>\n<li>自动转换<code>JSON</code>数据</li>\n<li>客户端支持防止<code>CSRF/XSRF</code></li>\n</ul>\n<p><strong>fetch：</strong></p>\n<div><pre><code><span>try</span> <span>{</span>\n  <span>let</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>\n  <span>let</span> data <span>=</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>\n  console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>\n<span>}</span> <span>catch</span><span>(</span>e<span>)</span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>\"Oops, error\"</span><span>,</span> e<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>优缺点：</p>\n<ul>\n<li><code>fetcht</code>只对网络请求报错，对<code>400</code>，<code>500</code>都当做成功的请求，需要封装去处理</li>\n<li><code>fetch</code>默认不会带<code>cookie</code>，需要添加配置项</li>\n<li><code>fetch</code>不支持<code>abort</code>，不支持超时控制，使用<code>setTimeout</code>及<code>Promise.reject</code>的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li>\n<li><code>fetch</code>没有办法原生监测请求的进度，而XHR可以</li>\n</ul>\n<h3 id=\"_106-javascript的组成\"> 106 JavaScript的组成</h3>\n<p>JavaScript由以下三部分组成：</p>\n<ul>\n<li><code>ECMAScript（核心）：</code>JavaScript` 语言基础</li>\n<li><code>DOM</code>（文档对象模型）：规定了访问<code>HTML</code>和<code>XML</code>的接口</li>\n<li><code>BOM</code>（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li>\n</ul>\n<h3 id=\"_107-检测浏览器版本版本有哪些方式\"> 107 检测浏览器版本版本有哪些方式？</h3>\n<ul>\n<li>根据 <code>navigator.userAgent</code> <code>UA.toLowerCase().indexOf('chrome')</code></li>\n<li>根据 <code>window</code> 对象的成员 <code>'ActiveXObject' in window</code></li>\n</ul>\n<h3 id=\"_108-介绍js有哪些内置对象\"> 108 介绍JS有哪些内置对象</h3>\n<ul>\n<li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code></li>\n<li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>\n<li>ES6新增对象：<code>Symbol</code>、<code>Map</code>、<code>Set</code>、<code>Promises</code>、<code>Proxy</code>、<code>Reflect</code></li>\n</ul>\n<h3 id=\"_109-说几条写javascript的基本规范\"> 109 说几条写JavaScript的基本规范</h3>\n<ul>\n<li>代码缩进，建议使用“四个空格”缩进</li>\n<li>代码段使用花括号<code>{}</code>包裹</li>\n<li>语句结束使用分号;</li>\n<li>变量和函数在使用前进行声明</li>\n<li>以大写字母开头命名构造函数，全大写命名常量</li>\n<li>规范定义<code>JSON</code>对象，补全双引号</li>\n<li>用<code>{}</code>和<code>[]</code>声明对象和数组</li>\n</ul>\n<h3 id=\"_110-如何编写高性能的javascript\"> 110 如何编写高性能的JavaScript</h3>\n<ul>\n<li>遵循严格模式：<code>&quot;use strict&quot;;</code></li>\n<li>将js脚本放在页面底部，加快渲染页面</li>\n<li>将js脚本将脚本成组打包，减少请求</li>\n<li>使用非阻塞方式下载js脚本</li>\n<li>尽量使用局部变量来保存全局变量</li>\n<li>尽量减少使用闭包</li>\n<li>使用 <code>window</code> 对象属性方法时，省略 <code>window</code></li>\n<li>尽量减少对象成员嵌套</li>\n<li>缓存 <code>DOM</code> 节点的访问</li>\n<li>通过避免使用 <code>eval()</code> 和 <code>Function()</code> 构造器</li>\n<li>给 <code>setTimeout()</code> 和 <code>setInterval()</code> 传递函数而不是字符串作为参数</li>\n<li>尽量使用直接量创建对象和数组</li>\n<li>最小化重绘(<code>repaint</code>)和回流(<code>reflow</code>)</li>\n</ul>\n<h3 id=\"_111-描述浏览器的渲染过程-dom树和渲染树的区别\"> 111 描述浏览器的渲染过程，DOM树和渲染树的区别</h3>\n<ul>\n<li>浏览器的渲染过程：\n<ul>\n<li>解析<code>HTML</code>构建 <code>DOM</code>(DOM树)，并行请求 <code>css/image/js</code></li>\n<li><code>CSS</code> 文件下载完成，开始构建 <code>CSSOM</code>(<code>CSS</code>树)</li>\n<li><code>CSSOM</code> 构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li>\n<li>布局(<code>Layout</code>)：计算出每个节点在屏幕中的位置</li>\n<li>显示(<code>Painting</code>)：通过显卡把页面画到屏幕上</li>\n</ul>\n</li>\n<li><code>DOM</code>树 和 渲染树 的区别：\n<ul>\n<li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li>\n<li>渲染树不包括<code>head</code>和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的<code>css</code>属性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_112-script-的位置是否会影响首屏显示时间\"> 112 script 的位置是否会影响首屏显示时间</h3>\n<ul>\n<li>在解析 <code>HTML</code> 生成 <code>DOM</code> 过程中，<code>js</code> 文件的下载是并行的，不需要 <code>DOM</code> 处理到 <code>script</code> 节点。因此，<code>script</code>的位置不影响首屏显示的开始时间。</li>\n<li>浏览器解析 <code>HTML</code> 是自上而下的线性过程，<code>script</code>作为 <code>HTML</code> 的一部分同样遵循这个原则</li>\n<li>因此，<code>script</code> 会延迟 <code>DomContentLoad</code>，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li>\n</ul>\n<h3 id=\"_113-解释javascript中的作用域与变量声明提升\"> 113 解释JavaScript中的作用域与变量声明提升</h3>\n<ul>\n<li><code>JavaScript</code>作用域：\n<ul>\n<li>在<code>Java</code>、<code>C</code>等语言中，作用域为for语句、<code>if</code>语句或<code>{}</code>内的一块区域，称为作用域；</li>\n<li>而在 <code>JavaScript</code> 中，作用域为<code>function(){}</code>内的区域，称为函数作用域。</li>\n</ul>\n</li>\n<li><code>JavaScript</code>变量声明提升：\n<ul>\n<li>在<code>JavaScript</code>中，函数声明与变量声明经常被<code>JavaScript</code>引擎隐式地提升到当前作用域的顶部。</li>\n<li>声明语句中的赋值部分并不会被提升，只有名称被提升</li>\n<li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li>\n<li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_114-javascript有几种类型的值-你能画一下他们的内存图吗\"> 114 JavaScript有几种类型的值？，你能画一下他们的内存图吗</h3>\n<ul>\n<li>原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）-- 栈</li>\n<li>引用数据类型（对象、数组和函数）-- 堆</li>\n<li>两种类型的区别是：存储位置不同：</li>\n<li>原始数据类型是直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li>\n<li>引用数据类型存储在堆(<code>heap</code>)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li>\n<li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li>\n<li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>\n</ul>\n<h3 id=\"_115-javascript如何实现一个类-怎么实例化这个类\"> 115 JavaScript如何实现一个类，怎么实例化这个类</h3>\n<ul>\n<li>构造函数法（this+prototype） -- 用new关键字 生成实例对象\n<ul>\n<li>缺点：用到了 <code>this</code> 和 <code>prototype</code>，编写复杂，可读性差</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>function</span> <span>Mobile</span><span>(</span><span>name<span>,</span> price</span><span>)</span><span>{</span>\n  <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n  <span>this</span><span>.</span>price <span>=</span> price<span>;</span>\n<span>}</span>\n<span>Mobile</span><span>.</span>prototype<span>.</span><span>sell</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>alert</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>\"，售价 $\"</span> <span>+</span> <span>this</span><span>.</span>price<span>)</span><span>;</span>\n<span>}</span>\n<span>var</span> iPhone7 <span>=</span> <span>new</span> <span>Mobile</span><span>(</span><span>\"iPhone7\"</span><span>,</span> <span>1000</span><span>)</span><span>;</span>\niPhone7<span>.</span><span>sell</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li><code>Object.create</code> 法 -- 用 <code>Object.create()</code> 生成实例对象</li>\n<li>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</li>\n</ul>\n<div><pre><code><span>var</span> Person <span>=</span> <span>{</span>\n  firstname<span>:</span> <span>\"Mark\"</span><span>,</span>\n  lastname<span>:</span> <span>\"Yun\"</span><span>,</span>\n  age<span>:</span> <span>25</span><span>,</span>\n  <span>introduce</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>alert</span><span>(</span><span>'I am '</span> <span>+</span> Person<span>.</span>firstname <span>+</span> <span>' '</span> <span>+</span> Person<span>.</span>lastname<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>var</span> person <span>=</span> Object<span>.</span><span>create</span><span>(</span>Person<span>)</span><span>;</span>\nperson<span>.</span><span>introduce</span><span>(</span><span>)</span><span>;</span>\n\n<span>// Object.create 要求 IE9+，低版本浏览器可以自行部署：</span>\n<span>if</span> <span>(</span><span>!</span>Object<span>.</span>create<span>)</span> <span>{</span>\n  Object<span>.</span><span>create</span> <span>=</span> <span>function</span> <span>(</span><span>o</span><span>)</span> <span>{</span>\n    <span>function</span> <span>F</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n    <span>F</span><span>.</span>prototype <span>=</span> o<span>;</span>\n    <span>return</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ul>\n<li>极简主义法（消除this和prototype） -- 调用createNew()得到实例对象</li>\n<li>优点：容易理解，结构清晰优雅，符合传统的&quot;面向对象编程&quot;的构造</li>\n</ul>\n<div><pre><code><span>var</span> Cat <span>=</span> <span>{</span>\n  age<span>:</span> <span>3</span><span>,</span> <span>// 共享数据 -- 定义在类对象内，createNew() 外</span>\n  <span>createNew</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>var</span> cat <span>=</span> <span>{</span><span>}</span><span>;</span>\n    <span>// var cat = Animal.createNew(); // 继承 Animal 类</span>\n    cat<span>.</span>name <span>=</span> <span>\"小咪\"</span><span>;</span>\n    <span>var</span> sound <span>=</span> <span>\"喵喵喵\"</span><span>;</span> <span>// 私有属性--定义在 createNew() 内，输出对象外</span>\n    cat<span>.</span><span>makeSound</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n      <span>alert</span><span>(</span>sound<span>)</span><span>;</span>  <span>// 暴露私有属性</span>\n    <span>}</span><span>;</span>\n    cat<span>.</span><span>changeAge</span> <span>=</span> <span>function</span><span>(</span><span>num</span><span>)</span><span>{</span>\n      Cat<span>.</span>age <span>=</span> num<span>;</span> <span>// 修改共享数据</span>\n    <span>}</span><span>;</span>\n    <span>return</span> cat<span>;</span> <span>// 输出对象</span>\n  <span>}</span>\n<span>}</span><span>;</span>\n\n<span>var</span> cat <span>=</span> Cat<span>.</span><span>createNew</span><span>(</span><span>)</span><span>;</span>\ncat<span>.</span><span>makeSound</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>\n<p><code>ES6</code> 语法糖 <code>class</code> -- 用 <code>new</code> 关键字 生成实例对象</p>\n</blockquote>\n<div><pre><code><span>class</span> <span>Point</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>x <span>=</span> x<span>;</span>\n    <span>this</span><span>.</span>y <span>=</span> y<span>;</span>\n  <span>}</span>\n  <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>'('</span> <span>+</span> <span>this</span><span>.</span>x <span>+</span> <span>', '</span> <span>+</span> <span>this</span><span>.</span>y <span>+</span> <span>')'</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>var</span> point <span>=</span> <span>new</span> <span>Point</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_116-javascript如何实现继承\"> 116 Javascript如何实现继承</h3>\n<blockquote>\n<p>构造函数绑定：使用 <code>call</code> 或 <code>apply</code> 方法，将父对象的构造函数绑定在子对象上</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>Cat</span><span>(</span><span>name<span>,</span>color</span><span>)</span><span>{</span>\n 　<span>Animal</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span><span>;</span>\n 　<span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n 　<span>this</span><span>.</span>color <span>=</span> color<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>实例继承：将子对象的 prototype 指向父对象的一个实例</li>\n</ul>\n<div><pre><code><span>Cat</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>)</span><span>;</span>\n<span>Cat</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Cat<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>extend</span><span>(</span><span>Child<span>,</span> Parent</span><span>)</span> <span>{</span>\n  <span>var</span> p <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>\n  <span>var</span> c <span>=</span> <span>Child</span><span>.</span>prototype<span>;</span>\n  <span>for</span> <span>(</span><span>var</span> i <span>in</span> p<span>)</span> <span>{</span>\n    c<span>[</span>i<span>]</span> <span>=</span> p<span>[</span>i<span>]</span><span>;</span>\n  <span>}</span>\n  c<span>.</span>uber <span>=</span> p<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>原型继承：将子对象的 <code>prototype</code> 指向父对象的 <code>prototype</code></p>\n</blockquote>\n<div><pre><code><span>function</span> <span>extend</span><span>(</span><span>Child<span>,</span> Parent</span><span>)</span> <span>{</span>\n  <span>var</span> <span>F</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>\n　<span>F</span><span>.</span>prototype <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>\n　Child<span>.</span>prototype <span>=</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>\n　Child<span>.</span>prototype<span>.</span>constructor <span>=</span> Child<span>;</span>\n　Child<span>.</span>uber <span>=</span> <span>Parent</span><span>.</span>prototype<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>ES6<code>语法糖</code>extends：class ColorPoint extends Point {}</p>\n</blockquote>\n<div><pre><code><span>class</span> <span>ColorPoint</span> <span>extends</span> <span>Point</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>x<span>,</span> y<span>,</span> color</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span> <span>// 调用父类的constructor(x, y)</span>\n    <span>this</span><span>.</span>color <span>=</span> color<span>;</span>\n  <span>}</span>\n  <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span>color <span>+</span> <span>' '</span> <span>+</span> <span>super</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// 调用父类的toString()</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_117-javascript作用链域\"> 117 Javascript作用链域</h3>\n<ul>\n<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>\n<li>如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链</li>\n</ul>\n<h3 id=\"_118-介绍-dom-的发展\"> 118 介绍 DOM 的发展</h3>\n<ul>\n<li><code>DOM</code>：文档对象模型（<code>Document Object Model</code>），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li>\n<li><code>DOM0</code>：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：<code>document.forms['login']</code></li>\n<li><code>DOM1</code>：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：<code>JavaScript中的Document</code>对象</li>\n<li><code>DOM2</code>：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：<code>getComputedStyle(elem, pseudo)</code></li>\n<li><code>DOM3</code>：增加了XPath模块和加载与保存（<code>Load and Save</code>）模块。如：<code>XPathEvaluator</code></li>\n</ul>\n<h3 id=\"_119-介绍dom0-dom2-dom3事件处理方式区别\"> 119 介绍DOM0，DOM2，DOM3事件处理方式区别</h3>\n<ul>\n<li>DOM0级事件处理方式：\n<ul>\n<li><code>btn.onclick = func;</code></li>\n<li><code>btn.onclick = null;</code></li>\n</ul>\n</li>\n<li>DOM2级事件处理方式：\n<ul>\n<li><code>btn.addEventListener('click', func, false);</code></li>\n<li><code>btn.removeEventListener('click', func, false);</code></li>\n<li><code>btn.attachEvent(&quot;onclick&quot;, func);</code></li>\n<li><code>btn.detachEvent(&quot;onclick&quot;, func);</code></li>\n</ul>\n</li>\n<li>DOM3级事件处理方式：\n<ul>\n<li><code>eventUtil.addListener(input, &quot;textInput&quot;, func);</code></li>\n<li><code>eventUtil</code> 是自定义对象，<code>textInput</code> 是DOM3级事件</li>\n</ul>\n</li>\n</ul>\n<p><strong>事件的三个阶段：</strong></p>\n<ul>\n<li>捕获、目标、冒泡</li>\n</ul>\n<h3 id=\"_120-介绍事件-捕获-和-冒泡-执行顺序和事件的执行次数\"> 120 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数</h3>\n<ul>\n<li>按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li>\n<li>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数\n<ul>\n<li>注意1：前提是事件被确实触发</li>\n<li>注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”</li>\n</ul>\n</li>\n<li>事件执行顺序：判断的关键是否目标元素\n<ul>\n<li>非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序）</li>\n<li>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）</li>\n<li>最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡</li>\n<li>注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系</li>\n</ul>\n</li>\n</ul>\n<p><strong>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</strong></p>\n<ul>\n<li>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</li>\n<li>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</li>\n<li>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</li>\n</ul>\n<p><strong>事件的代理/委托：</strong></p>\n<ul>\n<li>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件\n<ul>\n<li>优点：\n<ul>\n<li>可以减少事件注册，节省大量内存占用</li>\n<li>可以将事件应用于动态添加的子元素上</li>\n</ul>\n</li>\n<li>缺点： 使用不当会造成事件在不应该触发时触发</li>\n<li>示例：</li>\n</ul>\n</li>\n</ul>\n<div><pre><code>ulEl<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span><span>{</span>\n  <span>var</span> target <span>=</span> event<span>.</span>target <span>||</span> event<span>.</span>srcElement<span>;</span>\n  <span>if</span><span>(</span><span>!</span><span>!</span>target <span>&amp;&amp;</span> target<span>.</span>nodeName<span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>===</span> <span>\"LI\"</span><span>)</span><span>{</span>\n    console<span>.</span><span>log</span><span>(</span>target<span>.</span>innerHTML<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>W3C事件的 target 与 currentTarget 的区别？</strong></p>\n<ul>\n<li><code>target</code> 只会出现在事件流的目标阶段</li>\n<li><code>currentTarget</code> 可能出现在事件流的任何阶段</li>\n<li>当事件流处在目标阶段时，二者的指向相同</li>\n<li>当事件流处于捕获或冒泡阶段时：<code>currentTarget</code> 指向当前事件活动的对象(一般为父级)</li>\n</ul>\n<p><strong>如何派发事件(dispatchEvent)？如何进行事件广播？</strong></p>\n<ul>\n<li>W3C: 使用 <code>dispatchEvent</code> 方法</li>\n<li>IE: 使用 <code>fireEvent</code> 方法</li>\n</ul>\n<div><pre><code><span>var</span> <span>fireEvent</span> <span>=</span> <span>function</span><span>(</span><span>element<span>,</span> event</span><span>)</span><span>{</span>\n  <span>if</span> <span>(</span>document<span>.</span>createEventObject<span>)</span><span>{</span>\n    <span>var</span> mockEvent <span>=</span> document<span>.</span><span>createEventObject</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> element<span>.</span><span>fireEvent</span><span>(</span><span>'on'</span> <span>+</span> event<span>,</span> mockEvent<span>)</span>\n  <span>}</span><span>else</span><span>{</span>\n    <span>var</span> mockEvent <span>=</span> document<span>.</span><span>createEvent</span><span>(</span><span>'HTMLEvents'</span><span>)</span><span>;</span>\n    mockEvent<span>.</span><span>initEvent</span><span>(</span>event<span>,</span> <span>true</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>return</span> <span>!</span>element<span>.</span><span>dispatchEvent</span><span>(</span>mockEvent<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_121-什么是函数节流-介绍一下应用场景和原理\"> 121 什么是函数节流？介绍一下应用场景和原理？</h3>\n<ul>\n<li>函数节流(<code>throttle</code>)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）</li>\n<li>函数节流用于 <code>onresize</code>, <code>onscroll</code> 等短时间内会多次触发的事件</li>\n<li>函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 <code>setTimout</code> 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 <code>clearTimeout</code> 原来的定时器， 再 <code>setTimeout</code> 一个新的定时器重复以上流程。</li>\n</ul>\n<p><strong>函数节流简单实现：</strong></p>\n<div><pre><code><span>function</span> <span>throttle</span><span>(</span><span>method<span>,</span> context</span><span>)</span> <span>{</span>\n  <span>clearTimeout</span><span>(</span>methor<span>.</span>tId<span>)</span><span>;</span>\n  method<span>.</span>tId <span>=</span> <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>\n    <span>method</span><span>.</span><span>call</span><span>(</span>context<span>)</span><span>;</span>\n  <span>}</span>， <span>100</span><span>)</span><span>;</span> <span>// 两次调用至少间隔 100ms</span>\n<span>}</span>\n<span>// 调用</span>\nwindow<span>.</span><span>onresize</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n  <span>throttle</span><span>(</span>myFunc<span>,</span> window<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_122-区分什么是-客户区坐标-、-页面坐标-、-屏幕坐标\"> 122 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”</h3>\n<ul>\n<li>客户区坐标：鼠标指针在可视区中的水平坐标(<code>clientX</code>)和垂直坐标(<code>clientY</code>)</li>\n<li>页面坐标：鼠标指针在页面布局中的水平坐标(<code>pageX</code>)和垂直坐标(<code>pageY</code>)</li>\n<li>屏幕坐标：设备物理屏幕的水平坐标(<code>screenX</code>)和垂直坐标(<code>screenY</code>)</li>\n</ul>\n<p><strong>如何获得一个DOM元素的绝对位置？</strong></p>\n<ul>\n<li><code>elem.offsetLef</code>t：返回元素相对于其定位父级左侧的距离</li>\n<li><code>elem.offsetTop</code>：返回元素相对于其定位父级顶部的距离</li>\n<li><code>elem.getBoundingClientRect()</code>：返回一个<code>DOMRect</code>对象，包含一组描述边框的只读属性，单位像素</li>\n</ul>\n<h3 id=\"_123-解释一下这段代码的意思\"> 123 解释一下这段代码的意思</h3>\n<div><pre><code><span>[</span><span>]</span><span>.</span><span>forEach</span><span>.</span><span>call</span><span>(</span><span>$$</span><span>(</span><span>\"*\"</span><span>)</span><span>,</span> <span>function</span><span>(</span><span>el</span><span>)</span><span>{</span>\n  el<span>.</span>style<span>.</span>outline <span>=</span> <span>\"1px solid #\"</span> <span>+</span> <span>(</span><span>~</span><span>~</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>*</span><span>(</span><span>1</span><span>&lt;&lt;</span><span>24</span><span>)</span><span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>16</span><span>)</span><span>;</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline)</li>\n<li><code>$$(sel)</code> // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)</li>\n<li><code>[].forEach.call(NodeLists)</code> // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表</li>\n<li><code>el.style.outline = &quot;1px solid #333&quot;</code> // 样式 outline 位于盒模型之外，不影响元素布局位置</li>\n<li><code>(1&lt;&lt;24)</code> // parseInt(&quot;ffffff&quot;, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216</li>\n<li><code>Math.random()*(1&lt;&lt;24)</code> // 表示一个位于 0 到 16777216 之间的随机浮点数</li>\n<li><code>Math.random()*(1&lt;&lt;24)</code> // 作用相当于 parseInt 取整</li>\n<li><code>(~~(Math.random()*(1&lt;&lt;24))).toString(16)</code> // 转换为一个十六进制-</li>\n</ul>\n<h3 id=\"_124-javascript垃圾回收方法\"> 124 Javascript垃圾回收方法</h3>\n<ul>\n<li>标记清除（mark and sweep）</li>\n</ul>\n<blockquote>\n<ul>\n<li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li>\n<li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li>\n</ul>\n</blockquote>\n<p><strong>引用计数(reference counting)：</strong></p>\n<blockquote>\n<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p>\n</blockquote>\n<h3 id=\"_125-请解释一下-javascript-的同源策略\"> 125 请解释一下 JavaScript 的同源策略</h3>\n<ul>\n<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>\n<li>指一段脚本只能读取来自同一来源的窗口和文档的属性</li>\n</ul>\n<p><strong>为什么要有同源限制？</strong></p>\n<ul>\n<li>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li>\n<li>缺点\n<ul>\n<li>现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_126-如何删除一个cookie\"> 126 如何删除一个cookie</h3>\n<ul>\n<li>将时间设为当前时间往前一点</li>\n</ul>\n<div><pre><code><span>var</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>\ndate<span>.</span><span>setDate</span><span>(</span>date<span>.</span><span>getDate</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span><span>//真正的删除</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p><code>setDate()</code>方法用于设置一个月的某一天</p>\n</blockquote>\n<ul>\n<li><code>expires</code>的设置</li>\n</ul>\n<div><pre><code>document<span>.</span>cookie <span>=</span> <span>'user='</span><span>+</span> <span>encodeURIComponent</span><span>(</span><span>'name'</span><span>)</span>  <span>+</span> <span>';expires = '</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>0</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_127-页面编码和被请求的资源编码如果不一致如何处理\"> 127 页面编码和被请求的资源编码如果不一致如何处理</h3>\n<ul>\n<li>后端响应头设置 <code>charset</code></li>\n<li>前端页面<code>&lt;meta&gt;</code>设置 <code>charset</code></li>\n</ul>\n<h3 id=\"_128-把-script-放在-body-之前和之后有什么区别-浏览器会如何解析它们\"> 128 把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</h3>\n<ul>\n<li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li>\n<li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li>\n<li>浏览器的容错机制会忽略<code>&lt;script&gt;</code>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li>\n</ul>\n<h3 id=\"_129-javascript-中-调用函数有哪几种方式\"> 129 JavaScript 中，调用函数有哪几种方式</h3>\n<ul>\n<li>方法调用模式 <code>Foo.foo(arg1, arg2);</code></li>\n<li>函数调用模式 <code>foo(arg1, arg2);</code></li>\n<li>构造器调用模式 <code>(new Foo())(arg1, arg2);</code></li>\n<li><code>call/applay</code>调用模式 <code>Foo.foo.call(that, arg1, arg2);</code></li>\n<li><code>bind</code>调用模式 <code>Foo.foo.bind(that)(arg1, arg2)();</code></li>\n</ul>\n<h3 id=\"_130-简单实现-function-bind-函数\"> 130 简单实现 Function.bind 函数</h3>\n<div><pre><code><span>if</span> <span>(</span><span>!</span><span>Function</span><span>.</span>prototype<span>.</span>bind<span>)</span> <span>{</span>\n  <span>Function</span><span>.</span>prototype<span>.</span><span>bind</span> <span>=</span> <span>function</span><span>(</span><span>that</span><span>)</span> <span>{</span>\n    <span>var</span> func <span>=</span> <span>this</span><span>,</span> args <span>=</span> arguments<span>;</span>\n    <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>func</span><span>.</span><span>apply</span><span>(</span>that<span>,</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>args<span>,</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n<span>// 只支持 bind 阶段的默认参数：</span>\n<span>func</span><span>.</span><span>bind</span><span>(</span>that<span>,</span> arg1<span>,</span> arg2<span>)</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 不支持以下调用阶段传入的参数：</span>\n<span>func</span><span>.</span><span>bind</span><span>(</span>that<span>)</span><span>(</span>arg1<span>,</span> arg2<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_131-列举一下javascript数组和对象有哪些原生方法\"> 131 列举一下JavaScript数组和对象有哪些原生方法？</h3>\n<p><strong>数组：</strong></p>\n<ul>\n<li><code>arr.concat(arr1, arr2, arrn);</code></li>\n<li><code>arr.join(&quot;,&quot;);</code></li>\n<li><code>arr.sort(func);</code></li>\n<li><code>arr.pop();</code></li>\n<li><code>arr.push(e1, e2, en);</code></li>\n<li><code>arr.shift();</code></li>\n<li><code>unshift(e1, e2, en);</code></li>\n<li><code>arr.reverse();</code></li>\n<li><code>arr.slice(start, end);</code></li>\n<li><code>arr.splice(index, count, e1, e2, en);</code></li>\n<li><code>arr.indexOf(el);</code></li>\n<li><code>arr.includes(el);</code> // ES6</li>\n</ul>\n<p><strong>对象：</strong></p>\n<ul>\n<li><code>object.hasOwnProperty(prop);</code></li>\n<li><code>object.propertyIsEnumerable(prop);</code></li>\n<li><code>object.valueOf();</code></li>\n<li><code>object.toString();</code></li>\n<li><code>object.toLocaleString();</code></li>\n<li><code>Class.prototype.isPropertyOf(object);</code></li>\n</ul>\n<h3 id=\"_132-array-splice-与-array-splice-的区别\"> 132 Array.splice() 与 Array.splice() 的区别？</h3>\n<p><strong><code>slice</code></strong></p>\n<blockquote>\n<p>“读取”数组指定的元素，不会对原数组进行修改</p>\n</blockquote>\n<ul>\n<li>语法：<code>arr.slice(start, end)</code></li>\n<li><code>start</code> 指定选取开始位置（含）</li>\n<li><code>end</code> 指定选取结束位置（不含）</li>\n</ul>\n<p><strong>splice：</strong></p>\n<ul>\n<li>“操作”数组指定的元素，会修改原数组，返回被删除的元素</li>\n<li>语法：<code>arr.splice(index, count, [insert Elements])</code></li>\n<li><code>index</code> 是操作的起始位置</li>\n<li><code>count = 0</code> 插入元素，<code>count &gt; 0</code> 删除元素</li>\n<li><code>[insert Elements]</code> 向数组新插入的元素</li>\n</ul>\n<h3 id=\"_133-mvvm\"> 133 MVVM</h3>\n<p><strong>MVVM 由以下三个内容组成：</strong></p>\n<ul>\n<li><code>View</code>：界面</li>\n<li><code>Model</code>：数据模型</li>\n<li><code>ViewModel</code>：作为桥梁负责沟通 <code>View</code> 和 <code>Model</code></li>\n</ul>\n<blockquote>\n<ul>\n<li>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合</li>\n<li>在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel</li>\n</ul>\n</blockquote>\n<ul>\n<li>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持</li>\n</ul>\n<p><strong>脏数据检测：</strong></p>\n<ul>\n<li>当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次</li>\n<li>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数</li>\n</ul>\n<p><strong>数据劫持：</strong></p>\n<ul>\n<li><code>Vue</code> 内部使用了 <code>Obeject.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code>的事件</li>\n</ul>\n<div><pre><code><span>var</span> data <span>=</span> <span>{</span> name<span>:</span> <span>'yck'</span> <span>}</span>\n<span>observe</span><span>(</span>data<span>)</span>\n<span>let</span> name <span>=</span> data<span>.</span>name <span>// -> get value</span>\ndata<span>.</span>name <span>=</span> <span>'yyy'</span> <span>// -> change value</span>\n\n<span>function</span> <span>observe</span><span>(</span><span>obj</span><span>)</span> <span>{</span>\n  <span>// 判断类型</span>\n  <span>if</span> <span>(</span><span>!</span>obj <span>||</span> <span>typeof</span> obj <span>!==</span> <span>'object'</span><span>)</span> <span>{</span>\n    <span>return</span>\n  <span>}</span>\n  Object<span>.</span><span>keys</span><span>(</span>data<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>\n    <span>defineReactive</span><span>(</span>data<span>,</span> key<span>,</span> data<span>[</span>key<span>]</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n\n<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>\n  <span>// 递归子属性</span>\n  <span>observe</span><span>(</span>val<span>)</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>\n    enumerable<span>:</span> <span>true</span><span>,</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span><span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'get value'</span><span>)</span>\n      <span>return</span> val\n    <span>}</span><span>,</span>\n    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'change value'</span><span>)</span>\n      val <span>=</span> newVal\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><blockquote>\n<p>以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>\n  {{name}}\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>在解析如上模板代码时，遇到 <code>{name}</code> 就会给属性 <code>name</code> 添加发布订阅</p>\n</blockquote>\n<div><pre><code><span>// 通过 Dep 解耦</span>\n<span>class</span> <span>Dep</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>subs <span>=</span> <span>[</span><span>]</span>\n  <span>}</span>\n  <span>addSub</span><span>(</span><span>sub</span><span>)</span> <span>{</span>\n    <span>// sub 是 Watcher 实例</span>\n    <span>this</span><span>.</span>subs<span>.</span><span>push</span><span>(</span>sub<span>)</span>\n  <span>}</span>\n  <span>notify</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>subs<span>.</span><span>forEach</span><span>(</span><span>sub</span> <span>=></span> <span>{</span>\n      sub<span>.</span><span>update</span><span>(</span><span>)</span>\n    <span>}</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n<span>// 全局属性，通过该属性配置 Watcher</span>\nDep<span>.</span>target <span>=</span> <span>null</span>\n\n<span>function</span> <span>update</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n  document<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span><span>.</span>innerText <span>=</span> value\n<span>}</span>\n\n<span>class</span> <span>Watcher</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>obj<span>,</span> key<span>,</span> cb</span><span>)</span> <span>{</span>\n    <span>// 将 Dep.target 指向自己</span>\n    <span>// 然后触发属性的 getter 添加监听</span>\n    <span>// 最后将 Dep.target 置空</span>\n    Dep<span>.</span>target <span>=</span> <span>this</span>\n    <span>this</span><span>.</span>cb <span>=</span> cb\n    <span>this</span><span>.</span>obj <span>=</span> obj\n    <span>this</span><span>.</span>key <span>=</span> key\n    <span>this</span><span>.</span>value <span>=</span> obj<span>[</span>key<span>]</span>\n    Dep<span>.</span>target <span>=</span> <span>null</span>\n  <span>}</span>\n  <span>update</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 获得新值</span>\n    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span>obj<span>[</span><span>this</span><span>.</span>key<span>]</span>\n    <span>// 调用 update 方法更新 Dom</span>\n    <span>this</span><span>.</span><span>cb</span><span>(</span><span>this</span><span>.</span>value<span>)</span>\n  <span>}</span>\n<span>}</span>\n<span>var</span> data <span>=</span> <span>{</span> name<span>:</span> <span>'yck'</span> <span>}</span>\n<span>observe</span><span>(</span>data<span>)</span>\n<span>// 模拟解析到 `{{name}}` 触发的操作</span>\n<span>new</span> <span>Watcher</span><span>(</span>data<span>,</span> <span>'name'</span><span>,</span> update<span>)</span>\n<span>// update Dom innerText</span>\ndata<span>.</span>name <span>=</span> <span>'yyy'</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><blockquote>\n<p>接下来,对 defineReactive 函数进行改造</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>\n  <span>// 递归子属性</span>\n  <span>observe</span><span>(</span>val<span>)</span>\n  <span>let</span> dp <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>\n    enumerable<span>:</span> <span>true</span><span>,</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    <span>get</span><span>:</span> <span>function</span> <span>reactiveGetter</span><span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'get value'</span><span>)</span>\n      <span>// 将 Watcher 添加到订阅</span>\n      <span>if</span> <span>(</span>Dep<span>.</span>target<span>)</span> <span>{</span>\n        dp<span>.</span><span>addSub</span><span>(</span>Dep<span>.</span>target<span>)</span>\n      <span>}</span>\n      <span>return</span> val\n    <span>}</span><span>,</span>\n    <span>set</span><span>:</span> <span>function</span> <span>reactiveSetter</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'change value'</span><span>)</span>\n      val <span>=</span> newVal\n      <span>// 执行 watcher 的 update 方法</span>\n      dp<span>.</span><span>notify</span><span>(</span><span>)</span>\n    <span>}</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>\n<p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加</p>\n</blockquote>\n<p><strong>Proxy 与 Obeject.defineProperty 对比：</strong></p>\n<ul>\n<li>\n<p>Obeject.defineProperty虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p>\n<ul>\n<li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li>\n<li>对于数组不能监听到数据的变化</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>虽然 <code>Vue</code> 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code> 的办法，并且也是有缺陷的</p>\n</blockquote>\n<h3 id=\"_134-web应用从服务器主动推送data到客户端有那些方式\"> 134 WEB应用从服务器主动推送Data到客户端有那些方式</h3>\n<ul>\n<li>\n<p><code>AJAX</code> 轮询</p>\n</li>\n<li>\n<p><code>html5</code> 服务器推送事件 <code>(new EventSource(SERVER_URL)).addEventListener(&quot;message&quot;, func);</code></p>\n</li>\n<li>\n<p>html5 Websocket</p>\n</li>\n<li>\n<p><code>(new WebSocket(SERVER_URL)).addEventListener(&quot;message&quot;, func);</code></p>\n</li>\n</ul>\n<h3 id=\"_135-继承\"> 135 继承</h3>\n<ul>\n<li><strong>原型链继承</strong>，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。</li>\n<li><strong>构造继承</strong>，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，构造继承可以向父类传递参数，可以实现多继承，通过<code>call</code>多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能</li>\n<li><strong>实例继承</strong>，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承</li>\n<li><strong>拷贝继承</strong>：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用<code>for in</code>访问到）</li>\n<li><strong>组合继承</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li>\n<li><strong>寄生组合继承</strong>：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li>\n</ul>\n<h3 id=\"_136-this指向\"> 136 this指向</h3>\n<p><strong>1. this 指向有哪几种：</strong></p>\n<ul>\n<li>默认绑定：全局环境中，<code>this</code>默认绑定到<code>window</code></li>\n<li>隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，<code>this</code>隐式绑定到该直接对象</li>\n<li>隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到<code>window</code>。显式绑定：通过<code>call()</code>、<code>apply()</code>、<code>bind()</code>方法把对象绑定到<code>this</code>上，叫做显式绑定new绑定：如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定\n<ul>\n<li>构造函数通常不使用<code>return</code>关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值</li>\n<li>如果构造函数使用<code>return</code>语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果</li>\n<li>如果构造函数显式地使用<code>return</code>语句返回一个对象，那么调用表达式的值就是这个对象</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. 改变函数内部 this 指针的指向函数（bind，apply，call的区别）：</strong></p>\n<ul>\n<li><code>apply</code>：调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.apply(A, arguments)</code>;即A对象应用B对象的方法</li>\n<li><code>call</code>：调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.call(A, args1,args2)</code>;即A对象调用B对象的方法</li>\n<li><code>bind</code>除了返回是函数以外，它的参数和<code>call</code>一样</li>\n</ul>\n<p><strong>3. 箭头函数：</strong></p>\n<ul>\n<li>箭头函数没有<code>this</code>，所以需要通过查找作用域链来确定<code>this</code>的值，这就意味着如果箭头函数被非箭头函数包含，<code>this</code>绑定的就是最近一层非箭头函数的<code>this</code>，</li>\n<li>箭头函数没有自己的<code>arguments</code>对象，但是可以访问外围函数的<code>arguments</code>对象</li>\n<li>不能通过<code>new</code>关键字调用，同样也没有<code>new.target</code>值和原型</li>\n</ul>\n<h3 id=\"_137-判断是否是数组\"> 137 判断是否是数组</h3>\n<ul>\n<li><code>Array.isArray(arr</code></li>\n<li><code>Object.prototype.toString.call(arr) === '[Object Array]'</code></li>\n<li><code>arr instanceof Array</code></li>\n<li><code>array.constructor === Array</code></li>\n</ul>\n<h3 id=\"_138-加载\"> 138 加载</h3>\n<p><strong>1. 异步加载js的方法：</strong></p>\n<ul>\n<li><code>defer</code>：只支持IE如果您的脚本不会改变文档的内容，可将 <code>defer</code> 属性加入到<code>&lt;script&gt;</code>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止</li>\n<li><code>async</code>：<code>HTML5</code> 属性，仅适用于外部脚本；并且如果在IE中，同时存在<code>defer</code>和<code>async</code>，那么<code>defer</code>的优先级比较高；脚本将在页面完成时执行</li>\n</ul>\n<p><strong>2. 图片的懒加载和预加载：</strong></p>\n<ul>\n<li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</li>\n<li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数</li>\n</ul>\n<blockquote>\n<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>\n</blockquote>\n<h3 id=\"_139-垃圾回收\"> 139 垃圾回收</h3>\n<blockquote>\n<p>找出那些不再继续使用的变 量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)， 周期性地执行这一操作。</p>\n</blockquote>\n<p><strong>标记清除：</strong></p>\n<blockquote>\n<p>先所有都加上标记，再把环境中引用到的变量去除标记。剩下的就是没用的了</p>\n</blockquote>\n<p><strong>引用计数：</strong></p>\n<blockquote>\n<p>跟踪记录每 个值被引用的次数。清除引用次数为0的变量 ⚠️会有循环引用问题 。循环引用如果大量存在就会导致内存泄露。</p>\n</blockquote>\n",
      "image": "https://github.com/letme350/javaScriptBase/7.png",
      "date_published": "2021-07-27T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.086Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "JavaScript"
      ]
    },
    {
      "title": "React",
      "url": "https://github.com/letme350/react/react/",
      "id": "https://github.com/letme350/react/react/",
      "content_html": "<h1 id=\"react\"> React</h1>\n<h2 id=\"react面试\"> React面试</h2>\n<h3 id=\"_1、react-中-keys-的作用是什么\"> 1、React 中 keys 的作用是什么？</h3>\n<blockquote>\n<p><code>Keys</code>是 <code>React</code> 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p>\n</blockquote>\n<ul>\n<li>在开发过程中，我们需要保证某个元素的 <code>key</code> 在其同级元素中具有唯一性。在 <code>React Diff</code> 算法中<code>React</code> 会借助元素的 <code>Key</code> 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 <code>Key</code> 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 <code>Key</code> 的重要性</li>\n</ul>\n<h3 id=\"_2、传入-setstate-函数的第二个参数的作用是什么\"> 2、传入 setState 函数的第二个参数的作用是什么？</h3>\n<blockquote>\n<p>该函数会在 <code>setState</code> 函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：</p>\n</blockquote>\n<div><pre><code><span>this</span><span>.</span><span>setState</span><span>(</span>\n  <span>{</span> username<span>:</span> <span>'tylermcginnis33'</span> <span>}</span><span>,</span>\n  <span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'setState has finished and the component has re-rendered.'</span><span>)</span>\n<span>)</span>\n<span>this</span><span>.</span><span>setState</span><span>(</span><span>(</span><span>prevState<span>,</span> props</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>{</span>\n    streak<span>:</span> prevState<span>.</span>streak <span>+</span> props<span>.</span>count\n  <span>}</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3、react-中-refs-的作用是什么\"> 3、React 中 refs 的作用是什么</h3>\n<ul>\n<li><code>Refs</code> 是 <code>React</code> 提供给我们的安全访问 <code>DOM</code>元素或者某个组件实例的句柄</li>\n<li>可以为元素添加<code>ref</code>属性然后在回调函数中接受该元素在 <code>DOM</code> 树中的句柄，该值会作为回调函数的第一个参数返回</li>\n</ul>\n<h3 id=\"_4、在生命周期中的哪一步你应该发起-ajax-请求\"> 4、在生命周期中的哪一步你应该发起 AJAX 请求</h3>\n<blockquote>\n<p>我们应当将AJAX 请求放到 <code>componentDidMount</code> 函数中执行，主要原因有下</p>\n</blockquote>\n<ul>\n<li><code>React</code> 下一代调和算法 <code>Fiber</code> 会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount</code> 的触发次数。对于 <code>componentWillMount</code> 这个生命周期函数的调用次数会变得不确定，<code>React</code> 可能会多次频繁调用 <code>componentWillMount</code>。如果我们将 <code>AJAX</code> 请求放到 <code>componentWillMount</code> 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</li>\n<li>如果我们将<code>AJAX</code> 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了<code>setState</code>函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 <code>componentDidMount</code> 函数中进行 <code>AJAX</code> 请求则能有效避免这个问题</li>\n</ul>\n<h3 id=\"_5、shouldcomponentupdate-的作用\"> 5、shouldComponentUpdate 的作用</h3>\n<blockquote>\n<p><code>shouldComponentUpdate</code> 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新</p>\n</blockquote>\n<h3 id=\"_6、如何告诉-react-它应该编译生产环境版\"> 6、如何告诉 React 它应该编译生产环境版</h3>\n<blockquote>\n<p>通常情况下我们会使用 <code>Webpack</code> 的 <code>DefinePlugin</code> 方法来将 <code>NODE_ENV</code> 变量值设置为 <code>production</code>。编译版本中 <code>React</code>会忽略 <code>propType</code> 验证以及其他的告警信息，同时还会降低代码库的大小，<code>React</code> 使用了 <code>Uglify</code> 插件来移除生产环境下不必要的注释等信息</p>\n</blockquote>\n<h3 id=\"_7、概述下-react-中的事件处理逻辑\"> 7、概述下 React 中的事件处理逻辑</h3>\n<blockquote>\n<p>为了解决跨浏览器兼容性问题，<code>React</code> 会将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的</p>\n</blockquote>\n<h3 id=\"_8、createelement-与-cloneelement-的区别是什么\"> 8、createElement 与 cloneElement 的区别是什么</h3>\n<blockquote>\n<p>createElement<code>函数是 JSX 编译之后使用的创建</code>React Element<code>的函数，而</code>cloneElement<code>则是用于复制某个元素并传入新的</code>Props</p>\n</blockquote>\n<h3 id=\"_9、redux中间件\"> 9、redux中间件</h3>\n<blockquote>\n<p>中间件提供第三方插件的模式，自定义拦截 <code>action</code> -&gt; <code>reducer</code> 的过程。变为 <code>action</code> -&gt; <code>middlewares</code> -&gt; <code>reducer</code>。这种机制可以让我们改变数据流，实现如异步<code>action</code> ，<code>action</code> 过滤，日志输出，异常报告等功能</p>\n</blockquote>\n<ul>\n<li><code>redux-logger</code>：提供日志输出</li>\n<li><code>redux-thunk</code>：处理异步操作</li>\n<li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li>\n</ul>\n<h3 id=\"_10、redux有什么缺点\"> 10、redux有什么缺点</h3>\n<ul>\n<li>一个组件所需要的数据，必须由父组件传过来，而不能像<code>flux</code>中直接从<code>store</code>取。</li>\n<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新<code>render</code>，可能会有效率影响，或者需要写复杂的<code>shouldComponentUpdate</code>进行判断。</li>\n</ul>\n<h3 id=\"_11、react组件的划分业务组件技术组件\"> 11、react组件的划分业务组件技术组件？</h3>\n<ul>\n<li>根据组件的职责通常把组件分为UI组件和容器组件。</li>\n<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>\n<li>两者通过<code>React-Redux</code> 提供<code>connect</code>方法联系起来</li>\n</ul>\n<h3 id=\"_12、react旧版生命周期函数\"> 12、react旧版生命周期函数</h3>\n<p><strong>初始化阶段：</strong></p>\n<ul>\n<li><code>getDefaultProps</code>:获取实例的默认属性</li>\n<li><code>getInitialState</code>:获取每个实例的初始化状态</li>\n<li><code>componentWillMount</code>：组件即将被装载、渲染到页面上</li>\n<li><code>render</code>:组件在这里生成虚拟的<code>DOM</code>节点</li>\n<li><code>componentDidMount</code>:组件真正在被装载之后</li>\n</ul>\n<p><strong>运行中状态：</strong></p>\n<ul>\n<li><code>componentWillReceiveProps</code>:组件将要接收到属性的时候调用</li>\n<li><code>shouldComponentUpdate</code>:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止<code>render</code>调用，后面的函数不会被继续执行了）</li>\n<li><code>componentWillUpdate</code>:组件即将更新不能修改属性和状态</li>\n<li><code>render</code>:组件重新描绘</li>\n<li><code>componentDidUpdate</code>:组件已经更新</li>\n</ul>\n<p><strong>销毁阶段：</strong></p>\n<ul>\n<li><code>componentWillUnmount</code>:组件即将销毁</li>\n</ul>\n<h4 id=\"_12-新版生命周期\"> 12 新版生命周期</h4>\n<blockquote>\n<p>在新版本中，React 官方对生命周期有了新的 变动建议:</p>\n</blockquote>\n<ul>\n<li>使用<code>getDerivedStateFromProps</code>替换<code>componentWillMount；</code></li>\n<li>使用<code>getSnapshotBeforeUpdate</code>替换<code>componentWillUpdate；</code></li>\n<li>避免使用<code>componentWillReceiveProps</code>；</li>\n</ul>\n<blockquote>\n<p>其实该变动的原因，正是由于上述提到的 <code>Fiber</code>。首先，从上面我们知道 React 可以分成 <code>reconciliation</code> 与 <code>commit</code>两个阶段，对应的生命周期如下:</p>\n</blockquote>\n<p><strong>reconciliation：</strong></p>\n<ul>\n<li><code>componentWillMount</code></li>\n<li><code>componentWillReceiveProps</code></li>\n<li><code>shouldComponentUpdate</code></li>\n<li><code>componentWillUpdate</code></li>\n</ul>\n<p><strong>commit：</strong></p>\n<ul>\n<li><code>componentDidMount</code></li>\n<li><code>componentDidUpdate</code></li>\n<li><code>componentWillUnmount</code></li>\n</ul>\n<blockquote>\n<p>在 <code>Fiber</code> 中，<code>reconciliation</code> 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 <code>reconciliation</code> 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误</p>\n</blockquote>\n<p>新版的建议生命周期如下:</p>\n<div><pre><code><span>class</span> <span>Component</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>// 替换 `componentWillReceiveProps` ，</span>\n  <span>// 初始化和 update 时被调用</span>\n  <span>// 静态函数，无法使用 this</span>\n  <span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> prevState</span><span>)</span> <span>{</span><span>}</span>\n  \n  <span>// 判断是否需要更新组件</span>\n  <span>// 可以用于组件性能优化</span>\n  <span>shouldComponentUpdate</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span><span>}</span>\n  \n  <span>// 组件被挂载后触发</span>\n  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  \n  <span>// 替换 componentWillUpdate</span>\n  <span>// 可以在更新之前获取最新 dom 数据</span>\n  <span>getSnapshotBeforeUpdate</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  \n  <span>// 组件更新后调用</span>\n  <span>componentDidUpdate</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  \n  <span>// 组件即将销毁</span>\n  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  \n  <span>// 组件已销毁</span>\n  <span>componentDidUnMount</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>使用建议:</strong></p>\n<ul>\n<li>在<code>constructor</code>初始化 <code>state</code>；</li>\n<li>在<code>componentDidMount</code>中进行事件监听，并在<code>componentWillUnmount</code>中解绑事件；</li>\n<li>在<code>componentDidMount</code>中进行数据的请求，而不是在<code>componentWillMount</code>；</li>\n<li>需要根据<code>props</code>更新<code>state</code>时，使用<code>getDerivedStateFromProps(nextProps, prevState)</code>；\n<ul>\n<li>旧 props 需要自己存储，以便比较；</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>public</span> <span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> prevState</span><span>)</span> <span>{</span>\n  <span>// 当新 props 中的 data 发生变化时，同步更新到 state 上</span>\n  <span>if</span> <span>(</span>nextProps<span>.</span>data <span>!==</span> prevState<span>.</span>data<span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      data<span>:</span> nextProps<span>.</span>data\n    <span>}</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>return</span> null1\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<p>可以在componentDidUpdate监听 props 或者 state 的变化，例如:</p>\n</blockquote>\n<div><pre><code><span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>)</span> <span>{</span>\n  <span>// 当 id 发生变化时，重新获取数据</span>\n  <span>if</span> <span>(</span><span>this</span><span>.</span>props<span>.</span>id <span>!==</span> prevProps<span>.</span>id<span>)</span> <span>{</span>\n    <span>this</span><span>.</span><span>fetchData</span><span>(</span><span>this</span><span>.</span>props<span>.</span>id<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>在componentDidUpdate使用setState时，必须加条件，否则将进入死循环；</li>\n<li>getSnapshotBeforeUpdate(prevProps, prevState)可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；</li>\n<li>shouldComponentUpdate: 默认每次调用setState，一定会最终走到 diff 阶段，但可以通过shouldComponentUpdate的生命钩子返回false来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。</li>\n</ul>\n<h3 id=\"_13、react性能优化是哪个周期函数\"> 13、react性能优化是哪个周期函数</h3>\n<blockquote>\n<p><code>shouldComponentUpdate</code> 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在<code>shouldComponentUpdate方</code>法中能够写出更优化的<code>dom diff</code>算法，可以极大的提高性能</p>\n</blockquote>\n<h3 id=\"_14、为什么虚拟dom会提高性能\"> 14、为什么虚拟dom会提高性能</h3>\n<blockquote>\n<p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p>\n</blockquote>\n<p><strong>具体实现步骤如下：</strong></p>\n<ul>\n<li>用 <code>JavaScript</code> 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 <code>DOM</code> 树，插到文档当中</li>\n<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>\n<li>把2所记录的差异应用到步骤1所构建的真正的<code>DOM</code>树上，视图就更新</li>\n</ul>\n<h3 id=\"_15、diff算法\"> 15、diff算法?</h3>\n<ul>\n<li>把树形结构按照层级分解，只比较同级元素。</li>\n<li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li>\n<li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li>\n<li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li>\n<li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li>\n</ul>\n<h3 id=\"_16、react性能优化方案\"> 16、react性能优化方案</h3>\n<ul>\n<li>重写<code>shouldComponentUpdate</code>来避免不必要的dom操作</li>\n<li>使用 <code>production</code> 版本的<code>react.js</code></li>\n<li>使用<code>key</code>来帮助<code>React</code>识别列表中所有组件的最小变化</li>\n</ul>\n<h3 id=\"_16、简述flux-思想\"> 16、简述flux 思想</h3>\n<blockquote>\n<p><code>Flux</code> 的最大特点，就是数据的&quot;单向流动&quot;。</p>\n</blockquote>\n<ul>\n<li>用户访问 <code>View</code></li>\n<li><code>View</code>发出用户的 <code>Action</code></li>\n<li><code>Dispatcher</code> 收到<code>Action</code>，要求 <code>Store</code> 进行相应的更新</li>\n<li><code>Store</code> 更新后，发出一个<code>&quot;change&quot;</code>事件</li>\n<li><code>View</code> 收到<code>&quot;change&quot;</code>事件后，更新页面</li>\n</ul>\n<h3 id=\"_17、说说你用react有什么坑点\"> 17、说说你用react有什么坑点？</h3>\n<p><strong>1. JSX做表达式判断时候，需要强转为boolean类型：</strong></p>\n<blockquote>\n<p>如果不使用 <code>!!b</code> 进行强转数据类型，会在页面里面输出 <code>0</code>。</p>\n</blockquote>\n<div><pre><code><span>render</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> b <span>=</span> <span>0</span><span>;</span>\n  <span>return</span> <span><span><span>&lt;</span>div</span><span>></span></span><span>\n    </span><span>{</span>\n      <span>!</span><span>!</span>b <span>&amp;&amp;</span> <span><span><span>&lt;</span>div</span><span>></span></span><span>这是一段文本</span><span><span><span>&lt;/</span>div</span><span>></span></span>\n    <span>}</span><span>\n  </span><span><span><span>&lt;/</span>div</span><span>></span></span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2. 尽量不要在 <code>componentWillReviceProps</code> 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃</strong></p>\n<p><strong>3. 给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次ref这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null！</strong></p>\n<p><strong>4. 遍历子节点的时候，不要用 index 作为组件的 key 进行传入。</strong></p>\n<h3 id=\"_18、我现在有一个button-要用react在上面绑定点击事件-要怎么做\"> 18、我现在有一个button，要用react在上面绑定点击事件，要怎么做？</h3>\n<div><pre><code><span>class</span> <span>Demo</span> <span>{</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>\n      <span>alert</span><span>(</span><span>'我点击了按钮'</span><span>)</span>\n    <span>}</span><span>}</span></span><span>></span></span><span>\n      按钮\n    </span><span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>你觉得你这样设置点击事件会有什么问题吗？</strong></p>\n<blockquote>\n<p>由于<code>onClick</code>使用的是匿名函数，所有每次重渲染的时候，会把该<code>onClick</code>当做一个新的<code>prop</code>来处理，会将内部缓存的<code>onClick</code>事件进行重新赋值，所以相对直接使用函数来说，可能有一点的性能下降</p>\n</blockquote>\n<p>修改</p>\n<div><pre><code><span>class</span> <span>Demo</span> <span>{</span>\n\n  <span>onClick</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=></span> <span>{</span>\n    <span>alert</span><span>(</span><span>'我点击了按钮'</span><span>)</span>\n  <span>}</span>\n\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>onClick<span>}</span><span>></span>\n      按钮\n    <span>&lt;</span><span>/</span>button<span>></span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_19、react-的虚拟dom是怎么实现的\"> 19、react 的虚拟dom是怎么实现的</h3>\n<blockquote>\n<p>首先说说为什么要使用<code>Virturl DOM</code>，因为操作真实<code>DOM</code>的耗费的性能代价太高，所以<code>react</code>内部使用<code>js</code>实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟<code>DOM</code>，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行<code>diff</code>的时候，<code>react</code>会先比较该节点类型，假如节点类型不一样，那么<code>react</code>会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较<code>prop</code>是否有更新，假如有<code>prop</code>不一样，那么<code>react</code>会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点</p>\n</blockquote>\n<h3 id=\"_20、react-的渲染过程中-兄弟节点之间是怎么处理的-也就是key值不一样的时候\"> 20、react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候</h3>\n<blockquote>\n<p>通常我们输出节点的时候都是map一个数组然后返回一个<code>ReactNode</code>，为了方便<code>react</code>内部进行优化，我们必须给每一个<code>reactNode</code>添加<code>key</code>，这个<code>key prop</code>在设计值处不是给开发者用的，而是给react用的，大概的作用就是给每一个<code>reactNode</code>添加一个身份标识，方便react进行识别，在重渲染过程中，如果key一样，若组件属性有所变化，则<code>react</code>只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件</p>\n</blockquote>\n<h3 id=\"_21、介绍一下react\"> 21、介绍一下react</h3>\n<ol>\n<li>以前我们没有jquery的时候，我们大概的流程是从后端通过ajax获取到数据然后使用jquery生成dom结果然后更新到页面当中，但是随着业务发展，我们的项目可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们又需要重新组装一次dom结构，然后更新页面，这样我们手动同步dom和数据的成本就越来越高，而且频繁的操作dom，也使我我们页面的性能慢慢的降低。</li>\n<li>这个时候mvvm出现了，mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以大大降低我们手动去维护dom更新的成本，mvvm为react的特性之一，虽然react属于单项数据流，需要我们手动实现双向数据绑定。</li>\n<li>有了mvvm还不够，因为如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了页面性能)的问题，为了解决这个问题，react内部实现了一套虚拟dom结构，也就是用js实现的一套dom结构，他的作用是讲真实dom在js中做一套缓存，每次有数据更改的时候，react内部先使用算法，也就是鼎鼎有名的diff算法对dom结构进行对比，找到那些我们需要新增、更新、删除的dom节点，然后一次性对真实DOM进行更新，这样就大大降低了操作dom的次数。 那么diff算法是怎么运作的呢，首先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且用新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对比这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。</li>\n<li>react设计之初是主要负责UI层的渲染，虽然每个组件有自己的state，state表示组件的状态，当状态需要变化的时候，需要使用setState更新我们的组件，但是，我们想通过一个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到父组件当中，让父组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要一直往下传，无疑加大了我们代码的复杂度，我们需要一个状态管理中心，来帮我们管理我们状态state。</li>\n<li>这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某一个state有变化的时候，依赖到这个state的组件就会进行一次重渲染，这样就解决了我们的我们需要一直把state往下传的问题。redux有action、reducer的概念，action为唯一修改state的来源，reducer为唯一确定state如何变化的入口，这使得redux的数据流非常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。</li>\n<li>后来，社区就出现了另外一套解决方案，也就是mobx，它推崇代码简约易懂，只需要定义一个可观测的对象，然后哪个组价使用到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，而且mobx内部也做好了是否重渲染组件的生命周期shouldUpdateComponent，不建议开发者进行更改，这使得我们使用mobx开发项目的时候可以简单快速的完成很多功能，连redux的作者也推荐使用mobx进行项目开发。但是，随着项目的不断变大，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以针对于小项目来说，社区推荐使用mobx，对大项目推荐使用redux</li>\n</ol>\n<h3 id=\"_22、react怎么做数据的检查和变化\"> 22、React怎么做数据的检查和变化</h3>\n<blockquote>\n<p>Model<code>改变之后（可能是调用了</code>setState<code>），触发了</code>virtual dom<code>的更新，再用</code>diff<code>算法来</code>把virtual DOM<code>比较</code>real DOM<code>，看看是哪个</code>dom<code>节点更新了，再渲染</code>real dom</p>\n</blockquote>\n<h3 id=\"_23、react-router里的-link-标签和-a-标签有什么区别\"> 23、react-router里的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别</h3>\n<blockquote>\n<p>对比<code>&lt;a&gt;</code>,<code>Link</code>组件避免了不必要的重渲染</p>\n</blockquote>\n<h3 id=\"_24、connect原理\"> 24、connect原理</h3>\n<ul>\n<li>首先<code>connect</code>之所以会成功，是因为<code>Provider</code>组件：</li>\n<li>在原应用组件上包裹一层，使原来整个应用成为<code>Provider</code>的子组件 接收<code>Redux</code>的<code>store</code>作为<code>props</code>，通过<code>context</code>对象传递给子孙组件上的<code>connect</code></li>\n</ul>\n<blockquote>\n<p><code>connect</code>做了些什么。它真正连接 <code>Redux</code> 和 <code>React</code>，它包在我们的容器组件的外一层，它接收上面 <code>Provider</code> 提供的 <code>store</code> 里面的<code>state</code> 和 <code>dispatch</code>，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件</p>\n</blockquote>\n<ul>\n<li><code>connect</code>是一个高阶函数，首先传入<code>mapStateToProps</code>、<code>mapDispatchToProps</code>，然后返回一个生产<code>Component</code>的函数(<code>wrapWithConnect</code>)，然后再将真正的<code>Component</code>作为参数传入<code>wrapWithConnect</code>，这样就生产出一个经过包裹的<code>Connect</code>组件，</li>\n</ul>\n<p><strong>该组件具有如下特点：</strong></p>\n<ul>\n<li>通过<code>props.store</code>获取祖先<code>Component</code>的<code>store props</code>包括<code>stateProps</code>、<code>dispatchProps</code>、<code>parentProps</code>,合并在一起得到<code>nextState</code>，作为<code>props</code>传给真正的<code>Component componentDidMount</code>时，添加事件<code>this.store.subscribe(this.handleChange)</code>，实现页面交互</li>\n<li><code>shouldComponentUpdate</code>时判断是否有避免进行渲染，提升页面性能，并得到<code>nextState</code> <code>componentWillUnmount</code>时移除注册的事件<code>this.handleChange</code></li>\n</ul>\n<blockquote>\n<p>由于<code>connect</code>的源码过长，我们只看主要逻辑</p>\n</blockquote>\n<div><pre><code><span>export</span> <span>default</span> <span>function</span> <span>connect</span><span>(</span><span>mapStateToProps<span>,</span> mapDispatchToProps<span>,</span> mergeProps<span>,</span> options <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>\n  <span>return</span> <span>function</span> <span>wrapWithConnect</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span>\n    <span>class</span> <span>Connect</span> <span>extends</span> <span>Component</span> <span>{</span>\n      <span>constructor</span><span>(</span><span>props<span>,</span> context</span><span>)</span> <span>{</span>\n        <span>// 从祖先Component处获得store</span>\n        <span>this</span><span>.</span>store <span>=</span> props<span>.</span>store <span>||</span> context<span>.</span>store\n        <span>this</span><span>.</span>stateProps <span>=</span> <span>computeStateProps</span><span>(</span><span>this</span><span>.</span>store<span>,</span> props<span>)</span>\n        <span>this</span><span>.</span>dispatchProps <span>=</span> <span>computeDispatchProps</span><span>(</span><span>this</span><span>.</span>store<span>,</span> props<span>)</span>\n        <span>this</span><span>.</span>state <span>=</span> <span>{</span> storeState<span>:</span> <span>null</span> <span>}</span>\n        <span>// 对stateProps、dispatchProps、parentProps进行合并</span>\n        <span>this</span><span>.</span><span>updateState</span><span>(</span><span>)</span>\n      <span>}</span>\n      <span>shouldComponentUpdate</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>\n        <span>// 进行判断，当数据发生改变时，Component重新渲染</span>\n        <span>if</span> <span>(</span>propsChanged <span>||</span> mapStateProducedChange <span>||</span> dispatchPropsChanged<span>)</span> <span>{</span>\n          <span>this</span><span>.</span><span>updateState</span><span>(</span>nextProps<span>)</span>\n          <span>return</span> <span>true</span>\n        <span>}</span>\n      <span>}</span>\n      <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 改变Component的state</span>\n        <span>this</span><span>.</span>store<span>.</span><span>subscribe</span><span>(</span><span>(</span><span>)</span> <span>=</span> <span>{</span>\n          <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>\n            storeState<span>:</span> <span>this</span><span>.</span>store<span>.</span><span>getState</span><span>(</span><span>)</span>\n          <span>}</span><span>)</span>\n        <span>}</span><span>)</span>\n      <span>}</span>\n      <span>render</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 生成包裹组件Connect</span>\n        <span>return</span> <span>(</span>\n          <span>&lt;</span>WrappedComponent <span>{</span><span>...</span><span>this</span><span>.</span>nextState<span>}</span> <span>/</span><span>></span>\n        <span>)</span>\n      <span>}</span>\n    <span>}</span>\n    Connect<span>.</span>contextTypes <span>=</span> <span>{</span>\n      store<span>:</span> storeShape\n    <span>}</span>\n    <span>return</span> Connect<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id=\"_25、redux实现原理解析\"> 25、Redux实现原理解析</h3>\n<p><strong>为什么要用redux？</strong></p>\n<blockquote>\n<p>在<code>React</code>中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过<code>props</code>）,所以，两个非父子组件之间通信就相对麻烦，<code>redux</code>的出现就是为了解决<code>state</code>里面的数据问题</p>\n</blockquote>\n<p><strong>Redux设计理念：</strong></p>\n<blockquote>\n<p><code>Redux</code>是将整个应用状态存储到一个地方上称为<code>store</code>,里面保存着一个状态树<code>store tree</code>,组件可以派发(<code>dispatch</code>)行为(<code>action</code>)给<code>store</code>,而不是直接通知其他组件，组件内部通过订阅<code>store</code>中的状态<code>state</code>来刷新自己的视图</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/11/22/Pg3vIaMpTAROFzK.png\" alt=\"img\" /></p>\n<p><strong>Redux三大原则：</strong></p>\n<ul>\n<li>唯一数据源</li>\n</ul>\n<blockquote>\n<p>整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中</p>\n</blockquote>\n<ul>\n<li>保持只读状态</li>\n</ul>\n<blockquote>\n<p><code>state</code>是只读的，唯一改变<code>state</code>的方法就是触发<code>action</code>，<code>action</code>是一个用于描述以发生时间的普通对象</p>\n</blockquote>\n<ul>\n<li>数据改变只能通过纯函数来执行</li>\n</ul>\n<blockquote>\n<p>使用纯函数来执行修改，为了描述<code>action</code>如何改变<code>state</code>的，你需要编写<code>reducers</code></p>\n</blockquote>\n<p><strong>Redux源码：</strong></p>\n<div><pre><code><span>let</span> <span>createStore</span> <span>=</span> <span>(</span><span>reducer</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> state<span>;</span>\n  <span>//获取状态对象</span>\n  <span>//存放所有的监听函数</span>\n  <span>let</span> listeners <span>=</span> <span>[</span><span>]</span><span>;</span>\n  <span>let</span> <span>getState</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> state<span>;</span>\n  <span>//提供一个方法供外部调用派发action</span>\n  <span>let</span> <span>dispath</span> <span>=</span> <span>(</span><span>action</span><span>)</span> <span>=></span> <span>{</span>\n    <span>//调用管理员reducer得到新的state</span>\n    state <span>=</span> <span>reducer</span><span>(</span>state<span>,</span> action<span>)</span><span>;</span>\n    <span>//执行所有的监听函数</span>\n    listeners<span>.</span><span>forEach</span><span>(</span><span>(</span><span>l</span><span>)</span> <span>=></span> <span>l</span><span>(</span><span>)</span><span>)</span>\n  <span>}</span>\n  <span>//订阅状态变化事件，当状态改变发生之后执行监听函数</span>\n  <span>let</span> <span>subscribe</span> <span>=</span> <span>(</span><span>listener</span><span>)</span> <span>=></span> <span>{</span>\n    listeners<span>.</span><span>push</span><span>(</span>listener<span>)</span><span>;</span>\n  <span>}</span>\n  <span>dispath</span><span>(</span><span>)</span><span>;</span>\n  <span>return</span> <span>{</span>\n    getState<span>,</span>\n    dispath<span>,</span>\n    subscribe\n  <span>}</span>\n<span>}</span>\n<span>let</span> <span>combineReducers</span><span>=</span><span>(</span><span>renducers</span><span>)</span><span>=></span><span>{</span>\n  <span>//传入一个renducers管理组，返回的是一个renducer</span>\n  <span>return</span> <span>function</span><span>(</span><span>state<span>=</span><span>{</span><span>}</span><span>,</span>action<span>=</span><span>{</span><span>}</span></span><span>)</span><span>{</span>\n    <span>let</span> newState<span>=</span><span>{</span><span>}</span><span>;</span>\n    <span>for</span><span>(</span><span>var</span> attr <span>in</span> renducers<span>)</span><span>{</span>\n      newState<span>[</span>attr<span>]</span><span>=</span>renducers<span>[</span>attr<span>]</span><span>(</span>state<span>[</span>attr<span>]</span><span>,</span>action<span>)</span>\n    <span>}</span>\n    <span>return</span> newState<span>;</span>\n  <span>}</span>\n<span>}</span>\n<span>export</span> <span>{</span>createStore<span>,</span>combineReducers<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id=\"_26、purecomponent和functioncomponent区别\"> 26、pureComponent和FunctionComponent区别</h3>\n<blockquote>\n<p><code>PureComponent</code>和<code>Component</code>完全相同，但是在<code>shouldComponentUpdate</code>实现中，<code>PureComponent</code>使用了<code>props</code>和<code>state</code>的浅比较。主要作用是用来提高某些特定场景的性能</p>\n</blockquote>\n<h3 id=\"_27-react-hooks-它带来了那些便利\"> 27 react hooks，它带来了那些便利</h3>\n<ul>\n<li>代码逻辑聚合，逻辑复用</li>\n<li>HOC嵌套地狱</li>\n<li>代替class</li>\n</ul>\n<blockquote>\n<p>React 中通常使用 类定义 或者 函数定义 创建组件:</p>\n</blockquote>\n<p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p>\n<p><strong>好处:</strong></p>\n<ol>\n<li>跨组件复用: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</li>\n<li>类定义更为复杂</li>\n</ol>\n<ul>\n<li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li>\n<li>时刻需要关注this的指向问题；</li>\n<li><strong>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿</strong></li>\n</ul>\n<ol>\n<li>状态与UI隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</li>\n</ol>\n<p><strong>注意:</strong></p>\n<ul>\n<li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li>\n<li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li>\n<li>不能在useEffect中使用useState，React 会报错提示；</li>\n<li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li>\n</ul>\n<p><strong>重要钩子：</strong></p>\n<ol>\n<li>状态钩子 (useState): 用于定义组件的 State，其到类定义中this.state的功能；</li>\n</ol>\n<div><pre><code><span>// useState 只接受一个参数: 初始状态</span>\n<span>// 返回的是组件名和更改该组件对应的函数</span>\n<span>const</span> <span>[</span>flag<span>,</span> setFlag<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>true</span><span>)</span><span>;</span>\n<span>// 修改状态</span>\n<span>setFlag</span><span>(</span><span>false</span><span>)</span>\n<span>// 上面的代码映射到类定义中:</span>\n<span>this</span><span>.</span>state <span>=</span> <span>{</span>\n  flag<span>:</span> <span>true</span>\n<span>}</span>\n<span>const</span> flag <span>=</span> <span>this</span><span>.</span>state<span>.</span>flag\n<span>const</span> <span>setFlag</span> <span>=</span> <span>(</span><span>bool</span><span>)</span> <span>=></span> <span>{</span>\n  <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>\n    flag<span>:</span> bool<span>,</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol>\n<li>生命周期钩子 (useEffect):</li>\n</ol>\n<blockquote>\n<p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (useEffect)，这里可以看做componentDidMount、componentDidUpdate和componentWillUnmount的结合。</p>\n</blockquote>\n<p><strong>useEffect(callback, [source])接受两个参数：</strong></p>\n<ul>\n<li>callback: 钩子回调函数；</li>\n<li>source: 设置触发条件，仅当 source 发生改变时才会触发；</li>\n<li>useEffect钩子在没有传入[source]参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li>\n</ul>\n<div><pre><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 组件挂载后执行事件绑定</span>\n  console<span>.</span><span>log</span><span>(</span><span>'on'</span><span>)</span>\n  <span>addEventListener</span><span>(</span><span>)</span>\n\n  <span>// 组件 update 时会执行事件解绑</span>\n  <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'off'</span><span>)</span>\n    <span>removeEventListener</span><span>(</span><span>)</span>\n  <span>}</span>\n<span>}</span><span>,</span> <span>[</span>source<span>]</span><span>)</span><span>;</span>\n\n\n<span>// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):</span>\n<span>// --- DidMount ---</span>\n<span>// 'on'</span>\n<span>// --- DidUpdate ---</span>\n<span>// 'off'</span>\n<span>// 'on'</span>\n<span>// --- DidUpdate ---</span>\n<span>// 'off'</span>\n<span>// 'on'</span>\n<span>// --- WillUnmount --- </span>\n<span>// 'off'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>通过第二个参数，我们便可模拟出几个常用的生命周期:</strong></p>\n<ul>\n<li>componentDidMount: 传入[]时，就只会在初始化时调用一次</li>\n</ul>\n<div><pre><code><span>const</span> <span>useMount</span> <span>=</span> <span>(</span><span>fn</span><span>)</span> <span>=></span> <span>useEffect</span><span>(</span>fn<span>,</span> <span>[</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次</li>\n</ul>\n<div><pre><code><span>const</span> <span>useUnmount</span> <span>=</span> <span>(</span><span>fn</span><span>)</span> <span>=></span> <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> fn<span>,</span> <span>[</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</li>\n</ul>\n<div><pre><code><span>const</span> <span>useMounted</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> <span>[</span>mounted<span>,</span> setMounted<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>\n  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>!</span>mounted <span>&amp;&amp;</span> <span>setMounted</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>setMounted</span><span>(</span><span>false</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>\n  <span>return</span> mounted<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li>componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；</li>\n</ul>\n<div><pre><code><span>const</span> mounted <span>=</span> <span>useMounted</span><span>(</span><span>)</span> \n<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  mounted <span>&amp;&amp;</span> <span>fn</span><span>(</span><span>)</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>\n<li>其它内置钩子:</li>\n</ol>\n<ul>\n<li>\n<p><code>useContext</code>: 获取 context 对象</p>\n</li>\n<li>\n<p>useReducer: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p>\n<ul>\n<li>并不是持久化存储，会随着组件被销毁而销毁；</li>\n<li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li>\n<li>配合useContext`的全局性，可以完成一个轻量级的 Redux；(easy-peasy)</li>\n</ul>\n</li>\n<li>\n<p><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</p>\n</li>\n<li>\n<p><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</p>\n</li>\n<li>\n<p><code>useRef</code>: 获取组件的真实节点；</p>\n</li>\n<li>\n<p>useLayoutEffect</p>\n<ul>\n<li>DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同</li>\n<li>useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；</li>\n<li>可以获取更新后的 state；</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>自定义钩子(useXxxxx): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的useMounted。又例如，我们需要每个页面自定义标题:</li>\n</ol>\n<div><pre><code><span>function</span> <span>useTitle</span><span>(</span><span>title</span><span>)</span> <span>{</span>\n  <span>useEffect</span><span>(</span>\n    <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      document<span>.</span>title <span>=</span> title<span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 使用:</span>\n<span>function</span> <span>Home</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> title <span>=</span> <span>'我是首页'</span>\n  <span>useTitle</span><span>(</span>title<span>)</span>\n\n  <span>return</span> <span>(</span>\n    <span>&lt;</span>div<span>></span><span>{</span>title<span>}</span><span>&lt;</span><span>/</span>div<span>></span>\n  <span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_28、react-portal-有哪些使用场景\"> 28、React Portal 有哪些使用场景</h3>\n<ul>\n<li>在以前， react 中所有的组件都会位于 #app 下，而使用 Portals 提供了一种脱离 #app 的组件</li>\n<li>因此 Portals 适合脱离文档流(out of flow) 的组件，特别是 position: absolute 与 position: fixed的组件。比如模态框，通知，警告，goTop 等。</li>\n</ul>\n<p>以下是官方一个模态框的示例，可以在以下地址中测试效果</p>\n<div><pre><code><span><span><span>&lt;</span>html</span><span>></span></span><span>\n  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>\n    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span>\n    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>modal<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span>\n    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>gotop<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span>\n    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>alert<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span><span>\n  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>\n</span><span><span><span>&lt;/</span>html</span><span>></span></span>\n<span>const</span> modalRoot <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'modal'</span><span>)</span><span>;</span>\n\n<span>class</span> <span>Modal</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>el <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n    modalRoot<span>.</span><span>appendChild</span><span>(</span><span>this</span><span>.</span>el<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>\n    modalRoot<span>.</span><span>removeChild</span><span>(</span><span>this</span><span>.</span>el<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> ReactDOM<span>.</span><span>createPortal</span><span>(</span>\n      <span>this</span><span>.</span>props<span>.</span>children<span>,</span>\n      <span>this</span><span>.</span>el<span>,</span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><strong>React Hooks当中的useEffect是如何区分生命周期钩子的：</strong></p>\n<blockquote>\n<p>useEffect可以看成是<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>三者的结合。useEffect(callback, [source])接收两个参数，调用方式如下</p>\n</blockquote>\n<div><pre><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'mounted'</span><span>)</span><span>;</span>\n  <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'willUnmount'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>,</span> <span>[</span>source<span>]</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>生命周期函数的调用主要是通过第二个参数[source]来进行控制，有如下几种情况：</p>\n</blockquote>\n<ul>\n<li><code>[source]</code>参数不传时，则每次都会优先调用上次保存的函数中返回的那个函数，然后再调用外部那个函数；</li>\n<li><code>[source]</code>参数传[]时，则外部的函数只会在初始化时调用一次，返回的那个函数也只会最终在组件卸载时调用一次；</li>\n<li><code>[source]</code>参数有值时，则只会监听到数组中的值发生变化后才优先调用返回的那个函数，再调用外部的函数。</li>\n</ul>\n<h3 id=\"_29、react和vue的区别\"> 29、react和vue的区别</h3>\n<p><strong>相同点：</strong></p>\n<ol>\n<li>数据驱动页面，提供响应式的试图组件</li>\n<li>都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范</li>\n<li>数据流动单向，都支持服务器的渲染SSR</li>\n<li>都有支持native的方法，react有React native， vue有wexx</li>\n</ol>\n<p><strong>不同点：</strong></p>\n<ol>\n<li>数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的</li>\n<li>数据渲染：大规模的数据渲染，react更快</li>\n<li>使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目</li>\n<li>开发风格：react推荐做法jsx + inline style把html和css都写在js了</li>\n</ol>\n<blockquote>\n<p>vue是采用webpack +vue-loader单文件组件格式，html, js, css同一个文件</p>\n</blockquote>\n<h3 id=\"_30、什么是高阶组件-hoc\"> 30、什么是高阶组件(HOC)</h3>\n<ul>\n<li>高阶组件(Higher Order Componennt)本身其实不是组件，而是一个函数，这个函数接收一个元组件作为参数，然后返回一个新的增强组件，高阶组件的出现本身也是为了逻辑复用，举个例子</li>\n</ul>\n<div><pre><code><span>function</span> <span>withLoginAuth</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> React<span>.</span>Component <span>{</span>\n    <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n      <span>super</span><span>(</span>props<span>)</span><span>;</span>\n      <span>this</span><span>.</span>state <span>=</span> <span>{</span>\n        isLogin<span>:</span> <span>false</span>\n      <span>}</span><span>;</span>\n    <span>}</span>\n    <span>async</span> <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n      <span>const</span> isLogin <span>=</span> <span>await</span> <span>getLoginStatus</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> isLogin <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>state<span>.</span>isLogin<span>)</span> <span>{</span>\n        <span>return</span> <span>&lt;</span>WrappedComponent <span>{</span><span>...</span><span>this</span><span>.</span>props<span>}</span> <span>/</span><span>></span><span>;</span>\n      <span>}</span>\n      <span>return</span> <span>(</span><span>&lt;</span>div<span>></span>您还未登录<span>...</span><span>&lt;</span><span>/</span>div<span>></span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_31、react实现的移动应用中-如果出现卡顿-有哪些可以考虑的优化方案\"> 31、React实现的移动应用中，如果出现卡顿，有哪些可以考虑的优化方案</h3>\n<ul>\n<li>增加<code>shouldComponentUpdate</code>钩子对新旧<code>props</code>进行比较，如果值相同则阻止更新，避免不必要的渲染，或者使用<code>PureReactComponent</code>替代<code>Component</code>，其内部已经封装了<code>shouldComponentUpdate</code>的浅比较逻辑</li>\n<li>对于列表或其他结构相同的节点，为其中的每一项增加唯一<code>key</code>属性，以方便<code>React</code>的<code>diff</code>算法中对该节点的复用，减少节点的创建和删除操作</li>\n<li><code>render</code>函数中减少类似<code>onClick={() =&gt; {doSomething()}}</code>的写法，每次调用render函数时均会创建一个新的函数，即使内容没有发生任何变化，也会导致节点没必要的重渲染，建议将函数保存在组件的成员对象中，这样只会创建一次</li>\n<li>组件的<code>props</code>如果需要经过一系列运算后才能拿到最终结果，则可以考虑使用<code>reselect</code>库对结果进行缓存，如果props值未发生变化，则结果直接从缓存中拿，避免高昂的运算代价</li>\n<li><code>webpack-bundle-analyzer</code>分析当前页面的依赖包，是否存在不合理性，如果存在，找到优化点并进行优化</li>\n</ul>\n<h3 id=\"_32、fiber\"> <strong>32、Fiber</strong></h3>\n<p><strong>React 的核心流程可以分为两个部分:</strong></p>\n<ul>\n<li>\n<p>reconciliation(调度算法，也可称为render)</p>\n<ul>\n<li>更新 <code>state</code> 与 <code>props</code>；</li>\n<li>调用生命周期钩子；</li>\n<li>生成virtual dom\n<ul>\n<li>这里应该称为 <code>Fiber Tree</code> 更为符合；</li>\n</ul>\n</li>\n<li>通过新旧 vdom 进行 diff 算法，获取 vdom change</li>\n<li>确定是否需要重新渲染</li>\n</ul>\n</li>\n<li>\n<p>commit</p>\n<ul>\n<li>如需要，则操作 <code>dom</code> 节点更新</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>要了解 Fiber，我们首先来看为什么需要它</p>\n</blockquote>\n<ul>\n<li><strong>问题</strong>: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。</li>\n<li><strong>解决方</strong>案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的</li>\n<li>简述\n<ul>\n<li>在 <code>React V16</code> 将调度算法进行了重构， 将之前的 <code>stack reconciler</code> 重构成新版的 fiber <code>reconciler</code>，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启</li>\n<li>这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</li>\n</ul>\n</li>\n<li>核心\n<ul>\n<li><code>Fiber</code> 这里可以具象为一个 数据结构</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>class</span> <span>Fiber</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>instance</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>instance <span>=</span> instance\n    <span>// 指向第一个 child 节点</span>\n    <span>this</span><span>.</span>child <span>=</span> child\n    <span>// 指向父节点</span>\n    <span>this</span><span>.</span>return <span>=</span> parent\n    <span>// 指向第一个兄弟节点</span>\n    <span>this</span><span>.</span>sibling <span>=</span> previous\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>\n<p>链表树遍历算法</p>\n<p>: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提</p>\n<ul>\n<li>首先通过不断遍历子节点，到树末尾；</li>\n<li>开始通过 <code>sibling</code> 遍历兄弟节点；</li>\n<li>return 返回父节点，继续执行2；</li>\n<li>直到 root 节点后，跳出遍历；</li>\n</ul>\n</li>\n<li>\n<p>任务分割</p>\n<p>，React 中的渲染更新可以分成两个阶段</p>\n<ul>\n<li><strong>reconciliation 阶段</strong>: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对</li>\n<li><strong>Commit 阶段</strong>: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况</li>\n</ul>\n</li>\n<li>\n<p>分散执行:任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API:requestIdleCallback与requestAnimationFrame</p>\n<ul>\n<li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 <code>pollyfill</code>，而且拥有 <code>deadline</code> 参数，限制执行事件，以继续切分任务；</li>\n<li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>// 类似于这样的方式</span>\n<span>requestIdleCallback</span><span>(</span><span>(</span><span>deadline</span><span>)</span> <span>=></span> <span>{</span>\n  <span>// 当有空闲时间时，我们执行一个组件渲染；</span>\n  <span>// 把任务塞到一个个碎片时间中去；</span>\n  <span>while</span> <span>(</span><span>(</span>deadline<span>.</span><span>timeRemaining</span><span>(</span><span>)</span> <span>></span> <span>0</span> <span>||</span> deadline<span>.</span>didTimeout<span>)</span> <span>&amp;&amp;</span> nextComponent<span>)</span> <span>{</span>\n    nextComponent <span>=</span> <span>performWork</span><span>(</span>nextComponent<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li><strong>优先级策略:</strong> 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li>\n</ul>\n<blockquote>\n<ul>\n<li>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。</li>\n<li>核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</li>\n<li>当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。</li>\n</ul>\n</blockquote>\n<h3 id=\"_33、setstate\"> 33、setState</h3>\n<blockquote>\n<p>在了解setState之前，我们先来简单了解下 React 一个包装结构: Transaction:</p>\n</blockquote>\n<p><strong>事务 (Transaction)：</strong></p>\n<blockquote>\n<p>是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作</p>\n</blockquote>\n<ul>\n<li>setState: React 中用于修改状态，更新视图。它具有以下特点:</li>\n</ul>\n<p><strong>异步与同步:</strong> setState并不是单纯的异步或同步，这其实与调用时的环境相关:</p>\n<ul>\n<li>在合成事件和生命周期钩子(除 componentDidUpdate) 中，setState是&quot;异步&quot;的；\n<ul>\n<li>原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；\n<ul>\n<li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li>\n<li>在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；</li>\n</ul>\n</li>\n<li>问题: 无法在setState后马上从this.state上获取更新后的值。</li>\n<li>解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；</li>\n</ul>\n</li>\n<li>在原生事件和 setTimeout 中，setState是同步的，可以马上获取更新后的值；\n<ul>\n<li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li>\n</ul>\n</li>\n<li><strong>批量更新</strong>: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</li>\n<li>函数式: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) =&gt; newState)；\n<ul>\n<li>使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意事项:</strong></p>\n<ul>\n<li>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li>\n<li>当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法\n<ul>\n<li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li>\n<li>在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_34、hoc-高阶组件\"> 34、HOC(高阶组件)</h3>\n<blockquote>\n<p>HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。</p>\n</blockquote>\n<p><strong>简述:</strong></p>\n<ul>\n<li>高阶组件不是组件，是 增强函数，可以输入一个元组件，返回出一个新的增强组件；</li>\n<li>高阶组件的主要作用是 代码复用，操作 状态和参数；</li>\n</ul>\n<p><strong>用法:</strong></p>\n<ul>\n<li>属性代理 (Props Proxy): 返回出一个组件，它基于被包裹组件进行 功能增强；</li>\n</ul>\n<ol>\n<li>默认参数: 可以为组件包裹一层默认参数；</li>\n</ol>\n<div><pre><code><span>function</span> <span>proxyHoc</span><span>(</span><span>Comp</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> React<span>.</span>Component <span>{</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>const</span> newProps <span>=</span> <span>{</span>\n        name<span>:</span> <span>'tayde'</span><span>,</span>\n        age<span>:</span> <span>1</span><span>,</span>\n      <span>}</span>\n      <span>return</span> <span>&lt;</span>Comp <span>{</span><span>...</span><span>this</span><span>.</span>props<span>}</span> <span>{</span><span>...</span>newProps<span>}</span> <span>/</span><span>></span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol>\n<li>提取状态: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:</li>\n</ol>\n<div><pre><code><span>function</span> <span>withOnChange</span><span>(</span><span>Comp</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> React<span>.</span>Component <span>{</span>\n    <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n      <span>super</span><span>(</span>props<span>)</span>\n      <span>this</span><span>.</span>state <span>=</span> <span>{</span>\n        name<span>:</span> <span>''</span><span>,</span>\n      <span>}</span>\n    <span>}</span>\n    <span>onChangeName</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>\n        name<span>:</span> <span>'dongdong'</span><span>,</span>\n      <span>}</span><span>)</span>\n    <span>}</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>const</span> newProps <span>=</span> <span>{</span>\n        value<span>:</span> <span>this</span><span>.</span>state<span>.</span>name<span>,</span>\n        onChange<span>:</span> <span>this</span><span>.</span>onChangeName<span>,</span>\n      <span>}</span>\n      <span>return</span> <span>&lt;</span>Comp <span>{</span><span>...</span><span>this</span><span>.</span>props<span>}</span> <span>{</span><span>...</span>newProps<span>}</span> <span>/</span><span>></span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>使用姿势如下，这样就能非常快速的将一个 Input 组件转化成受控组件。</p>\n<div><pre><code><span>const</span> <span>NameInput</span> <span>=</span> <span>props</span> <span>=></span> <span>(</span><span>&lt;</span>input name<span>=</span><span>\"name\"</span> <span>{</span><span>...</span>props<span>}</span> <span>/</span><span>></span><span>)</span>\n<span>export</span> <span>default</span> <span>withOnChange</span><span>(</span>NameInput<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>包裹组件: 可以为被包裹元素进行一层包装，</strong></p>\n<div><pre><code><span>function</span> <span>withMask</span><span>(</span><span>Comp</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> React<span>.</span>Component <span>{</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>(</span>\n          <span>&lt;</span>div<span>></span>\n            <span>&lt;</span>Comp <span>{</span><span>...</span><span>this</span><span>.</span>props<span>}</span> <span>/</span><span>></span>\n            <span>&lt;</span>div style<span>=</span><span>{</span><span>{</span>\n              width<span>:</span> <span>'100%'</span><span>,</span>\n              height<span>:</span> <span>'100%'</span><span>,</span>\n              backgroundColor<span>:</span> <span>'rgba(0, 0, 0, .6)'</span><span>,</span>\n            <span>}</span><span>}</span> \n          <span>&lt;</span><span>/</span>div<span>></span>\n      <span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>\n<p><strong>反向继承</strong> (Inheritance Inversion): 返回出一个组件，继承于被包裹组件，常用于以下操作</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>IIHoc</span><span>(</span><span>Comp</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> Comp <span>{</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>super</span><span>.</span><span>render</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>渲染劫持 (Render Highjacking)：</strong></p>\n<p>条件渲染: 根据条件，渲染不同的组件</p>\n<div><pre><code><span>function</span> <span>withLoading</span><span>(</span><span>Comp</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> Comp <span>{</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>if</span><span>(</span><span>this</span><span>.</span>props<span>.</span>isLoading<span>)</span> <span>{</span>\n        <span>return</span> <span>&lt;</span>Loading <span>/</span><span>></span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>super</span><span>.</span><span>render</span><span>(</span><span>)</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可以直接修改被包裹组件渲染出的 React 元素树</p>\n<p><strong>操作状态 (Operate State)</strong>: 可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。</p>\n<p><strong>应用场景:</strong></p>\n<blockquote>\n<p>权限控制，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:</p>\n</blockquote>\n<div><pre><code><span>function</span> <span>withAdminAuth</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> React<span>.</span>Component <span>{</span>\n    <span>constructor</span><span>(</span><span>props</span><span>)</span><span>{</span>\n      <span>super</span><span>(</span>props<span>)</span>\n      <span>this</span><span>.</span>state <span>=</span> <span>{</span>\n        isAdmin<span>:</span> <span>false</span><span>,</span>\n      <span>}</span>\n    <span>}</span> \n    <span>async</span> <span>componentWillMount</span><span>(</span><span>)</span> <span>{</span>\n      <span>const</span> currentRole <span>=</span> <span>await</span> <span>getCurrentUserRole</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>\n        isAdmin<span>:</span> currentRole <span>===</span> <span>'Admin'</span><span>,</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>this</span><span>.</span>state<span>.</span>isAdmin<span>)</span> <span>{</span>\n        <span>return</span> <span>&lt;</span>Comp <span>{</span><span>...</span><span>this</span><span>.</span>props<span>}</span> <span>/</span><span>></span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>(</span><span>&lt;</span>div<span>></span>您没有权限查看该页面，请联系管理员！<span>&lt;</span><span>/</span>div<span>></span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>性能监控</strong>，包裹组件的生命周期，进行统一埋点:</p>\n<div><pre><code><span>function</span> <span>withTiming</span><span>(</span><span>Comp</span><span>)</span>\u0010 <span>{</span>\n  <span>return</span> <span>class</span> <span>extends</span> Comp <span>{</span>\n    <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n      <span>super</span><span>(</span>props<span>)</span><span>;</span>\n      <span>this</span><span>.</span>start <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>end <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n    <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n      <span>super</span><span>.</span>componentDidMount <span>&amp;&amp;</span> <span>super</span><span>.</span><span>componentDidMount</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>end <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n      console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>WrappedComponent<span>.</span>name<span>}</span></span><span> 组件渲染时间为 </span><span><span>${</span><span>this</span><span>.</span>end <span>-</span> <span>this</span><span>.</span>start<span>}</span></span><span> ms</span><span>`</span></span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>render</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>super</span><span>.</span><span>render</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>代码复用，可以将重复的逻辑进行抽象。</p>\n<p><strong>使用注意:</strong></p>\n<ul>\n<li>纯函数: 增强函数应为纯函数，避免侵入修改元组件；</li>\n<li>避免用法污染: 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；</li>\n<li>命名空间: 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；</li>\n<li><strong>引用传递</strong>: 如果需要传递元组件的 refs 引用，可以使用React.forwardRef；</li>\n<li>静态方法: 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:\n<ul>\n<li>函数导出</li>\n<li>静态方法赋值</li>\n</ul>\n</li>\n<li><strong>重新渲</strong>染: 由于增强函数每次调用是返回一个新组件，因此如果在 Render中使用增强函数，就会导致每次都重新渲染整个HOC，而且之前的状态会丢失；</li>\n</ul>\n<h3 id=\"_35、react如何进行组件-逻辑复用\"> 35、React如何进行组件/逻辑复用?</h3>\n<blockquote>\n<p>抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:</p>\n</blockquote>\n<ul>\n<li>高阶组件:\n<ul>\n<li>属性代理</li>\n<li>反向继承</li>\n</ul>\n</li>\n<li>渲染属性</li>\n<li>react-hooks</li>\n</ul>\n<h3 id=\"_36、你对-time-slice的理解\"> 36、你对 Time Slice的理解?</h3>\n<p><strong>时间分片：</strong></p>\n<ul>\n<li>React 在渲染（render）的时候，不会阻塞现在的线程</li>\n<li>如果你的设备足够快，你会感觉渲染是同步的</li>\n<li>如果你设备非常慢，你会感觉还算是灵敏的</li>\n<li>虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来</li>\n<li>同样书写组件的方式</li>\n</ul>\n<blockquote>\n<p>也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果呢？</p>\n</blockquote>\n<h3 id=\"_37、setstate到底是异步还是同步\"> 37、setState到底是异步还是同步?</h3>\n<blockquote>\n<p>先给出答案: 有时表现出异步,有时表现出同步</p>\n</blockquote>\n<ul>\n<li><code>setState</code>只在合成事件和钩子函数中是“异步”的，在原生事件和<code>setTimeout</code> 中都是同步的</li>\n<li><code>setState</code> 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数<code>setState(partialState, callback)</code>中的<code>callback</code>拿到更新后的结果</li>\n<li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和<code>setTimeout</code> 中不会批量更新，在“异步”中如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新</li>\n</ul>\n",
      "image": "https://i.loli.net/2020/11/22/Pg3vIaMpTAROFzK.png",
      "date_published": "2021-07-29T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.496Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "webpack",
      "url": "https://github.com/letme350/webpack/webpack/",
      "id": "https://github.com/letme350/webpack/webpack/",
      "content_html": "<h1 id=\"webpack\"> webpack</h1>\n<blockquote>\n<p>使用webpack4定制你的前端开发环境</p>\n</blockquote>\n<h2 id=\"一、webpack概念和基础使用\"> 一、webpack概念和基础使用</h2>\n<h3 id=\"_1-1-安装和使用\"> 1.1 安装和使用</h3>\n<div><pre><code><span>npm</span> <span>install</span> webpack webpack-cli -g \n\n<span># 或者</span>\n<span>yarn</span> global <span>add</span> webpack webpack-cli\n\n<span># 然后就可以全局执行命令了</span>\nwebpack --help\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_1-2-webpack-的基本概念\"> 1.2 webpack 的基本概念</h3>\n<blockquote>\n<p>webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/11/29/dfP71Nt8KgFkUqs.png\" alt=\"img\" /></p>\n<blockquote>\n<p>webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件</p>\n</blockquote>\n<p><strong>入口：</strong></p>\n<blockquote>\n<p>入口可以使用 <code>entry</code>字段来进行配置，<code>webpack</code> 支持配置多个入口来进行构建</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'./src/index.js'</span> \n<span>}</span>\n\n<span>// 上述配置等同于</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    main<span>:</span> <span>'./src/index.js'</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 或者配置多个入口</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    foo<span>:</span> <span>'./src/page-foo.js'</span><span>,</span>\n    bar<span>:</span> <span>'./src/page-bar.js'</span><span>,</span> \n    <span>// ...</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 使用数组来对多个文件进行打包</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    main<span>:</span> <span>[</span>\n      <span>'./src/foo.js'</span><span>,</span>\n      <span>'./src/bar.js'</span>\n    <span>]</span>\n  <span>}</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><strong>loader：</strong></p>\n<blockquote>\n<p>可以把 <code>loader</code>理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块</p>\n</blockquote>\n<ul>\n<li>当我们需要使用不同的 <code>loader</code> 来解析处理不同类型的文件时，我们可以在 <code>module.rules</code> 字段下来配置相关的规则，例如使用 <code>Babel</code> 来处理 <code>.js</code> 文件</li>\n</ul>\n<div><pre><code>module<span>:</span> <span>{</span>\n  <span>// ...</span>\n  rules<span>:</span> <span>[</span>\n    <span>{</span>\n      test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span> <span>// 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span>\n      include<span>:</span> <span>[</span>\n        path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span> <span>// 指定哪些路径下的文件需要经过 loader 处理</span>\n      <span>]</span><span>,</span>\n      use<span>:</span> <span>'babel-loader'</span><span>,</span> <span>// 指定使用的 loader</span>\n    <span>}</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>plugin：</strong></p>\n<blockquote>\n<p>模块代码转换的工作由 <code>loader</code> 来处理，除此之外的其他任何工作都可以交由 <code>plugin</code> 来完成。通过添加我们需要的 <code>plugin</code>，可以满足更多构建中特殊的需求。例如，要使用压缩 <code>JS</code>代码的 <code>uglifyjs-webpack-plugin</code> 插件，只需在配置中通过 <code>plugins</code>字段添加新的 <code>plugin</code>即可...</p>\n</blockquote>\n<div><pre><code><span>const</span> UglifyPlugin <span>=</span> <span>require</span><span>(</span><span>'uglifyjs-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>UglifyPlugin</span><span>(</span><span>)</span>\n  <span>]</span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p><code>plugin</code> 理论上可以干涉 <code>webpack</code> 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求</p>\n</blockquote>\n<p><strong>输出：</strong></p>\n<blockquote>\n<p>构建结果的文件名、路径等都是可以配置的，使用 <code>output</code>字段</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  output<span>:</span> <span>{</span>\n    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n    filename<span>:</span> <span>'bundle.js'</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span>\n\n<span>// 或者多个入口生成不同文件</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    foo<span>:</span> <span>'./src/foo.js'</span><span>,</span>\n    bar<span>:</span> <span>'./src/bar.js'</span><span>,</span>\n  <span>}</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    filename<span>:</span> <span>'[name].js'</span><span>,</span>\n    path<span>:</span> __dirname <span>+</span> <span>'/dist'</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span>\n\n<span>// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  output<span>:</span> <span>{</span>\n    filename<span>:</span> <span>'[name].js'</span><span>,</span>\n    path<span>:</span> __dirname <span>+</span> <span>'/dist/[hash]'</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>\n<p>我们一开始直接使用 <code>webpack</code> 构建时，默认创建的输出内容就是 <code>./dist/main.js</code></p>\n</blockquote>\n<p><strong>一个简单的 webpack 配置：</strong></p>\n<blockquote>\n<p>我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 <code>webpack</code> 配置了，<code>webpack</code> 运行时默认读取项目下的 <code>webpack.config.js</code> 文件作为配置。所以我们在项目中创建一个 <code>webpack.config.js</code> 文件</p>\n</blockquote>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> UglifyPlugin <span>=</span> <span>require</span><span>(</span><span>'uglifyjs-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'./src/index.js'</span><span>,</span>\n\n  output<span>:</span> <span>{</span>\n    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n    filename<span>:</span> <span>'bundle.js'</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>'babel-loader'</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  <span>// 代码模块路径解析的配置</span>\n  resolve<span>:</span> <span>{</span>\n    modules<span>:</span> <span>[</span>\n      <span>\"node_modules\"</span><span>,</span>\n      path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span>\n    <span>]</span><span>,</span>\n\n    extensions<span>:</span> <span>[</span><span>\".wasm\"</span><span>,</span> <span>\".mjs\"</span><span>,</span> <span>\".js\"</span><span>,</span> <span>\".json\"</span><span>,</span> <span>\".jsx\"</span><span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>UglifyPlugin</span><span>(</span><span>)</span><span>,</span> \n    <span>// 使用 uglifyjs-webpack-plugin 来压缩 JS 代码</span>\n    <span>// 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件</span>\n    <span>// 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id=\"二、搭建基础的前端开发环境\"> 二、搭建基础的前端开发环境</h2>\n<h3 id=\"_2-1-关联-html\"> 2.1 关联 HTML</h3>\n<blockquote>\n<p><code>webpack</code> 默认从作为入口的 <code>.js</code> 文件进行构建（更多是基于 <code>SPA</code> 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 <code>script</code> 标签直接引用构建好的 JS 文件，如...</p>\n</blockquote>\n<div><pre><code><span>&lt;</span>script src<span>=</span><span>\"./dist/bundle.js\"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>但是，如果我们的文件名或者路径会变化，例如使用 <code>[hash]</code> 来进行命名，那么最好是将 <code>HTML</code> 引用路径和我们的构建结果关联起来，这个时候我们可以使用 <code>html-webpack-plugin</code></li>\n<li><code>html-webpack-plugin</code> 是一个独立的 <code>node package</code>，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中</li>\n</ul>\n<div><pre><code><span>npm</span> <span>install</span> html-webpack-plugin -D \n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>然后在 <code>webpack</code>配置中，将 <code>html-webpack-plugin</code> 添加到 <code>plugins</code> 列表中</p>\n</blockquote>\n<div><pre><code><span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>这样配置好之后，构建时 <code>html-webpack-plugin</code> 会为我们创建一个 <code>HTML</code> 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 <code>HTML</code> 文件并没有什么用，我们需要自己来写 <code>HTML</code> 文件，可以通过 <code>html-webpack-plugin</code> 的配置，传递一个写好的 HTML 模板...</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 配置输出文件名和路径</span>\n      template<span>:</span> <span>'assets/index.html'</span><span>,</span> <span>// 配置文件模板</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>这样，通过 <code>html-webpack-plugin</code> 就可以将我们的页面和构建 <code>JS</code> 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 <code>html-webpack-plugin</code>， 并将它们都放到 <code>plugins</code> 字段数组中就可以了...</p>\n</blockquote>\n<h2 id=\"_2-2-构建-css\"> 2.2 构建 CSS</h2>\n<blockquote>\n<p>我们编写 <code>CSS</code>，并且希望使用 <code>webpack</code> 来进行构建，为此，需要在配置中引入 <code>loader</code> 来解析和处理 <code>CSS</code> 文件</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// ...</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>'style-loader'</span><span>,</span>\n          <span>'css-loader'</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>\n<li><code>css-loader</code> 负责解析 <code>CSS</code> 代码，主要是为了处理 <code>CSS</code> 中的依赖，例如 <code>@import</code> 和 <code>url()</code> 等引用外部文件的声明；</li>\n<li><code>style-loader</code> 会将 <code>css-loader</code> 解析的结果转变成 <code>JS</code>代码，运行时动态插入 <code>style</code> 标签来让 <code>CSS</code> 代码生效...</li>\n</ul>\n<blockquote>\n<p>经由上述两个 <code>loader</code> 的处理后，CSS 代码会转变为 JS，和 <code>index.js</code>一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 <code>extract-text-webpack-plugin</code> 插件</p>\n</blockquote>\n<div><pre><code><span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        <span>// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span> \n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>'css-loader'</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 引入插件，配置文件名，这里同样可以使用 [hash]</span>\n    <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'index.css'</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_2-3-css-预处理器\"> 2.3 CSS 预处理器</h3>\n<blockquote>\n<p>在上述使用 CSS 的基础上，通常我们会使用 <code>Less/Sass</code> 等 CSS 预处理器，webpack 可以通过添加对应的 <code>loader</code> 来支持，以使用 <code>Less</code> 为例，我们可以在官方文档中找到对应的 <code>loader</code></p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        <span>// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span> \n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>[</span>\n            <span>'css-loader'</span><span>,</span> \n            <span>'less-loader'</span><span>,</span>\n          <span>]</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span> \n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n  <span>// ...</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"_2-4-处理图片文件\"> 2.4 处理图片文件</h3>\n<blockquote>\n<p>在前端项目的样式中总会使用到图片，虽然我们已经提到 <code>css-loader</code> 会解析样式中用 <code>url()</code> 引用的文件路径，但是图片对应的 <code>jpg/png/gif</code> 等文件格式，<code>webpack</code> 处理不了。是的，我们只要添加一个处理图片的 <code>loader</code> 配置就可以了，现有的 <code>file-loader</code> 就是个不错的选择...</p>\n</blockquote>\n<ul>\n<li><code>file-loader</code> 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 <code>rules</code>中添加一个字段，增加图片类型文件的解析配置</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'file-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span><span>}</span><span>,</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_2-5-使用-babel\"> 2.5 使用 Babel</h3>\n<blockquote>\n<p><code>Babel</code> 是一个让我们能够使用 <code>ES</code> 新特性的 <code>JS</code> 编译工具，我们可以在 <code>webpack</code> 中配置 Babel，以便使用 <code>ES6</code>、<code>ES7</code> 标准来编写 <code>JS</code>代码</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span> <span>// 支持 js 和 jsx</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span> <span>// src 目录下的才需要经过 babel-loader 处理</span>\n        <span>]</span><span>,</span>\n        loader<span>:</span> <span>'babel-loader'</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-6-启动静态服务\"> 2.6 启动静态服务</h3>\n<blockquote>\n<p>至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 <code>webpack-dev-server</code> 在本地开启一个简单的静态服务来进行开发</p>\n</blockquote>\n<div><pre><code><span>\"scripts\"</span><span>:</span> <span>{</span>\n  <span>\"build\"</span><span>:</span> <span>\"webpack --mode production\"</span><span>,</span>\n  <span>\"start\"</span><span>:</span> <span>\"webpack-dev-server --mode development\"</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>尝试着运行 <code>npm start</code> 或者 <code>yarn start</code>，然后就可以访问<code>http://localhost:8080/</code> 来查看你的页面了。默认是访问 <code>index.html</code>，如果是其他页面要注意访问的 URL 是否正确</p>\n</blockquote>\n<h3 id=\"_2-7-完整示例代码\"> 2.7 完整示例代码</h3>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'./src/index.js'</span><span>,</span>\n\n  output<span>:</span> <span>{</span>\n    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n    filename<span>:</span> <span>'[name].js'</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>'babel-loader'</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        <span>// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span> \n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>[</span>\n            <span>'css-loader'</span><span>,</span> \n            <span>'less-loader'</span><span>,</span>\n          <span>]</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span> \n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'file-loader'</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  <span>// 代码模块路径解析的配置</span>\n  resolve<span>:</span> <span>{</span>\n    modules<span>:</span> <span>[</span>\n      <span>\"node_modules\"</span><span>,</span>\n      path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n    <span>]</span><span>,</span>\n\n    extensions<span>:</span> <span>[</span><span>\".wasm\"</span><span>,</span> <span>\".mjs\"</span><span>,</span> <span>\".js\"</span><span>,</span> <span>\".json\"</span><span>,</span> <span>\".jsx\"</span><span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 配置输出文件名和路径</span>\n      template<span>:</span> <span>'src/index.html'</span><span>,</span> <span>// 配置文件模板</span>\n    <span>}</span><span>)</span><span>,</span>\n    <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'[name].css'</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id=\"三、webpack如何解析代码模块路径\"> 三、webpack如何解析代码模块路径</h2>\n<blockquote>\n<p>webpack 中有一个很关键的模块 <code>enhanced-resolve</code> 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置</p>\n</blockquote>\n<ul>\n<li>在 webpack 配置中，和模块路径解析相关的配置都在 <code>resolve</code>字段下</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  resolve<span>:</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-1-常用的一些配置\"> 3.1 常用的一些配置</h3>\n<p><strong>resolve.alias：</strong></p>\n<blockquote>\n<p>假设我们有个 <code>utils</code> 模块极其常用，经常编写相对路径很麻烦，希望可以直接 <code>import 'utils'</code> 来引用，那么我们可以配置某个模块的别名，如</p>\n</blockquote>\n<div><pre><code>alias<span>:</span> <span>{</span>\n  utils<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/utils'</span><span>)</span> <span>// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：</p>\n</blockquote>\n<div><pre><code><span>import</span> <span>'utils/query.js'</span> \n<span>// 等同于 </span>\n<span>import</span> <span>'[项目绝对路径]/src/utils/query.js'</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>如果需要进行精确匹配可以使用：</p>\n</blockquote>\n<div><pre><code>alias<span>:</span> <span>{</span>\n  utils$<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/utils'</span><span>)</span> <span>// 只会匹配 import 'utils'</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>resolve.extensions：</strong></p>\n<div><pre><code>extensions<span>:</span> <span>[</span><span>'.wasm'</span><span>,</span> <span>'.mjs'</span><span>,</span> <span>'.js'</span><span>,</span> <span>'.json'</span><span>,</span> <span>'.jsx'</span><span>]</span><span>,</span>\n<span>// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>这个配置的作用是和文件后缀名有关的,这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找</p>\n</blockquote>\n<h2 id=\"四、配置loader\"> )四、配置loader</h2>\n<h3 id=\"_4-1-loader-匹配规则\"> 4.1 loader 匹配规则</h3>\n<blockquote>\n<p>当我们需要配置 <code>loader</code> 时，都是在 <code>module.rules</code> 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 <code>loader</code>的规则</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span> \n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span> <span>// 条件</span>\n        include<span>:</span> <span>[</span> \n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span> <span>// 条件</span>\n        use<span>:</span> <span>'babel-loader'</span><span>,</span> <span>// 规则应用结果\u000e</span>\n      <span>}</span><span>,</span> <span>// 一个 object 即一条规则</span>\n      <span>// ...</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>\n<p><code>loader</code> 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用</p>\n</blockquote>\n<h3 id=\"_4-2-规则条件配置\"> 4.2 规则条件配置</h3>\n<blockquote>\n<p>大多数情况下，配置 <code>loader</code> 的匹配条件时，只要使用 <code>test</code> 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 <code>loader</code>，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式...</p>\n</blockquote>\n<ul>\n<li><code>{ test: ... }</code> 匹配特定条件</li>\n<li><code>{ include: ... }</code> 匹配特定路径</li>\n<li><code>{ exclude: ... }</code>排除特定路径</li>\n<li><code>{ and: [...] }</code>必须匹配数组中所有条件</li>\n<li><code>{ or: [...] }</code>匹配数组中任意一个条件</li>\n<li><code>{ not: [...] }</code> 排除匹配数组中所有条件...</li>\n</ul>\n<blockquote>\n<p>上述的所谓条件的值可以是：</p>\n</blockquote>\n<ul>\n<li>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</li>\n<li>正则表达式：调用正则的 <code>test</code> 方法来判断匹配</li>\n<li>函数：<code>(path) =&gt; boolean</code>，返回 <code>true</code> 表示匹配</li>\n<li>数组：至少包含一个条件的数组</li>\n<li>对象：匹配所有属性值的条件...</li>\n</ul>\n<div><pre><code>rules<span>:</span> <span>[</span>\n  <span>{</span>\n    test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span> <span>// 正则</span>\n    include<span>:</span> <span>[</span>\n      path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span> <span>// 字符串，注意是绝对路径</span>\n    <span>]</span><span>,</span> <span>// 数组</span>\n    <span>// ...</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    test<span>:</span> <span>{</span>\n      js<span>:</span> <span><span>/</span><span>\\.js</span><span>/</span></span><span>,</span>\n      jsx<span>:</span> <span><span>/</span><span>\\.jsx</span><span>/</span></span><span>,</span>\n    <span>}</span><span>,</span> <span>// 对象，不建议使用</span>\n    not<span>:</span> <span>[</span>\n      <span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span> <span>/* ... */</span> <span>return</span> <span>true</span><span>;</span> <span>}</span><span>,</span> <span>// 函数，通常需要高度自定义时才会使用</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>]</span><span>,</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_4-3-使用-loader-配置\"> 4.3 使用 loader 配置</h3>\n<blockquote>\n<p><code>module.rules</code> 的匹配规则最重要的还是用于配置 <code>loader</code>，我们可以使用 <code>use</code> 字段</p>\n</blockquote>\n<div><pre><code>rules<span>:</span> <span>[</span>\n  <span>{</span>\n    test<span>:</span> <span><span>/</span><span>\\.less</span><span>/</span></span><span>,</span>\n    use<span>:</span> <span>[</span>\n      <span>'style-loader'</span><span>,</span> <span>// 直接使用字符串表示 loader</span>\n      <span>{</span>\n        loader<span>:</span> <span>'css-loader'</span><span>,</span>\n        options<span>:</span> <span>{</span>\n          importLoaders<span>:</span> <span>1</span>\n        <span>}</span><span>,</span>\n      <span>}</span><span>,</span> <span>// 用对象表示 loader，可以传递 loader 配置等</span>\n      <span>{</span>\n        loader<span>:</span> <span>'less-loader'</span><span>,</span>\n        options<span>:</span> <span>{</span>\n          noIeCompat<span>:</span> <span>true</span>\n        <span>}</span><span>,</span> <span>// 传递 loader 配置</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>]</span><span>,</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>\n<p>use字段可以是一个数组，也可以是一个字符串或者表示 <code>loader</code> 的对象。如果只需要一个 <code>loader</code>，也可以这样：<code>use: { loader: 'babel-loader'</code>, `options: { ... } }</p>\n</blockquote>\n<h3 id=\"_4-4-loader-应用顺序\"> 4.4 loader 应用顺序</h3>\n<ul>\n<li>对于上面的 <code>less</code> 规则配置，一个 <code>style.less</code> 文件会途径 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code> 处理，成为一个可以打包的模块。</li>\n<li><code>loader</code> 的应用顺序在配置多个 <code>loader</code> 一起工作时很重要，通常会使用在 CSS 配置上，除了 <code>style-loader</code> 和 <code>css-loader</code>，你可能还要配置 <code>less-loader</code>然后再加个 <code>postcss</code> 的 <code>autoprefixer</code> 等。</li>\n<li>上述从后到前的顺序是在同一个 <code>rule</code> 中进行的，那如果多个 <code>rule</code> 匹配了同一个模块文件，<code>loader</code> 的应用顺序又是怎样的呢？看一份这样的配置...</li>\n</ul>\n<div><pre><code>rules<span>:</span> <span>[</span>\n  <span>{</span>\n    test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n    exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span>\n    loader<span>:</span> <span>\"eslint-loader\"</span><span>,</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n    exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span>\n    loader<span>:</span> <span>\"babel-loader\"</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>]</span><span>,</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>\n<p>这样无法法保证 <code>eslint-loader</code> 在 <code>babel-loader</code> 应用前执行。<code>webpack</code>在 r<code>ules</code> 中提供了一个 <code>enforce</code> 的字段来配置当前 <code>rule</code> 的 <code>loader</code> 类型，没配置的话是普通类型，我们可以配置 <code>pre</code>或<code>post</code>，分别对应前置类型或后置类型的 <code>loader</code>...</p>\n</blockquote>\n<ul>\n<li>所有的 <code>loader</code> <strong>按照前置</strong> -&gt; <strong>行</strong>内 -&gt; <strong>普通</strong> -&gt; <strong>后置</strong>的顺序执行。所以当我们要确保 <code>eslint-loader</code> 在 <code>babel-loader</code> 之前执行时，可以如下添加 <code>enforce</code> 配置</li>\n</ul>\n<div><pre><code>rules<span>:</span> <span>[</span>\n  <span>{</span>\n    enforce<span>:</span> <span>'pre'</span><span>,</span> <span>// 指定为前置类型</span>\n    test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n    exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span>\n    loader<span>:</span> <span>\"eslint-loader\"</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>]</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>当项目文件类型和应用的 <code>loader</code> 不是特别复杂的时候，通常建议把要应用的同一类型 <code>loader</code> 都写在同一个匹配规则中，这样更好维护和控制</p>\n</blockquote>\n<h3 id=\"_4-5-完整代码\"> 4.5 完整代码</h3>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>\n<span>const</span> CopyWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'copy-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'./src/index'</span><span>,</span>\n\n  output<span>:</span> <span>{</span>\n    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n    filename<span>:</span> <span>'[name].js'</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        enforce<span>:</span> <span>'pre'</span><span>,</span> <span>// 指定为前置类型</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?$</span><span>/</span></span><span>,</span>\n        exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span>\n        loader<span>:</span> <span>\"eslint-loader\"</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?$</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>'babel-loader'</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span>\n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>[</span>\n            <span>'css-loader'</span><span>,</span>\n          <span>]</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span>\n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>[</span>\n            <span>'css-loader'</span><span>,</span>\n            <span>'less-loader'</span><span>,</span>\n          <span>]</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'file-loader'</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  resolve<span>:</span> <span>{</span>\n    alias<span>:</span> <span>{</span>\n      utils<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/utils'</span><span>)</span><span>,</span> <span>// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span>\n      log$<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/utils/log.js'</span><span>)</span> <span>// 只匹配 log</span>\n    <span>}</span><span>,</span>\n    extensions<span>:</span> <span>[</span><span>'.js'</span><span>,</span> <span>'.json'</span><span>,</span> <span>'.jsx'</span><span>,</span> <span>'.css'</span><span>,</span> <span>'.less'</span><span>]</span><span>,</span>\n    modules<span>:</span> <span>[</span>\n      path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'node_modules'</span><span>)</span><span>,</span> <span>// 指定当前目录下的 node_modules 优先查找</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 配置输出文件名和路径</span>\n      template<span>:</span> <span>'src/index.html'</span><span>,</span> <span>// 配置文件模板</span>\n    <span>}</span><span>)</span><span>,</span>\n    <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'[name].css'</span><span>)</span><span>,</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>TWO</span><span>:</span> <span>'1+1'</span><span>,</span>\n      <span>CONSTANTS</span><span>:</span> <span>{</span>\n        <span>APP_VERSION</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'1.1.2'</span><span>)</span><span>,</span> <span>// const CONSTANTS = { APP_VERSION: '1.1.2' }</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>)</span><span>,</span>\n    <span>new</span> <span>CopyWebpackPlugin</span><span>(</span><span>[</span>\n      <span>{</span> from<span>:</span> <span>'src/assets/favicon.ico'</span><span>,</span> to<span>:</span> <span>'favicon.ico'</span><span>,</span> <span>}</span><span>,</span> <span>// 顾名思义，from 配置来源，to 配置目标路径</span>\n    <span>]</span><span>)</span><span>,</span>\n    <span>new</span> <span>webpack<span>.</span>ProvidePlugin</span><span>(</span><span>{</span>\n      _<span>:</span> <span>'lodash'</span><span>,</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n\n  devServer<span>:</span> <span>{</span>\n    port<span>:</span> <span>'1234'</span><span>,</span>\n    <span>before</span><span>(</span><span>app</span><span>)</span><span>{</span>\n      app<span>.</span><span>get</span><span>(</span><span>'/api/test.json'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span> <span>// 当访问 /some/path 路径时，返回自定义的 json 数据</span>\n        res<span>.</span><span>json</span><span>(</span><span>{</span> code<span>:</span> <span>200</span><span>,</span> message<span>:</span> <span>'hello world'</span> <span>}</span><span>)</span>\n      <span>}</span><span>)</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br></div></div><h2 id=\"五、使用plugin\"> 五、使用plugin</h2>\n<blockquote>\n<p>更多的插件可以在这里查找：<a href=\"https://github.com/webpack-contrib/awesome-webpack#webpack-plugins\" target=\"_blank\" rel=\"noopener noreferrer\">plugins in awesome-webpack</a></p>\n</blockquote>\n<h3 id=\"_5-1-defineplugin\"> 5.1 DefinePlugin</h3>\n<blockquote>\n<p><code>DefinePlugin</code> 是 <code>webpack</code> 内置的插件，可以使用 <code>webpack.DefinePlugin</code> 直接获取</p>\n</blockquote>\n<ul>\n<li>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 <code>webpack</code> 的配置中去指定，例如</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>PRODUCTION</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>true</span><span>)</span><span>,</span> <span>// const PRODUCTION = true</span>\n      <span>VERSION</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'5fa3b9'</span><span>)</span><span>,</span> <span>// const VERSION = '5fa3b9'</span>\n      <span>BROWSER_SUPPORTS_HTML5</span><span>:</span> <span>true</span><span>,</span> <span>// const BROWSER_SUPPORTS_HTML5 = 'true'</span>\n      <span>TWO</span><span>:</span> <span>'1+1'</span><span>,</span> <span>// const TWO = 1 + 1,</span>\n      <span>CONSTANTS</span><span>:</span> <span>{</span>\n        <span>APP_VERSION</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>'1.1.2'</span><span>)</span> <span>// const CONSTANTS = { APP_VERSION: '1.1.2' }</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>\n<p>有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：</p>\n</blockquote>\n<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>\"Running App version \"</span> <span>+</span> <span>VERSION</span><span>)</span><span>;</span>\n\n<span>if</span><span>(</span><span>!</span><span>BROWSER_SUPPORTS_HTML5</span><span>)</span> <span>require</span><span>(</span><span>\"html5shiv\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。</p>\n</blockquote>\n<ul>\n<li>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 <code>&quot;1+1&quot;</code>，最后的结果是 <code>2</code></li>\n<li>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 <code>true</code>，最后的结果是 <code>'true'</code></li>\n<li>如果配置的是一个对象字面量，那么该对象的所有 <code>key</code>会以同样的方式去定义</li>\n<li>这样我们就可以理解为什么要使用 <code>JSON.stringify()</code> 了，因为 <code>JSON.stringify(true)</code> 的结果是 <code>'true'</code>，<code>JSON.stringify(&quot;5fa3b9&quot;)</code> 的结果是 <code>&quot;5fa3b9&quot;</code>。</li>\n</ul>\n<blockquote>\n<p>社区中关于 <code>DefinePlugin</code> 使用得最多的方式是定义环境变量，例如 <code>PRODUCTION = true</code> 或者 <code>__DEV__ = true</code> 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。</p>\n</blockquote>\n<ul>\n<li>建议使用 <code>process.env.NODE_ENV</code>: ... 的方式来定义 <code>process.env.NODE_ENV</code>，而不是使用 <code>process: { env: { NODE_ENV: ... } }</code> 的方式，因为这样会覆盖掉 <code>process</code> 这个对象，可能会对其他代码造成影响...</li>\n</ul>\n<h3 id=\"_5-2-copy-webpack-plugin\"> 5.2 copy-webpack-plugin</h3>\n<blockquote>\n<p>我们一般会把开发的所有源码和资源文件放在 <code>src/</code> 目录下，构建的时候产出一个 <code>build/</code> 目录，通常会直接拿 <code>build</code> 中的所有文件来发布。有些文件没经过 <code>webpack</code> 处理，但是我们希望它们也能出现在 <code>build</code> 目录下，这时就可以使用 <code>CopyWebpackPlugin</code> 来处理了...</p>\n</blockquote>\n<div><pre><code><span>const</span> CopyWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'copy-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>CopyWebpackPlugin</span><span>(</span><span>[</span>\n      <span>{</span> from<span>:</span> <span>'src/file.txt'</span><span>,</span> to<span>:</span> <span>'build/file.txt'</span><span>,</span> <span>}</span><span>,</span> <span>// 顾名思义，from 配置来源，to 配置目标路径</span>\n      <span>{</span> from<span>:</span> <span>'src/*.ico'</span><span>,</span> to<span>:</span> <span>'build/*.ico'</span> <span>}</span><span>,</span> <span>// 配置项可以使用 glob</span>\n      <span>// 可以配置很多项复制规则</span>\n    <span>]</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_5-3-extract-text-webpack-plugin\"> 5.3 extract-text-webpack-plugin</h3>\n<blockquote>\n<p>我们用它来把依赖的 <code>CSS</code> 分离出来成为单独的文件。这里再看一下使用 <code>extract-text-webpack-plugin</code> 的配置</p>\n</blockquote>\n<div><pre><code><span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css$</span><span>/</span></span><span>,</span>\n        <span>// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span> \n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>'css-loader'</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span> \n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// 引入插件，配置文件名，这里同样可以使用 [hash]</span>\n    <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'index.css'</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>\n<p>在上述的配置中，我们使用了 <code>index.css</code> 作为单独分离出来的文件名，但有的时候构建入口不止一个，<code>extract-text-webpack-plugin</code> 会为每一个入口创建单独分离的文件，因此最好这样配置</p>\n</blockquote>\n<div><pre><code><span>// 这样确保在使用多个构建入口时，生成不同名称的文件</span>\nplugins<span>:</span> <span>[</span>\n  <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'[name].css'</span><span>)</span><span>,</span>\n<span>]</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"六、更好使用webpack-dev-server\"> 六、更好使用webpack-dev-server</h2>\n<blockquote>\n<p><code>webpack-dev-server</code> 是 <code>webpack</code> 官方提供的一个工具，可以基于当前的 <code>webpack</code> 构建配置快速启动一个静态服务。当 <code>mode</code> 为 <code>development</code> 时，会具备 <code>hot reload</code> 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果...</p>\n</blockquote>\n<h3 id=\"_6-1-基础使用\"> 6.1 基础使用</h3>\n<blockquote>\n<p><code>webpack-dev-server</code> 是一个 <code>npm package</code>，安装后在已经有 <code>webpack</code> 配置文件的项目目录下直接启动就可以</p>\n</blockquote>\n<ul>\n<li><code>webpack-dev-server</code> 默认使用 <code>8080</code> 端口</li>\n</ul>\n<div><pre><code>npm install webpack-dev-server -gwebpack-dev-server --mode development \n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p><code>package</code> 中的 <code>scripts</code> 配置：</p>\n</blockquote>\n<div><pre><code><span>{</span>\n  <span>// ...</span>\n  <span>\"scripts\"</span><span>:</span> <span>{</span>\n    <span>\"start\"</span><span>:</span> <span>\"webpack-dev-server --mode development\"</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_6-2-配置\"> 6.2 配置</h3>\n<blockquote>\n<p>在 webpack 的配置中，可以通过 <code>devServer</code> 字段来配置 <code>webpack-dev-server</code>，如端口设置、启动 <code>gzip</code> 压缩等，这里简单讲解几个常用的配置</p>\n</blockquote>\n<ul>\n<li><code>public</code>字段用于指定静态服务的域名，默认是 <code>http://localhost:8080/</code> ，当你使用 <code>Nginx</code> 来做反向代理时，应该就需要使用该配置来指定 <code>Nginx</code> 配置使用的服务域名</li>\n<li><code>port</code> 字段用于指定静态服务的端口，如上，默认是 <code>8080</code>，通常情况下都不需要改动</li>\n<li><code>publicPath</code> 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 <code>/</code>，例如，对于一个构建好的文件 <code>bundle.js</code>，完整的访问路径是 <code>http://localhost:8080/bundle.js</code>，如果你配置了 <code>publicPath: 'assets/'</code>，那么上述 <code>bundle.js</code> 的完整访问路径就是 <code>http://localhost:8080/assets/bundle.js</code>。可以使用整个 <code>URL</code> 来作为 <code>publicPath</code>的值，如 <code>publicPath: 'http://localhost:8080/assets/'</code>。如果你使用了 <code>HMR</code>，那么要设置 <code>publicPath</code> 就必须使用完整的 <code>URL</code></li>\n</ul>\n<blockquote>\n<p>建议将 <code>devServer.publicPath</code> 和 <code>output.publicPath</code> 的值保持一致</p>\n</blockquote>\n<ul>\n<li><code>proxy</code>用于配置 <code>webpack-dev-server</code>将特定 <code>URL</code> 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如</li>\n</ul>\n<div><pre><code>proxy<span>:</span> <span>{</span>\n  <span>'/api'</span><span>:</span> <span>{</span>\n    target<span>:</span> <span>\"http://localhost:3000\"</span><span>,</span> <span>// 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上</span>\n    pathRewrite<span>:</span> <span>{</span> <span>'^/api'</span><span>:</span> <span>''</span> <span>}</span><span>,</span> <span>// 把 URL 中 path 部分的 `api` 移除掉</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li><code>before</code> 和 <code>after</code> 配置用于在 <code>webpack-dev-server</code> 定义额外的中间件，如</li>\n</ul>\n<div><pre><code><span>before</span><span>(</span><span>app</span><span>)</span><span>{</span>\n  app<span>.</span><span>get</span><span>(</span><span>'/some/path'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span> <span>// 当访问 /some/path 路径时，返回自定义的 json 数据</span>\n    res<span>.</span><span>json</span><span>(</span><span>{</span> custom<span>:</span> <span>'response'</span> <span>}</span><span>)</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li><code>before</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 <code>mock</code>。</li>\n<li><code>after</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理...</li>\n</ul>\n<h2 id=\"七、开发和生产环境的构建配置差异\"> 七、开发和生产环境的构建配置差异</h2>\n<ul>\n<li>我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 <code>debug</code> 信息，包含<code>sourcemap</code> 文件</li>\n<li>另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 <code>debug</code> 信息，静态文件不包括 <code>sourcemap</code> 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 <code>mock</code> 等工作</li>\n<li><code>webpack 4.x</code> 版本引入了 <code>mode</code> 的概念，在运行 <code>webpack</code> 时需要指定使用 <code>production</code>或 <code>development</code> 两个 <code>mode</code> 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。</li>\n</ul>\n<h3 id=\"_7-1-在配置文件中区分-mode\"> 7.1 在配置文件中区分 mode</h3>\n<blockquote>\n<p>之前我们的配置文件都是直接对外暴露一个 <code>JS</code> 对象，这种方式暂时没有办法获取到 <code>webpack</code> 的 <code>mode</code> 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做</p>\n</blockquote>\n<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>(</span><span>env<span>,</span> argv</span><span>)</span> <span>=></span> <span>(</span><span>{</span>\n  <span>// ... 其他配置</span>\n  optimization<span>:</span> <span>{</span>\n    minimize<span>:</span> <span>false</span><span>,</span>\n    <span>// 使用 argv 来获取 mode 参数的值</span>\n    minimizer<span>:</span> argv<span>.</span>mode <span>===</span> <span>'production'</span> <span>?</span> <span>[</span>\n      <span>new</span> <span>UglifyJsPlugin</span><span>(</span><span>{</span> <span>/* 你自己的配置 */</span> <span>}</span><span>)</span><span>,</span> \n      <span>// 仅在我们要自定义压缩配置时才需要这么做</span>\n      <span>// mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin</span>\n    <span>]</span> <span>:</span> <span>[</span><span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>\n<p>这样获取 <code>mode</code> 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 <code>loader</code>或<code>plugin</code> 做额外的配置就可以了</p>\n</blockquote>\n<ul>\n<li>以上是 <code>webpack 4.x</code> 的做法，由于有了 <code>mode</code> 参数，区分环境变得简单了。不过在当前业界，估计还是使用 <code>webpack 3.x</code> 版本的居多，所以这里也简单介绍一下 <code>3.x</code> 如何区分环境</li>\n</ul>\n<blockquote>\n<p><code>webpack</code> 的运行时环境是<code>Node.js</code>，我们可以通过 <code>Node.js</code>提供的机制给要运行的 <code>webpack</code> 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 <code>npm</code> 中的 <code>scripts</code> 字段添加一个用于生产环境的构建命令...</p>\n</blockquote>\n<div><pre><code><span>{</span>\n  <span>\"scripts\"</span><span>:</span> <span>{</span>\n    <span>\"build\"</span><span>:</span> <span>\"NODE_ENV=production webpack\"</span><span>,</span>\n    <span>\"develop\"</span><span>:</span> <span>\"NODE_ENV=development webpack-dev-server\"</span>\n  <span>}</span>\n<span>}</span>...\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>然后在 <code>webpack.config.js</code> 文件中可以通过 <code>process.env.NODE_ENV</code> 来获取命令传入的环境变量</p>\n</blockquote>\n<div><pre><code><span>const</span> config <span>=</span> <span>{</span>\n  <span>// ... webpack 配置</span>\n<span>}</span>\n\n<span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>===</span> <span>'production'</span><span>)</span> <span>{</span>\n  <span>// 生产环境需要做的事情，如使用代码压缩插件等</span>\n  config<span>.</span>plugins<span>.</span><span>push</span><span>(</span><span>new</span> <span>UglifyJsPlugin</span><span>(</span><span>)</span><span>)</span>\n<span>}</span>\n\nmodule<span>.</span>exports <span>=</span> config<span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_7-2-运行时的环境变量\"> 7.2 运行时的环境变量</h3>\n<blockquote>\n<p>我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 <code>process.env.NODE_ENV</code> 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 <code>debug</code> 信息...</p>\n</blockquote>\n<ul>\n<li>下面这个简单的例子，在应用开发的代码中实现一个简单的 <code>console</code>打印封装</li>\n</ul>\n<div><pre><code><span>export</span> <span>default</span> <span>function</span> <span>log</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>===</span> <span>'development'</span> <span>&amp;&amp;</span> console <span>&amp;&amp;</span> console<span>.</span>log<span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>.</span><span>apply</span><span>(</span>console<span>,</span> args<span>)</span>\n  <span>}</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>同样，以上是 <code>webpack 4.x</code> 的做法，下面简单介绍一下 <code>3.x</code> 版本应该如何实现。这里需要用到 <code>DefinePlugin</code> 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 <code>webpack 3.x</code> 版本区分构建环境的例子的基础上，再使用 <code>DefinePlugin</code> 添加环境变量即可影响到运行时的代码...</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  <span>// webpack 的配置</span>\n\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>// webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的</span>\n      <span>'process.env.NODE_ENV'</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span><span>)</span><span>,</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_7-3-常见的环境差异配置\"> 7.3 常见的环境差异配置</h3>\n<p><strong>常见的 webpack 构建差异配置：</strong></p>\n<ul>\n<li>生产环境可能需要分离 <code>CSS</code>成单独的文件，以便多个页面共享同一个 <code>CSS</code> 文件</li>\n<li>生产环境需要压缩 <code>HTML/CSS/JS</code> 代码</li>\n<li>生产环境需要压缩图片</li>\n<li>开发环境需要生成 <code>sourcemap</code> 文件</li>\n<li>开发环境需要打印 <code>debug</code> 信息</li>\n<li>开发环境需要 <code>live reload</code>或者 <code>hot reload</code> 的功能...</li>\n</ul>\n<blockquote>\n<p><code>webpack 4.x</code> 的 <code>mode</code> 已经提供了上述差异配置的大部分功能，<code>mode</code> 为 <code>production</code> 时默认使用 <code>JS</code> 代码压缩，而<code>mode</code> 为 <code>development</code> 时默认启用 <code>hot</code> <code>reload</code>，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 <code>loader</code> 和 <code>plugin</code> 做区分配置就可以了...</p>\n</blockquote>\n<ul>\n<li><code>webpack 3.x</code> 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 <code>webpack 4.x</code>版本</li>\n</ul>\n<h3 id=\"_7-4-拆分配置\"> 7.4 拆分配置</h3>\n<blockquote>\n<p>前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 <code>webpack</code> 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 <code>webpack</code> 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下...</p>\n</blockquote>\n<ul>\n<li><code>webpack.base.js</code>：基础部分，即多个文件中共享的配置</li>\n<li><code>webpack.development.js</code>：开发环境使用的配置</li>\n<li><code>webpack.production.js</code>：生产环境使用的配置</li>\n<li><code>webpack.test.js</code>：测试环境使用的配置...</li>\n</ul>\n<p><strong>如何处理这样的配置拆分：</strong></p>\n<blockquote>\n<p>首先我们要明白，对于 <code>webpack</code> 的配置，其实是对外暴露一个 <code>JS</code> 对象，所以对于这个对象，我们都可以用 <code>JS</code> 代码来修改它，例如</p>\n</blockquote>\n<div><pre><code><span>const</span> config <span>=</span> <span>{</span>\n  <span>// ... webpack 配置</span>\n<span>}</span>\n\n<span>// 我们可以修改这个 config 来调整配置，例如添加一个新的插件</span>\nconfig<span>.</span>plugins<span>.</span><span>push</span><span>(</span><span>new</span> <span>YourPlugin</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\nmodule<span>.</span>exports <span>=</span> config<span>;</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 <code>webpack-merge</code></p>\n</blockquote>\n<ul>\n<li>我们的 webpack 配置基础部分，即 <code>webpack.base.js</code> 应该大致是这样的</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'...'</span><span>,</span>\n  output<span>:</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span><span>,</span>\n  resolve<span>:</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span><span>,</span>\n  module<span>:</span> <span>{</span>\n    <span>// 这里是一个简单的例子，后面介绍 API 时会用到</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span> \n        use<span>:</span> <span>[</span><span>'babel'</span><span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n    <span>// ...</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// ...</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>\n<p>然后 <code>webpack.development.js</code> 需要添加 <code>loader</code> 或 <code>plugin</code>，就可以使用 <code>webpack-merge</code>的 <code>API</code>，例如</p>\n</blockquote>\n<div><pre><code><span>const</span> <span>{</span> smart <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> base <span>=</span> <span>require</span><span>(</span><span>'./webpack.base.js'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>smart</span><span>(</span>base<span>,</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理</span>\n      <span>// 和上述 base 配置合并后，这里会是 { test: /\\.js$/, use: ['babel', 'coffee'] }</span>\n      <span>// 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.js$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span><span>'coffee'</span><span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>// ...</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// plugins 这里的数组会和 base 中的 plugins 数组进行合并</span>\n    <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n      <span>'process.env.NODE_ENV'</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span><span>)</span><span>,</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>)</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><blockquote>\n<p>可见 <code>webpack-merge</code> 提供的 <code>smart</code> 方法，可以帮助我们更加轻松地处理 <code>loader</code> 配置的合并。<code>webpack-merge</code> 还有其他 <code>API</code> 可以用于自定义合并行为 <a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/survivejs/webpack-merge</a></p>\n</blockquote>\n<h3 id=\"_7-5-完整代码\"> 7.5 完整代码</h3>\n<blockquote>\n<p>webpack.config.js</p>\n</blockquote>\n<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span><span>(</span><span>env<span>,</span> argv</span><span>)</span> <span>{</span>\n  <span>return</span> argv<span>.</span>mode <span>===</span> <span>'production'</span> <span>?</span>\n    <span>require</span><span>(</span><span>'./configs/webpack.production'</span><span>)</span> <span>:</span>\n    <span>require</span><span>(</span><span>'./configs/webpack.development'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>configs/webpack.base.js</p>\n</blockquote>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'./src/index.js'</span><span>,</span>\n\n  output<span>:</span> <span>{</span>\n    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../dist'</span><span>)</span><span>,</span>\n    filename<span>:</span> <span>'[name].js'</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'../src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>'babel-loader'</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'file-loader'</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 配置输出文件名和路径</span>\n      template<span>:</span> <span>'src/index.html'</span><span>,</span> <span>// 配置文件模板</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><blockquote>\n<p>configs/webpack.development.js</p>\n</blockquote>\n<div><pre><code><span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> merge <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> baseConfig <span>=</span> <span>require</span><span>(</span><span>'./webpack.base'</span><span>)</span>\n\n<span>const</span> config <span>=</span> merge<span>.</span><span>smart</span><span>(</span>baseConfig<span>,</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        enforce<span>:</span> <span>'pre'</span><span>,</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?$</span><span>/</span></span><span>,</span>\n        exclude<span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span><span>,</span>\n        loader<span>:</span> <span>\"eslint-loader\"</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>'style-loader'</span><span>,</span>\n          <span>'css-loader'</span><span>,</span>\n          <span>'less-loader'</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  devServer<span>:</span> <span>{</span>\n    port<span>:</span> <span>'1234'</span><span>,</span>\n    <span>before</span><span>(</span><span>app</span><span>)</span><span>{</span>\n      app<span>.</span><span>get</span><span>(</span><span>'/api/test.json'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>\n        res<span>.</span><span>json</span><span>(</span><span>{</span> code<span>:</span> <span>200</span><span>,</span> message<span>:</span> <span>'hello world'</span> <span>}</span><span>)</span>\n      <span>}</span><span>)</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>)</span>\n\nconfig<span>.</span>plugins<span>.</span><span>push</span><span>(</span>\n  <span>new</span> <span>webpack<span>.</span>DefinePlugin</span><span>(</span><span>{</span>\n    __DEV__<span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>true</span><span>)</span><span>,</span>\n  <span>}</span><span>)</span>\n<span>)</span>\n\nmodule<span>.</span>exports <span>=</span> config\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><blockquote>\n<p>configs/webpack.production.js</p>\n</blockquote>\n<div><pre><code><span>const</span> merge <span>=</span> <span>require</span><span>(</span><span>'webpack-merge'</span><span>)</span>\n<span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>\n<span>const</span> baseConfig <span>=</span> <span>require</span><span>(</span><span>'./webpack.base'</span><span>)</span>\n\n<span>const</span> config <span>=</span> merge<span>.</span><span>smart</span><span>(</span>baseConfig<span>,</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span>\n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>[</span>\n            <span>{</span>\n              loader<span>:</span> <span>'css-loader'</span><span>,</span>\n              options<span>:</span> <span>{</span>\n                minimize<span>:</span> <span>true</span>\n              <span>}</span>\n            <span>}</span><span>,</span>\n            <span>'less-loader'</span><span>,</span>\n          <span>]</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span>\n<span>}</span><span>)</span>\n\nconfig<span>.</span>plugins<span>.</span><span>push</span><span>(</span><span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'[name].css'</span><span>)</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> config\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id=\"八、模块热替换提高开发效率\"> 八、模块热替换提高开发效率</h2>\n<blockquote>\n<p><code>HMR</code> 全称是 <code>Hot Module Replacement</code>，即模块热替换。在这个概念出来之前，我们使用过 <code>Hot Reloading</code>，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 <code>Hot Reloading</code>，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，<code>HMR</code> 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率...</p>\n</blockquote>\n<h3 id=\"_8-1-配置使用-hmr\"> 8.1 配置使用 HMR</h3>\n<blockquote>\n<p><code>HMR</code> 是 <code>webpack</code> 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 <code>webpack-dev-server</code>， 添加一些简单的配置，即在<code>webpack</code> 的配置文件中添加启用<code>HMR</code>需要的两个插件</p>\n</blockquote>\n<div><pre><code><span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  devServer<span>:</span> <span>{</span>\n    hot<span>:</span> <span>true</span> <span>// dev server 的配置要启动 hot，或者在命令行中带参数开启</span>\n  <span>}</span><span>,</span>\n  plugins<span>:</span> <span>[</span>\n    <span>// ...</span>\n    <span>new</span> <span>webpack<span>.</span>NamedModulesPlugin</span><span>(</span><span>)</span><span>,</span> <span>// 用于启动 HMR 时可以显示模块的相对路径</span>\n    <span>new</span> <span>webpack<span>.</span>HotModuleReplacementPlugin</span><span>(</span><span>)</span><span>,</span> <span>// Hot Module Replacement 的插件</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_8-2-module-hot-常见的-api\"> 8.2 module.hot 常见的 API</h3>\n<blockquote>\n<p>前面 <code>HMR</code>实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 <code>module.hot</code> <code>API</code> 有哪些，以及如何使用</p>\n</blockquote>\n<ul>\n<li><code>module.hot.accept</code> 方法指定在应用特定代码模块更新时执行相应的 <code>callback</code>，第一个参数可以是字符串或者数组，如</li>\n</ul>\n<div><pre><code><span>if</span> <span>(</span>module<span>.</span>hot<span>)</span> <span>{</span>\n  module<span>.</span>hot<span>.</span><span>accept</span><span>(</span><span>[</span><span>'./bar.js'</span><span>,</span> <span>'./index.css'</span><span>]</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>// ... 这样当 bar.js 或者 index.css 更新时都会执行该函数</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li><code>module.hot.decline</code> 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 <code>module.hot.decline('./bar.js')</code>。这个方法比较少用到</li>\n<li><code>module.hot.dispose</code> 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如</li>\n</ul>\n<div><pre><code><span>if</span> <span>(</span>module<span>.</span>hot<span>)</span> <span>{</span>\n  module<span>.</span>hot<span>.</span><span>dispose</span><span>(</span><span>(</span><span>data</span><span>)</span> <span>=></span> <span>{</span>\n    <span>// data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取</span>\n  <span>}</span><span>)</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li><code>module.hot.accept</code> 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 <code>module.hot.dispose</code> 会更加容易方便</li>\n<li><code>module.hot.removeDisposeHandler</code>用于移除 <code>dispose</code> 方法添加的 <code>callback</code></li>\n</ul>\n<h2 id=\"九、图片加载优化\"> 九、图片加载优化</h2>\n<h3 id=\"_9-1-css-sprites\"> 9.1 CSS Sprites</h3>\n<ul>\n<li>如果你使用的 <code>webpack 3.x</code> 版本，需要 <code>CSS Sprites</code> 的话，可以使用 <code>webpack-spritesmith</code> 或者 <code>sprite-webpack-plugin</code>。</li>\n<li>我们以 <code>webpack-spritesmith</code> 为例，先安装依赖...</li>\n</ul>\n<div><pre><code>module<span>:</span> <span>{</span>\n  loaders<span>:</span> <span>[</span>\n    <span>// ... 这里需要有处理图片的 loader，如 file-loader</span>\n  <span>]</span>\n<span>}</span><span>,</span>\nresolve<span>:</span> <span>{</span>\n  modules<span>:</span> <span>[</span>\n    <span>'node_modules'</span><span>,</span> \n    <span>'spritesmith-generated'</span><span>,</span> <span>// webpack-spritesmith 生成所需文件的目录</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>,</span>\nplugins<span>:</span> <span>[</span>\n  <span>new</span> <span>SpritesmithPlugin</span><span>(</span><span>{</span>\n    src<span>:</span> <span>{</span>\n      cwd<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/ico'</span><span>)</span><span>,</span> <span>// 多个图片所在的目录</span>\n      glob<span>:</span> <span>'*.png'</span> <span>// 匹配图片的路径</span>\n    <span>}</span><span>,</span>\n    target<span>:</span> <span>{</span>\n      <span>// 生成最终图片的路径</span>\n      image<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/spritesmith-generated/sprite.png'</span><span>)</span><span>,</span> \n      <span>// 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子</span>\n      css<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src/spritesmith-generated/sprite.styl'</span><span>)</span><span>,</span> \n    <span>}</span><span>,</span>\n    apiOptions<span>:</span> <span>{</span>\n      cssImageRef<span>:</span> <span>\"~sprite.png\"</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>)</span><span>,</span>\n<span>]</span><span>,</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>\n<p>在你需要的样式代码中引入 <code>sprite.styl</code> 后调用需要的<code>mixins</code> 即可</p>\n</blockquote>\n<div><pre><code><span>@import</span> <span>'~sprite.styl'</span>\n\n.close<span>-</span>button\n    <span>sprite</span><span>(</span>$close<span>)</span>\n.open<span>-</span>button\n    <span>sprite</span><span>(</span>$open<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>如果你使用的是 <code>webpack 4.x</code>，你需要配合使用 <code>postcss</code>和 <code>postcss-sprites</code>，才能实现 <code>CSS Sprites</code> 的相关构建</p>\n</blockquote>\n<h3 id=\"_9-2-图片压缩\"> 9.2 图片压缩</h3>\n<ul>\n<li>在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了</li>\n<li>我们之前提及使用<code>file-loader</code> 来处理图片文件，在此基础上，我们再添加一个 <code>image-webpack-loader</code>来压缩图片文件。简单的配置如下...</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>.*\\.(gif|png|jpe?g|svg|webp)$</span><span>/</span><span>i</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'file-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span><span>}</span>\n          <span>}</span><span>,</span>\n          <span>{</span>\n            loader<span>:</span> <span>'image-webpack-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span>\n              mozjpeg<span>:</span> <span>{</span> <span>// 压缩 jpeg 的配置</span>\n                progressive<span>:</span> <span>true</span><span>,</span>\n                quality<span>:</span> <span>65</span>\n              <span>}</span><span>,</span>\n              optipng<span>:</span> <span>{</span> <span>// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span>\n                enabled<span>:</span> <span>false</span><span>,</span>\n              <span>}</span><span>,</span>\n              pngquant<span>:</span> <span>{</span> <span>// 使用 imagemin-pngquant 压缩 png</span>\n                quality<span>:</span> <span>'65-90'</span><span>,</span>\n                speed<span>:</span> <span>4</span>\n              <span>}</span><span>,</span>\n              gifsicle<span>:</span> <span>{</span> <span>// 压缩 gif 的配置</span>\n                interlaced<span>:</span> <span>false</span><span>,</span>\n              <span>}</span><span>,</span>\n              webp<span>:</span> <span>{</span> <span>// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span>\n                quality<span>:</span> <span>75</span>\n              <span>}</span><span>,</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id=\"_9-3-使用-dataurl\"> 9.3 使用 DataURL</h3>\n<blockquote>\n<p>有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 <code>CSS Sprites</code> 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 <code>url-loader</code> 来处理这些很小的图片...</p>\n</blockquote>\n<ul>\n<li><code>url-loader</code> 和 <code>file-loader</code> 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，<code>url-loader</code> 会将其转换为一个 <code>base64</code> 编码的 <code>DataURL</code>，配置如下</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'url-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span>\n              limit<span>:</span> <span>8192</span><span>,</span> <span>// 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理</span>\n            <span>}</span><span>,</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_9-4-代码压缩\"> 9.4 代码压缩</h3>\n<ul>\n<li><code>webpack 4.x</code> 版本运行时，<code>mode</code> 为 <code>production</code> 即会启动压缩 <code>JS</code> 代码的插件，而对于 <code>webpack</code> <code>3.x</code>，使用压缩 <code>JS</code> 代码插件的方式也已经介绍过了。在生产环境中，压缩 <code>JS</code> 代码基本是一个必不可少的步骤，这样可以大大减小 <code>JavaScript</code> 的体积，相关内容这里不再赘述。</li>\n<li>除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。</li>\n<li>对于 HTML 文件，之前介绍的 <code>html-webpack-plugin</code> 插件可以帮助我们生成需要的 HTML 并对其进行压缩...</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 配置输出文件名和路径</span>\n      template<span>:</span> <span>'assets/index.html'</span><span>,</span> <span>// 配置文件模板</span>\n      minify<span>:</span> <span>{</span> <span>// 压缩 HTML 的配置</span>\n        minifyCSS<span>:</span> <span>true</span><span>,</span> <span>// 压缩 HTML 中出现的 CSS 代码</span>\n        minifyJS<span>:</span> <span>true</span> <span>// 压缩 HTML 中出现的 JS 代码</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>\n<li>如上，使用 <code>minify</code> 字段配置就可以使用 <code>HTML</code> 压缩，这个插件是使用 <code>html-minifier</code> 来实现<code>HTML</code> 代码压缩的，<code>minify</code>下的配置项直接透传给 <code>html-minifier</code>，配置项参考 <code>html-minifier</code> 文档即可。</li>\n<li>对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 <code>css-loader</code>，也提供了压缩 CSS 代码的功能：...</li>\n</ul>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>// ...</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.css</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>'style-loader'</span><span>,</span>\n          <span>{</span>\n            loader<span>:</span> <span>'css-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span>\n              minimize<span>:</span> <span>true</span><span>,</span> <span>// 使用 css 的压缩功能</span>\n            <span>}</span><span>,</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>\n<p>在 <code>css-loader</code> 的选项中配置 <code>minimize</code> 字段为 <code>true</code>来使用<code>CSS</code> 压缩代码的功能。<code>css-loader</code> 是使用 <code>cssnano</code>来压缩代码的，<code>minimize</code> 字段也可以配置为一个对象，来将相关配置传递给 <code>cssnano</code>...</p>\n</blockquote>\n<h2 id=\"十、分离代码文件\"> 十、分离代码文件</h2>\n<ul>\n<li>关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 <code>webpack</code> 中使用 <code>extract-text-webpack-plugin</code> 插件即可。</li>\n<li>先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。</li>\n<li>假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。</li>\n<li>还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观...</li>\n</ul>\n<blockquote>\n<p><code>3.x</code> 以前的版本是使用 <code>CommonsChunkPlugin</code> 来做代码分离的，而 <code>webpack 4.x</code> 则是把相关的功能包到了<code>optimize.splitChunks</code> 中，直接使用该配置就可以实现代码分离。</p>\n</blockquote>\n<h3 id=\"_10-1-webpack-4-x-的-optimization\"> 10.1 webpack 4.x 的 optimization</h3>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ... webpack 配置</span>\n\n  optimization<span>:</span> <span>{</span>\n    splitChunks<span>:</span> <span>{</span>\n      chunks<span>:</span> <span>\"all\"</span><span>,</span> <span>// 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 <code>commons.js</code> 需要在入口代码之前。下面是个简单的例子</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>commons.js<span>\"</span></span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>entry.bundle.js<span>\"</span></span> <span>charset</span><span><span>=</span><span>\"</span>utf-8<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>如果你使用了 <code>html-webpack-plugin</code>，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 <code>stats</code> 的 <code>entrypoints</code> 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息...</p>\n</blockquote>\n<p><strong>显式配置共享类库可以这么操作：</strong></p>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    vendor<span>:</span> <span>[</span><span>\"react\"</span><span>,</span> <span>\"lodash\"</span><span>,</span> <span>\"angular\"</span><span>,</span> <span>...</span><span>]</span><span>,</span> <span>// 指定公共使用的第三方类库</span>\n  <span>}</span><span>,</span>\n  optimization<span>:</span> <span>{</span>\n    splitChunks<span>:</span> <span>{</span>\n      cacheGroups<span>:</span> <span>{</span>\n        vendor<span>:</span> <span>{</span>\n          chunks<span>:</span> <span>\"initial\"</span><span>,</span>\n          test<span>:</span> <span>\"vendor\"</span><span>,</span>\n          name<span>:</span> <span>\"vendor\"</span><span>,</span> <span>// 使用 vendor 入口作为公共部分</span>\n          enforce<span>:</span> <span>true</span><span>,</span>\n        <span>}</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n  <span>// ... 其他配置</span>\n<span>}</span>\n\n<span>// 或者</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  optimization<span>:</span> <span>{</span>\n    splitChunks<span>:</span> <span>{</span>\n      cacheGroups<span>:</span> <span>{</span>\n        vendor<span>:</span> <span>{</span>\n          test<span>:</span> <span><span>/</span><span>react|angluar|lodash</span><span>/</span></span><span>,</span> <span>// 直接使用 test 来做路径匹配</span>\n          chunks<span>:</span> <span>\"initial\"</span><span>,</span>\n          name<span>:</span> <span>\"vendor\"</span><span>,</span>\n          enforce<span>:</span> <span>true</span><span>,</span>\n        <span>}</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span>\n\n<span>// 或者</span>\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  optimization<span>:</span> <span>{</span>\n    splitChunks<span>:</span> <span>{</span>\n      cacheGroups<span>:</span> <span>{</span>\n        vendor<span>:</span> <span>{</span>\n          chunks<span>:</span> <span>\"initial\"</span><span>,</span>\n          test<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>\"node_modules\"</span><span>)</span> <span>// 路径在 node_modules 目录下的都作为公共部分</span>\n          name<span>:</span> <span>\"vendor\"</span><span>,</span> <span>// 使用 vendor 入口作为公共部分</span>\n          enforce<span>:</span> <span>true</span><span>,</span>\n        <span>}</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><blockquote>\n<p>上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法..</p>\n</blockquote>\n<h3 id=\"_10-2-webpack-3-x-的-commonschunkplugin\"> 10.2 webpack 3.x 的 CommonsChunkPlugin</h3>\n<blockquote>\n<p><code>webpack 3.x</code>以下的版本需要用到 webpack 自身提供的 <code>CommonsChunkPlugin</code> 插件。我们先来看一个最简单的例子</p>\n</blockquote>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n      name<span>:</span> <span>\"commons\"</span><span>,</span> <span>// 公共使用的 chunk 的名称</span>\n      filename<span>:</span> <span>\"commons.js\"</span><span>,</span> <span>// 公共 chunk 的生成文件名</span>\n      minChunks<span>:</span> <span>3</span><span>,</span> <span>// 公共的部分必须被 3 个 chunk 共享</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>\n<li><code>chunk</code> 在这里是构建的主干，可以简单理解为一个入口对应一个 <code>chunk</code>。</li>\n<li>以上插件配置在构建后会生成一个 <code>commons.js</code> 文件，该文件就是代码中的公共部分。上面的配置中 <code>minChunks</code>字段为 3，该字段的意思是当一个模块被 3 个以上的 <code>chunk</code> 依赖时，这个模块就会被划分到 <code>commons chunk</code> 中去。单从这个配置的角度上讲，这种方式并没有 <code>4.x</code> 的 <code>chunks: &quot;all&quot;</code>那么方便。</li>\n</ul>\n<p><strong>CommonsChunkPlugin 也是支持显式配置共享类库的：</strong></p>\n<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>{</span>\n    vendor<span>:</span> <span>[</span><span>'react'</span><span>,</span> <span>'react-redux'</span><span>]</span><span>,</span> <span>// 指定公共使用的第三方类库</span>\n    app<span>:</span> <span>'./src/entry'</span><span>,</span>\n    <span>// ...</span>\n  <span>}</span><span>,</span>\n  <span>// ...</span>\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>webpack<span>.</span>optimize<span>.</span>CommonsChunkPlugin</span><span>(</span><span>{</span>\n      name<span>:</span> <span>'vendor'</span> <span>// 使用 vendor 入口作为公共部分</span>\n      filename<span>:</span> <span>\"vendor.js\"</span><span>,</span> \n      minChunks<span>:</span> <span>Infinity</span><span>,</span> <span>// 这个配置会让 webpack 不再自动抽离公共模块</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n<span>}</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>\n<p>上述配置会生成一个名为 <code>vendor.js</code> 的共享代码文件，里面包含了 <code>React</code> 和<code>React-Redux</code> 库的代码，可以提供给多个不同的入口代码使用。这里的 <code>minChunks</code> 字段的配置，我们使用了 <code>Infinity</code>，可以理解为<code>webpack</code> 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的<code>chunk</code>依赖的模块会和 <code>React</code>、<code>React-Redux</code> 一同打包进 <code>vendor</code>，这样就失去显式指定的意义了。\n<code>minChunks</code>其实还可以是一个函数，如：</p>\n</blockquote>\n<div><pre><code><span>minChunks</span><span>:</span> <span>(</span><span>module<span>,</span> count</span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span>module<span>,</span> count<span>)</span><span>;</span>\n  <span>return</span> <span>true</span><span>;</span>\n<span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 <code>module</code>，以及已经被作为公共模块的数量 <code>count</code>，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：</p>\n</blockquote>\n<div><pre><code><span>minChunks</span><span>:</span> <span>(</span><span>module<span>,</span> count</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> module<span>.</span>context <span>&amp;&amp;</span> module<span>.</span>context<span>.</span><span>includes</span><span>(</span><span>\"node_modules\"</span><span>)</span><span>;</span> \n  <span>// node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, \"node_modules\")</span>\n<span>}</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>更多使用 <code>CommonsChunkPlugin</code>的配置参考官方文档 <code>commons-chunk-plugin</code>。</li>\n</ul>\n<h2 id=\"十一、进一步控制js大小\"> 十一、进一步控制JS大小</h2>\n<h3 id=\"_11-1-按需加载模块\"> 11.1 按需加载模块</h3>\n<blockquote>\n<p>在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 <code>dynamic-import</code> 来编写代码即可，<code>webpack</code> 会自动处理使用该语法编写的模块</p>\n</blockquote>\n<div><pre><code><span>// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象</span>\n<span>// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用</span>\n<span>import</span><span>(</span><span>/* webpackChunkName: \"lodash\" */</span> <span>'lodash'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>_</span><span>)</span> <span>=></span> <span>{</span> \n  console<span>.</span><span>log</span><span>(</span>_<span>.</span><span>lash</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span><span>)</span> <span>// 打印 3</span>\n<span>}</span><span>)</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>注意一下，如果你使用了 <code>Babel</code> 的话，还需要 <code>Syntax Dynamic Import</code> 这个 <code>Babel</code> 插件来处理 <code>import()</code> 这种语法。</li>\n<li>由于动态加载代码模块的语法依赖于 <code>promise</code>，对于低版本的浏览器，需要添加 <code>promise</code> 的 <code>polyfill</code> 后才能使用。</li>\n<li>如上的代码，webpack 构建时会自动把 <code>lodash</code> 模块分离出来，并且在代码内部实现动态加载 <code>lodash</code> 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 <code>promise</code> 来获取动态加载的模块内容。</li>\n<li><code>import</code> 后面的注释 <code>webpackChunkName: &quot;lodash&quot;</code> 用于告知 <code>webpack</code>所要动态加载模块的名称。我们在 webpack 配置中添加一个 <code>output.chunkFilename</code> 的配置...</li>\n</ul>\n<div><pre><code>output<span>:</span> <span>{</span>\n  path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n  filename<span>:</span> <span>'[name].[hash:8].js'</span><span>,</span>\n  chunkFilename<span>:</span> <span>'[name].[hash:8].js'</span> <span>// 指定分离出来的代码文件的名称</span>\n<span>}</span><span>,</span><span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>\n<p>这样就可以把分离出来的文件名称用 lodash 标识了，如下图：</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480597-ae36b6816feed422.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240\" alt=\"image.png\" /></p>\n<blockquote>\n<p>如果没有添加注释 <code>webpackChunkName: &quot;lodash&quot; 以及 output.chunkFilename</code> 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别</p>\n</blockquote>\n<h3 id=\"_11-2-以上完整示例代码\"> 11.2 以上完整示例代码</h3>\n<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>\n<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>'webpack'</span><span>)</span>\n<span>const</span> HtmlWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'html-webpack-plugin'</span><span>)</span>\n<span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>\n\nmodule<span>.</span>exports <span>=</span> <span>{</span>\n  entry<span>:</span> <span>'./src/index.js'</span><span>,</span>\n\n  output<span>:</span> <span>{</span>\n    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'dist'</span><span>)</span><span>,</span>\n    filename<span>:</span> <span>'[name].js'</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  module<span>:</span> <span>{</span>\n    rules<span>:</span> <span>[</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.jsx?</span><span>/</span></span><span>,</span>\n        include<span>:</span> <span>[</span>\n          path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>\n        <span>]</span><span>,</span>\n        use<span>:</span> <span>'babel-loader'</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.less$</span><span>/</span></span><span>,</span>\n        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span>\n          fallback<span>:</span> <span>'style-loader'</span><span>,</span>\n          use<span>:</span> <span>[</span>\n            <span>'css-loader'</span><span>,</span>\n            <span>'postcss-loader'</span><span>,</span>\n            <span>'less-loader'</span><span>,</span>\n          <span>]</span><span>,</span>\n        <span>}</span><span>)</span><span>,</span>\n      <span>}</span><span>,</span>\n      <span>{</span>\n        test<span>:</span> <span><span>/</span><span>\\.(png|jpg|gif)$</span><span>/</span></span><span>,</span>\n        use<span>:</span> <span>[</span>\n          <span>{</span>\n            loader<span>:</span> <span>'url-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span>\n              limit<span>:</span> <span>8192</span>\n            <span>}</span><span>,</span>\n          <span>}</span><span>,</span>\n          <span>{</span>\n            loader<span>:</span> <span>'image-webpack-loader'</span><span>,</span>\n            options<span>:</span> <span>{</span>\n              mozjpeg<span>:</span> <span>{</span> <span>// 压缩 jpeg 的配置</span>\n                progressive<span>:</span> <span>true</span><span>,</span>\n                quality<span>:</span> <span>65</span>\n              <span>}</span><span>,</span>\n              optipng<span>:</span> <span>{</span> <span>// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span>\n                enabled<span>:</span> <span>false</span><span>,</span>\n              <span>}</span><span>,</span>\n              pngquant<span>:</span> <span>{</span> <span>// 使用 imagemin-pngquant 压缩 png</span>\n                quality<span>:</span> <span>'65-90'</span><span>,</span>\n                speed<span>:</span> <span>4</span>\n              <span>}</span><span>,</span>\n              gifsicle<span>:</span> <span>{</span> <span>// 压缩 gif 的配置</span>\n                interlaced<span>:</span> <span>false</span><span>,</span>\n              <span>}</span><span>,</span>\n              webp<span>:</span> <span>{</span> <span>// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span>\n                quality<span>:</span> <span>75</span>\n              <span>}</span><span>,</span>\n            <span>}</span><span>,</span>\n          <span>}</span><span>,</span>\n        <span>]</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>]</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  optimization<span>:</span> <span>{</span>\n    splitChunks<span>:</span> <span>{</span>\n      cacheGroups<span>:</span> <span>{</span>\n        vendor<span>:</span> <span>{</span>\n          chunks<span>:</span> <span>\"initial\"</span><span>,</span>\n          test<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>\"node_modules\"</span><span>)</span><span>,</span> <span>// 路径在 node_modules 目录下的都作为公共部分</span>\n          name<span>:</span> <span>\"vendor\"</span><span>,</span> <span>// 使用 vendor 入口作为公共部分</span>\n          enforce<span>:</span> <span>true</span><span>,</span>\n        <span>}</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n\n  plugins<span>:</span> <span>[</span>\n    <span>new</span> <span>HtmlWebpackPlugin</span><span>(</span><span>{</span>\n      filename<span>:</span> <span>'index.html'</span><span>,</span> <span>// 配置输出文件名和路径</span>\n      template<span>:</span> <span>'src/index.html'</span><span>,</span> <span>// 配置文件模板</span>\n      minify<span>:</span> <span>{</span> <span>// 压缩 HTML 的配置</span>\n        minifyCSS<span>:</span> <span>true</span><span>,</span> <span>// 压缩 HTML 中出现的 CSS 代码</span>\n        minifyJS<span>:</span> <span>true</span><span>,</span> <span>// 压缩 HTML 中出现的 JS 代码</span>\n        removeComments<span>:</span> <span>true</span><span>,</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>)</span><span>,</span>\n    <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>'[name].css'</span><span>)</span><span>,</span>\n    <span>new</span> <span>webpack<span>.</span>NamedModulesPlugin</span><span>(</span><span>)</span><span>,</span>\n    <span>new</span> <span>webpack<span>.</span>HotModuleReplacementPlugin</span><span>(</span><span>)</span><span>,</span>\n  <span>]</span><span>,</span>\n\n  devServer<span>:</span> <span>{</span>\n    hot<span>:</span> <span>true</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br></div></div>",
      "image": "https://i.loli.net/2020/11/29/dfP71Nt8KgFkUqs.png",
      "date_published": "2021-07-30T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.520Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "webpack"
      ]
    },
    {
      "title": "Vue",
      "url": "https://github.com/letme350/vue/vue/",
      "id": "https://github.com/letme350/vue/vue/",
      "content_html": "<h1 id=\"vue\"> Vue</h1>\n<h2 id=\"vue面试\"> Vue面试</h2>\n<h3 id=\"_1-对于mvvm的理解\"> 1 对于MVVM的理解</h3>\n<blockquote>\n<p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p>\n</blockquote>\n<p>MVVM 是 Model-View-ViewModel 的缩写</p>\n<p>Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为</p>\n<p>View: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View</p>\n<p>ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.</p>\n<p>总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。</p>\n<h3 id=\"_2-请详细说下你对vue生命周期的理解\"> 2 请详细说下你对vue生命周期的理解</h3>\n<blockquote>\n<p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p>\n</blockquote>\n<p><strong>生命周期是什么：</strong></p>\n<blockquote>\n<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期</p>\n</blockquote>\n<p><strong>各个生命周期的作用：</strong></p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beforeCreate</td>\n<td>组件实例被创建之初，组件的属性生效之前</td>\n</tr>\n<tr>\n<td>created</td>\n<td>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>\n</tr>\n<tr>\n<td>update</td>\n<td>组件数据更新之后</td>\n</tr>\n<tr>\n<td>activited</td>\n<td>keep-alive专属，组件被激活时调用</td>\n</tr>\n<tr>\n<td>deadctivated</td>\n<td>keep-alive专属，组件被销毁时调用</td>\n</tr>\n<tr>\n<td>beforeDestory</td>\n<td>组件销毁前调用</td>\n</tr>\n<tr>\n<td>destoryed</td>\n<td>组件销毁后调用</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/vue/lifeTime.png\" alt=\"lifeTime\" /></p>\n<blockquote>\n<p>由于Vue会在初始化实例时对属性执行<code>getter/setter</code>转化，所以属性必须在<code>data</code>对象上存在才能让<code>Vue</code>将它转换为响应式的。Vue提供了<code>$set</code>方法用来触发视图更新</p>\n</blockquote>\n<div><pre><code><span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span><span>{</span>\n    <span>return</span> <span>{</span>\n      obj<span>:</span> <span>{</span>\n        name<span>:</span> <span>'fei'</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>mounted</span><span>(</span><span>)</span><span>{</span>\n    <span>this</span><span>.</span><span>$set</span><span>(</span><span>this</span><span>.</span>obj<span>,</span> <span>'sex'</span><span>,</span> <span>'man'</span><span>)</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>什么是vue生命周期？</strong></p>\n<ul>\n<li>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li>\n</ul>\n<p><strong>vue生命周期的作用是什么？</strong></p>\n<ul>\n<li>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</li>\n</ul>\n<p><strong>vue生命周期总共有几个阶段？</strong></p>\n<ul>\n<li>答：它可以总共分为<code>8</code>个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。</li>\n</ul>\n<p><strong>第一次页面加载会触发哪几个钩子？</strong></p>\n<ul>\n<li>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 。</li>\n</ul>\n<p><strong>DOM 渲染在哪个周期中就已经完成？</strong></p>\n<ul>\n<li>答：<code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了</li>\n</ul>\n<h3 id=\"_3-vue实现数据双向绑定的原理-object-defineproperty\"> 3 Vue实现数据双向绑定的原理：Object.defineProperty()</h3>\n<ul>\n<li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 <code>data</code> 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty()</code> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 <code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li>\n<li><strong>vue的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>{{}}</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（<code>input</code>）—&gt;数据<code>model</code>变更双向绑定效果。</strong></li>\n</ul>\n<h3 id=\"_4-vue组件间的参数传递\"> 4 Vue组件间的参数传递</h3>\n<p><strong>父组件与子组件传值：</strong></p>\n<blockquote>\n<p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p>\n</blockquote>\n<ul>\n<li>子组件传给父组件： <code>$emit</code> 方法传递参数</li>\n</ul>\n<p><strong>非父子组件间的数据传递，兄弟组件传值：</strong></p>\n<blockquote>\n<p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用<code>VUEX</code>，具体来说看需求）</p>\n</blockquote>\n<h3 id=\"_5-vue的路由实现-hash模式-和-history模式\"> 5 Vue的路由实现：hash模式 和 history模式</h3>\n<ul>\n<li><code>hash</code>模式：在浏览器中符号<code>“#”</code>，#以及#后面的字符称之为<code>hash</code>，用 <code>window.location.hash</code> 读取。特点：<code>hash</code>虽然在<code>URL</code>中，但不被包括在<code>HTTP</code>请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。</li>\n<li><code>history</code>模式：h<code>istory</code>采用<code>HTML5</code>的新特性；且提供了两个新方法： <code>pushState()</code>， <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更</li>\n</ul>\n<h3 id=\"_5-vue路由的钩子函数\"> 5 vue路由的钩子函数</h3>\n<blockquote>\n<p>首页可以控制导航跳转，<code>beforeEach</code>，<code>afterEach</code>等，一般用于页面<code>title</code>的修改。一些需要登录才能调整页面的重定向功能。</p>\n</blockquote>\n<ul>\n<li><code>beforeEach</code>主要有3个参数<code>to</code>，<code>from</code>，<code>next</code>。</li>\n<li><code>to</code>：<code>route</code>即将进入的目标路由对象。</li>\n<li><code>from</code>：<code>route</code>当前导航正要离开的路由。</li>\n<li><code>next</code>：<code>function</code>一定要调用该方法<code>resolve</code>这个钩子。执行效果依赖n<code>ext</code>方法的调用参数。可以控制网页的跳转</li>\n</ul>\n<h3 id=\"_6-vuex是什么-怎么使用-哪种功能场景使用它\"> 6 vuex是什么？怎么使用？哪种功能场景使用它？</h3>\n<ul>\n<li>只用来读取的状态集中放在<code>store</code>中； 改变状态的方式是提交<code>mutations</code>，这是个同步的事物； 异步逻辑应该封装在<code>action</code>中。</li>\n<li>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>… export</code></li>\n<li><strong>场景有</strong>：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li>\n</ul>\n<p><img src=\"/vue/vue2.png\" alt=\"img\" /></p>\n<ul>\n<li><code>state</code>：<code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个<code>store</code> 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li>\n<li><code>mutations</code>：<code>mutations</code>定义的方法动态修改<code>Vuex</code> 的 <code>store</code> 中的状态或数据</li>\n<li><code>getters</code>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</li>\n<li><code>action</code>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code> 层通过 <code>store.dispath</code> 来分发 <code>action</code></li>\n</ul>\n<p><img src=\"/vue/vue3.png\" alt=\"img\" /></p>\n<blockquote>\n<p><code>modules</code>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理</p>\n</blockquote>\n<p><img src=\"/vue/vue4.png\" alt=\"img\" /></p>\n<h3 id=\"_7-v-if-和-v-show-区别\"> 7 v-if 和 v-show 区别</h3>\n<ul>\n<li>答：<code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code>；</li>\n</ul>\n<h3 id=\"_8-route和-router的区别\"> 8 <code>$route</code>和<code>$router</code>的区别</h3>\n<ul>\n<li><code>$route</code>是“路由信息对象”，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li>\n<li>而<code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等</li>\n</ul>\n<h3 id=\"_9-如何让css只在当前组件中起作用\"> 9 如何让CSS只在当前组件中起作用?</h3>\n<blockquote>\n<p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p>\n</blockquote>\n<h3 id=\"_10-keep-alive-keep-alive-的作用是什么\"> 10 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的作用是什么?</h3>\n<blockquote>\n<p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p>\n</blockquote>\n<ul>\n<li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染</li>\n</ul>\n<blockquote>\n<p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p>\n</blockquote>\n<ul>\n<li>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存</li>\n<li>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态</li>\n</ul>\n<h3 id=\"_11-指令v-el的作用是什么\"> 11 指令v-el的作用是什么?</h3>\n<blockquote>\n<p>提供一个在页面上已存在的 <code>DOM</code>元素作为 <code>Vue</code>实例的挂载目标.可以是 CSS 选择器，也可以是一个 <code>HTMLElement</code> 实例,</p>\n</blockquote>\n<h3 id=\"_12-在vue中使用插件的步骤\"> 12 在Vue中使用插件的步骤</h3>\n<ul>\n<li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li>\n<li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, { someOption: true })</code></li>\n</ul>\n<h3 id=\"_13-请列举出3个vue中常用的生命周期钩子函数\"> 13 请列举出3个Vue中常用的生命周期钩子函数?</h3>\n<ul>\n<li><code>created</code>: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, <code>watch/event</code>事件回调. 然而, 挂载阶段还没有开始, <code>$el</code>属性目前还不可见</li>\n<li><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code>被调用时 <code>vm.$el</code> 也在文档内。</li>\n<li><code>activated</code>: <code>keep-alive</code>组件激活时调用</li>\n</ul>\n<h3 id=\"_14-vue-cli-工程技术集合介绍\"> 14 \bvue-cli 工程技术集合介绍</h3>\n<p><strong>问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</strong></p>\n<ul>\n<li><code>vue.js</code>：<code>vue-cli</code>工程的核心，主要特点是 双向数据绑定 和 组件系统。</li>\n<li><code>vue-router</code>：<code>vue</code>官方推荐使用的路由框架。</li>\n<li><code>vuex</code>：专为 <code>Vue.js</code> 应用项目开发的状态管理器，主要用于维护<code>vue</code>组件间共用的一些 变量 和 方法。</li>\n<li><code>axios</code>（ 或者 <code>fetch</code> 、<code>ajax</code> ）：用于发起 <code>GET</code> 、或 <code>POST</code> 等 <code>http</code>请求，基于 <code>Promise</code> 设计。</li>\n<li><code>vuex</code>等：一个专为<code>vue</code>设计的移动端UI组件库。</li>\n<li>创建一个<code>emit.js</code>文件，用于<code>vue</code>事件机制的管理。</li>\n<li><code>webpack</code>：模块加载和<code>vue-cli</code>工程打包器。</li>\n</ul>\n<p><strong>问题二：vue-cli 工程常用的 npm 命令有哪些？</strong></p>\n<ul>\n<li>下载 <code>node_modules</code> 资源包的命令：</li>\n</ul>\n<div><pre><code><span>npm</span> <span>install</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>启动 <code>vue-cli</code> 开发环境的 npm命令：</li>\n</ul>\n<div><pre><code><span>npm</span> run dev\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>vue-cli</code> 生成 生产环境部署资源 的 <code>npm</code>命令：</li>\n</ul>\n<div><pre><code><span>npm</span> run build\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>用于查看 <code>vue-cli</code> 生产环境部署资源文件大小的 <code>npm</code>命令：</li>\n</ul>\n<div><pre><code><span>npm</span> run build --report\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>在浏览器上自动弹出一个 展示 <code>vue-cli</code> 工程打包后 <code>app.js</code>、<code>manifest.js</code>、<code>vendor.js</code> 文件里面所包含代码的页面。可以具此优化 <code>vue-cli</code> 生产环境部署的静态资源，提升 页面 的加载速度</p>\n</blockquote>\n<h3 id=\"_15-nexttick\"> 15 NextTick</h3>\n<blockquote>\n<p>nextTick<code>可以让我们在下次DOM更新循环结束之后执行延迟回调，用于获得更新后的</code>DOM</p>\n</blockquote>\n<h3 id=\"_16-vue的优点是什么\"> 16 vue的优点是什么？</h3>\n<ul>\n<li>低耦合。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>ViewModel</code>可以绑定到不同的<code>&quot;View&quot;</code>上，当View变化的时候Model可以不变，当<code>Model</code>变化的时候<code>View</code>也可以不变</li>\n<li>可重用性。你可以把一些视图逻辑放在一个<code>ViewModel</code>里面，让很多<code>view</code>重用这段视图逻辑</li>\n<li>可测试。界面素来是比较难于测试的，而现在测试可以针对<code>ViewModel</code>来写</li>\n</ul>\n<h3 id=\"_17-路由之间跳转\"> 17 路由之间跳转？</h3>\n<p><strong>声明式（标签跳转）：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>\"</span>index<span>\"</span></span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>编程式（ js跳转）：</strong></p>\n<div><pre><code>router<span>.</span><span>push</span><span>(</span><span>'index'</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_18-实现-vue-ssr\"> 18 实现 Vue SSR</h3>\n<p><strong>其基本实现原理：</strong></p>\n<ul>\n<li><code>app.js</code> 作为客户端与服务端的公用入口，导出 <code>Vue</code> 根实例，供客户端 <code>entry</code> 与服务端 <code>entry</code> 使用。客户端 <code>entry</code> 主要作用挂载到 <code>DOM</code> 上，服务端 <code>entry</code> 除了创建和返回实例，还进行路由匹配与数据预获取。</li>\n<li><code>webpack</code> 为客服端打包一个 <code>Client Bundle</code> ，为服务端打包一个 <code>Server Bundle</code> 。</li>\n<li>服务器接收请求时，会根据 <code>url</code>，加载相应组件，获取和解析异步数据，创建一个读取 <code>Server Bundle</code> 的 <code>BundleRenderer</code>，然后生成 <code>html</code> 发送给客户端。</li>\n<li>客户端混合，客户端收到从服务端传来的 <code>DOM</code> 与自己的生成的 DOM 进行对比，把不相同的 <code>DOM</code> 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 <code>stroe</code> 里，这样，在客户端挂载到 <code>DOM</code> 之前，可以直接从 <code>store</code>里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__</code>发送到客户端</li>\n</ul>\n<blockquote>\n<p><code>Vue SSR</code> 的实现，主要就是把 <code>Vue</code> 的组件输出成一个完整 <code>HTML</code>, <code>vue-server-renderer</code> 就是干这事的</p>\n</blockquote>\n<ul>\n<li><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至 <code>HTML</code>、客户端混合（<code>hydration</code>）、缓存等等。 相比于其他模板引擎（<code>ejs</code>, <code>jade</code> 等），最终要实现的目的是一样的，性能上可能要差点</li>\n</ul>\n<h3 id=\"_19-vue-组件-data-为什么必须是函数\"> 19 Vue 组件 data 为什么必须是函数</h3>\n<ul>\n<li>每个组件都是 <code>Vue</code> 的实例。</li>\n<li>组件共享 <code>data</code> 属性，当 <code>data</code> 的值是同一个引用类型的值时，改变其中一个会影响其他</li>\n</ul>\n<h3 id=\"_20-vue-computed-实现\"> 20 Vue computed 实现</h3>\n<ul>\n<li>建立与其他属性（如：<code>data</code>、 <code>Store</code>）的联系；</li>\n<li>属性改变后，通知计算属性重新计算</li>\n</ul>\n<blockquote>\n<p>实现时，主要如下</p>\n</blockquote>\n<ul>\n<li>初始化 <code>data</code>， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li>\n<li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 <code>computed</code> 属性都是一个 <code>watch</code> 实例。每个属性提供的函数作为属性的 <code>getter</code>，使用 <code>Object.defineProperty</code> 转化。</li>\n<li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li>\n<li>若出现当前 <code>computed</code> 计算属性嵌套其他 <code>computed</code> 计算属性时，先进行其他的依赖收集</li>\n</ul>\n<h3 id=\"_21-vue-complier-实现\"> 21 Vue complier 实现</h3>\n<ul>\n<li>模板解析这种事，本质是将数据转化为一段 <code>html</code> ，最开始出现在后端，经过各种处理吐给前端。随着各种 <code>mv*</code> 的兴起，模板解析交由前端处理。</li>\n<li>总的来说，<code>Vue complier</code> 是将 <code>template</code> 转化成一个 <code>render</code> 字符串。</li>\n</ul>\n<blockquote>\n<p>可以简单理解成以下步骤：</p>\n</blockquote>\n<ul>\n<li><code>parse</code> 过程，将 <code>template</code> 利用正则转化成<code>AST</code> 抽象语法树。</li>\n<li><code>optimize</code> 过程，标记静态节点，后 <code>diff</code> 过程跳过静态节点，提升性能。</li>\n<li><code>generate</code> 过程，生成 <code>render</code> 字符串</li>\n</ul>\n<h3 id=\"_22-怎么快速定位哪个组件出现性能问题\"> 22 怎么快速定位哪个组件出现性能问题</h3>\n<blockquote>\n<p>用 <code>timeline</code> 工具。 大意是通过 <code>timeline</code> 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p>\n</blockquote>\n<h3 id=\"_23-开发中常用的指令有哪些\"> 23 开发中常用的指令有哪些</h3>\n<ul>\n<li><code>v-model</code> :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定</li>\n<li><code>v-html</code>: 更新元素的 <code>innerHTML</code></li>\n<li><code>v-show</code> 与 <code>v-if</code>: 条件渲染, 注意二者区别</li>\n</ul>\n<blockquote>\n<p>使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏</p>\n</blockquote>\n<ul>\n<li><code>v-on</code> : <code>click</code>: 可以简写为<code>@click</code>,<code>@</code>绑定一个事件。如果事件触发了，就可以指定事件的处理函数</li>\n<li><code>v-for</code>:基于源数据多次渲染元素或模板块</li>\n<li><code>v-bind</code>: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 <code>DOM</code></li>\n</ul>\n<blockquote>\n<p>语法：<code>v-bind:title=&quot;msg&quot;</code>简写：<code>:title=&quot;msg&quot;</code></p>\n</blockquote>\n<h3 id=\"_24-proxy-相比于-defineproperty-的优势\"> 24 Proxy 相比于 defineProperty 的优势</h3>\n<blockquote>\n<p>Object.defineProperty() 的问题主要有三个：</p>\n</blockquote>\n<ul>\n<li>不能监听数组的变化</li>\n<li>必须遍历对象的每个属性</li>\n<li>必须深层遍历嵌套的对象</li>\n</ul>\n<blockquote>\n<p>Proxy 在 ES2015 规范中被正式加入，它有以下几个特点</p>\n</blockquote>\n<ul>\n<li>针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题</li>\n<li>支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。</li>\n</ul>\n<blockquote>\n<p>除了上述两点之外，Proxy 还拥有以下优势：</p>\n</blockquote>\n<ul>\n<li>Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富</li>\n<li>Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。</li>\n</ul>\n<h3 id=\"_25-vue-router-有哪几种导航守卫\"> 25 vue-router 有哪几种导航守卫?</h3>\n<ul>\n<li>全局守卫</li>\n<li>路由独享守卫</li>\n<li>路由组件内的守卫</li>\n</ul>\n<p><strong>全局守卫：</strong></p>\n<blockquote>\n<p>vue-router全局有三个守卫</p>\n</blockquote>\n<ul>\n<li><code>router.beforeEach</code> 全局前置守卫 进入路由之前</li>\n<li><code>router.beforeResolve</code> 全局解析守卫(2.5.0+) 在<code>beforeRouteEnter</code>调用之后调用</li>\n<li><code>router.afterEach</code> 全局后置钩子 进入路由之后</li>\n</ul>\n<div><pre><code><span>// main.js 入口文件</span>\n<span>import</span> router <span>from</span> <span>'./router'</span><span>;</span> <span>// 引入路由</span>\nrouter<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span> \n  <span>next</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\nrouter<span>.</span><span>beforeResolve</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>\n  <span>next</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\nrouter<span>.</span><span>afterEach</span><span>(</span><span>(</span><span>to<span>,</span> <span>from</span></span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'afterEach 全局后置钩子'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>路由独享守卫：</strong></p>\n<blockquote>\n<p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫</p>\n</blockquote>\n<div><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>\n  routes<span>:</span> <span>[</span>\n    <span>{</span>\n      path<span>:</span> <span>'/foo'</span><span>,</span>\n      component<span>:</span> Foo<span>,</span>\n      <span>beforeEnter</span><span>:</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span> \n        <span>// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span>\n        <span>// ...</span>\n      <span>}</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>路由组件内的守卫：</strong></p>\n<ul>\n<li>beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建</li>\n<li>beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this</li>\n<li>beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this</li>\n</ul>\n<h3 id=\"_26-组件之间的传值通信\"> 26 组件之间的传值通信</h3>\n<blockquote>\n<p>组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯</p>\n</blockquote>\n<p><strong>1. 父组件给子组件传值：</strong></p>\n<ul>\n<li>使用<code>props</code>，父组件可以使用<code>props</code>向子组件传递数据。</li>\n<li>父组件<code>vue</code>模板<code>father.vue</code>:</li>\n</ul>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>child</span> <span>:msg</span><span><span>=</span><span>\"</span>message<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>child</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> child <span>from</span> <span>'./child.vue'</span><span>;</span>\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    child\n  <span>}</span><span>,</span>\n  <span>data</span> <span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n        message<span>:</span> <span>'father message'</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>\n<p>子组件vue模板child.vue:</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>{{msg}}<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  props<span>:</span> <span>{</span>\n    msg<span>:</span> <span>{</span>\n      type<span>:</span> String<span>,</span>\n      required<span>:</span> <span>true</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>2. 子组件向父组件通信：</strong></p>\n<blockquote>\n<p>父组件向子组件传递事件方法，子组件通过<code>$emit</code>触发事件，回调给父组件</p>\n</blockquote>\n<p>父组件vue模板father.vue:</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>child</span> <span>@msgFunc</span><span><span>=</span><span>\"</span>func<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>child</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> child <span>from</span> <span>'./child.vue'</span><span>;</span>\n<span>export</span> <span>default</span> <span>{</span>\n  components<span>:</span> <span>{</span>\n    child\n  <span>}</span><span>,</span>\n  methods<span>:</span> <span>{</span>\n    <span>func</span> <span>(</span><span>msg</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span>msg<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>\n<p>子组件vue模板child.vue:</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>handleClick<span>\"</span></span><span>></span></span>点我<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  props<span>:</span> <span>{</span>\n    msg<span>:</span> <span>{</span>\n      type<span>:</span> String<span>,</span>\n      required<span>:</span> <span>true</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>methods</span> <span>(</span><span>)</span> <span>{</span>\n    <span>handleClick</span> <span>(</span><span>)</span> <span>{</span>\n      <span>//........</span>\n      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'msgFunc'</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>3. 非父子, 兄弟组件之间通信：</strong></p>\n<blockquote>\n<p>vue2中废弃了broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。Bus.js可以是这样:</p>\n</blockquote>\n<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>\n<span>export</span> <span>default</span> <span>new</span> <span>Vue</span><span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>在需要通信的组件都引入Bus.js:</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>\"</span>toBus<span>\"</span></span><span>></span></span>子组件传给兄弟组件<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>import</span> Bus <span>from</span> <span>'../common/js/bus.js'</span>\n<span>export</span> <span>default</span><span>{</span>\n  methods<span>:</span> <span>{</span>\n    <span>toBus</span> <span>(</span><span>)</span> <span>{</span>\n      Bus<span>.</span><span>$emit</span><span>(</span><span>'on'</span><span>,</span> <span>'来自兄弟组件'</span><span>)</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>\n<p>另一个组件也import Bus.js 在钩子函数中监听on事件</p>\n</blockquote>\n<div><pre><code><span>import</span> Bus <span>from</span> <span>'../common/js/bus.js'</span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>{</span>\n      message<span>:</span> <span>''</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  <span>mounted</span><span>(</span><span>)</span> <span>{</span>\n    Bus<span>.</span><span>$on</span><span>(</span><span>'on'</span><span>,</span> <span>(</span><span>msg</span><span>)</span> <span>=></span> <span>{</span>\n      <span>this</span><span>.</span>message <span>=</span> msg\n    <span>}</span><span>)</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_27-vue与angular以及react的区别\"> 27 Vue与Angular以及React的区别？</h3>\n<p><strong>Vue与AngularJS的区别：</strong></p>\n<ul>\n<li>Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript</li>\n<li>AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li>\n<li>AngularJS社区完善, Vue的学习成本较小</li>\n</ul>\n<p><strong>Vue与React的区别：</strong></p>\n<ul>\n<li>vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；</li>\n<li>props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；</li>\n<li>子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；</li>\n<li>每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；</li>\n<li>使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；</li>\n<li>多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；</li>\n<li>Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；</li>\n<li>react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</li>\n<li>react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。</li>\n<li>react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin</li>\n</ul>\n<h3 id=\"_28-vuex是什么-怎么使用-哪种功能场景使用它\"> 28 vuex是什么？怎么使用？哪种功能场景使用它？</h3>\n<ul>\n<li>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</li>\n<li>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</li>\n<li>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li>\n</ul>\n<blockquote>\n<p>vuex的使用借助官方提供的一张图来说明:</p>\n</blockquote>\n<p><img src=\"/vue/vue5.png\" alt=\"img\" /></p>\n<blockquote>\n<p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p>\n</blockquote>\n<p><strong>state：</strong></p>\n<blockquote>\n<p><code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p>\n</blockquote>\n<p><strong>mutations：</strong></p>\n<blockquote>\n<p><code>mutations</code>定义的方法动态修改Vuex 的 store 中的状态或数据。</p>\n</blockquote>\n<p><strong>getters：</strong></p>\n<blockquote>\n<p>类似vue的计算属性，主要用来过滤一些数据</p>\n</blockquote>\n<p><strong>action：</strong></p>\n<ul>\n<li>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li>\n<li>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。</li>\n<li>使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题</li>\n<li>vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 1、组件之间全局共享的数据 2、通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态</li>\n</ul>\n<blockquote>\n<p>一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题：</p>\n</blockquote>\n<ul>\n<li>开发时，改变数组或者对象的数据，但是页面没有更新如何解决？</li>\n<li>vue弹窗后如何禁止滚动条滚动？</li>\n<li>如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件</li>\n</ul>\n<h3 id=\"_28-watch与computed的区别\"> 28 watch与computed的区别</h3>\n<p><strong>computed:</strong></p>\n<ul>\n<li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li>\n<li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景</li>\n</ul>\n<p><strong>watch:</strong></p>\n<ul>\n<li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li>\n<li>无缓存性，页面重新渲染时值不变化也会执行</li>\n</ul>\n<p><strong>小结:</strong></p>\n<ul>\n<li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li>\n<li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li>\n</ul>\n<h3 id=\"_29、vue是如何实现双向绑定的\"> 29、Vue是如何实现双向绑定的?</h3>\n<blockquote>\n<p>利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。</p>\n</blockquote>\n<div><pre><code><span>// 这是将要被劫持的对象</span>\n<span>const</span> data <span>=</span> <span>{</span>\n  name<span>:</span> <span>''</span><span>,</span>\n<span>}</span><span>;</span>\n\n<span>function</span> <span>say</span><span>(</span><span>name</span><span>)</span> <span>{</span>\n  <span>if</span> <span>(</span>name <span>===</span> <span>'古天乐'</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'给大家推荐一款超好玩的游戏'</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>if</span> <span>(</span>name <span>===</span> <span>'渣渣辉'</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'戏我演过很多,可游戏我只玩贪玩懒月'</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'来做我的兄弟'</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 遍历对象,对其属性值进行劫持</span>\nObject<span>.</span><span>keys</span><span>(</span>data<span>)</span><span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>key</span><span>)</span> <span>{</span>\n  Object<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span> key<span>,</span> <span>{</span>\n    enumerable<span>:</span> <span>true</span><span>,</span>\n    configurable<span>:</span> <span>true</span><span>,</span>\n    <span>get</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      console<span>.</span><span>log</span><span>(</span><span>'get'</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n    <span>set</span><span>:</span> <span>function</span><span>(</span><span>newVal</span><span>)</span> <span>{</span>\n      <span>// 当属性值发生变化时我们可以进行额外操作</span>\n      console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>大家好,我系</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>\n      <span>say</span><span>(</span>newVal<span>)</span><span>;</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\ndata<span>.</span>name <span>=</span> <span>'渣渣辉'</span><span>;</span>\n<span>//大家好,我系渣渣辉</span>\n<span>//戏我演过很多,可游戏我只玩贪玩懒月</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h3 id=\"_29-vue2-x-响应式原理\"> 29 Vue2.x 响应式原理</h3>\n<blockquote>\n<p>Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n</blockquote>\n<p><img src=\"/vue/vue6.jpg\" alt=\"img\" /></p>\n<ul>\n<li><code>Observer</code> 遍历数据对象，给所有属性加上 <code>setter</code> 和 <code>getter</code>，监听数据的变化</li>\n<li><code>compile</code> 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>\n</ul>\n<blockquote>\n<p><code>Watcher</code> 订阅者是 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情</p>\n</blockquote>\n<ul>\n<li>在自身实例化时往属性订阅器 (<code>dep</code>) 里面添加自己</li>\n<li>待属性变动 <code>dep.notice()</code> 通知时，调用自身的 <code>update()</code> 方法，并触发 <code>Compile</code> 中绑定的回调</li>\n</ul>\n<p><strong>Vue3.x响应式数据原理：</strong></p>\n<blockquote>\n<p><code>Vue3.x</code>改用P<code>roxy</code>替代<code>Object.defineProperty</code>。因为P<code>roxy</code>可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p>\n</blockquote>\n<p><code>Proxy</code>只会代理对象的第一层，那么<code>Vue3</code>又是怎样处理这个问题的呢？</p>\n<blockquote>\n<p>判断当前<code>Reflect.get的</code>返回值是否为<code>Object</code>，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p>\n</blockquote>\n<p><strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong></p>\n<blockquote>\n<p>我们可以判断<code>key</code>是否为当前被代理对象<code>target</code>自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行<code>trigger</code></p>\n</blockquote>\n<h3 id=\"_30-v-model双向绑定原理\"> 30 v-model双向绑定原理</h3>\n<blockquote>\n<p><code>v-model</code>本质上是语法糖，<code>v-model</code>在内部为不同的输入元素使用不同的属性并抛出不同的事件</p>\n</blockquote>\n<ul>\n<li><code>text</code> 和 <code>textarea</code> 元素使用 value 属性和 input 事件</li>\n<li><code>checkbox</code> 和 <code>radio</code> 使用 checked 属性和 change 事件</li>\n<li><code>select</code> 字段将 value 作为 prop 并将 change 作为事件</li>\n</ul>\n<p><strong>所以我们可以v-model进行如下改写：</strong></p>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>v-model</span><span><span>=</span><span>\"</span>sth<span>\"</span></span> <span>/></span></span>//  等同于<span><span><span>&lt;</span>input</span> <span>:value</span><span><span>=</span><span>\"</span>sth<span>\"</span></span> <span>@input</span><span><span>=</span><span>\"</span>sth = $event.target.value<span>\"</span></span> <span>/></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>这个语法糖必须是固定的，也就是说属性必须为<code>value</code>，方法名必须为：<code>input</code>。</li>\n<li>知道了<code>v-model</code>的原理，我们可以在自定义组件上实现<code>v-model</code></li>\n</ul>\n<div><pre><code><span>//Parent</span>\n<span>&lt;</span>template<span>></span>\n    <span>{</span><span>{</span>num<span>}</span><span>}</span>\n    <span>&lt;</span>Child v<span>-</span>model<span>=</span><span>\"num\"</span><span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n<span>export</span> <span>default</span> <span>{</span>\n    <span>data</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> <span>{</span>\n            num<span>:</span> <span>0</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//Child</span>\n<span>&lt;</span>template<span>></span>\n    <span>&lt;</span>div @click<span>=</span><span>\"add\"</span><span>></span>Add<span>&lt;</span><span>/</span>div<span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n<span>export</span> <span>default</span> <span>{</span>\n    props<span>:</span> <span>[</span><span>'value'</span><span>]</span><span>,</span>\n    methods<span>:</span><span>{</span>\n        <span>add</span><span>(</span><span>)</span><span>{</span>\n            <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'input'</span><span>,</span> <span>this</span><span>.</span>value <span>+</span> <span>1</span><span>)</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"_31-scoped样式穿透\"> 31 scoped样式穿透</h3>\n<blockquote>\n<p><code>scoped</code>虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除<code>scoped</code>属性</p>\n</blockquote>\n<ol>\n<li>使用<code>/deep/</code></li>\n</ol>\n<div><pre><code><span>//Parent</span>\n<span>&lt;</span>template<span>></span>\n<span>&lt;</span>div <span>class</span><span>=</span><span>\"wrap\"</span><span>></span>\n    <span>&lt;</span>Child <span>/</span><span>></span>\n<span>&lt;</span><span>/</span>div<span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n\n<span>&lt;</span>style lang<span>=</span><span>\"scss\"</span> scoped<span>></span>\n<span>.</span>wrap <span>/</span>deep<span>/</span> <span>.</span>box<span>{</span>\n  background<span>:</span> red<span>;</span>\n<span>}</span>\n<span>&lt;</span><span>/</span>style<span>></span>\n\n<span>//Child</span>\n<span>&lt;</span>template<span>></span>\n  <span>&lt;</span>div <span>class</span><span>=</span><span>\"box\"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ol>\n<li>使用两个style标签</li>\n</ol>\n<div><pre><code><span>//Parent</span>\n<span>&lt;</span>template<span>></span>\n<span>&lt;</span>div <span>class</span><span>=</span><span>\"wrap\"</span><span>></span>\n  <span>&lt;</span>Child <span>/</span><span>></span>\n<span>&lt;</span><span>/</span>div<span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n\n<span>&lt;</span>style lang<span>=</span><span>\"scss\"</span> scoped<span>></span>\n<span>//其他样式</span>\n<span>&lt;</span><span>/</span>style<span>></span>\n<span>&lt;</span>style lang<span>=</span><span>\"scss\"</span><span>></span>\n<span>.</span>wrap <span>.</span>box<span>{</span>\n  background<span>:</span> red<span>;</span>\n<span>}</span>\n<span>&lt;</span><span>/</span>style<span>></span>\n\n<span>//Child</span>\n<span>&lt;</span>template<span>></span>\n  <span>&lt;</span>div <span>class</span><span>=</span><span>\"box\"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>\n<span>&lt;</span><span>/</span>template<span>></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_32-ref的作用\"> 32 ref的作用</h3>\n<ul>\n<li>获取<code>dom</code>元素<code>this.$refs.box</code></li>\n<li>获取子组件中的<code>datathis.$refs.box.msg</code></li>\n<li>调用子组件中的方法<code>this.$refs.box.open()</code></li>\n</ul>\n<h3 id=\"_33-computed和watch区别\"> 33 computed和watch区别</h3>\n<ol>\n<li>当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed</li>\n</ol>\n<blockquote>\n<p><code>Computed</code>本质是一个具备缓存的<code>watcher</code>，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理</p>\n</blockquote>\n<p><img src=\"/vue/vue7.png\" alt=\"img\" /></p>\n<div><pre><code><span>&lt;</span>template<span>></span><span>{</span><span>{</span>fullName<span>}</span><span>}</span><span>&lt;</span><span>/</span>template<span>></span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span><span>{</span>\n    <span>return</span> <span>{</span>\n      firstName<span>:</span> <span>'xie'</span><span>,</span>\n      lastName<span>:</span> <span>'yu fei'</span><span>,</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  computed<span>:</span><span>{</span>\n    <span>fullName</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n      <span>return</span> <span>this</span><span>.</span>firstName <span>+</span> <span>' '</span> <span>+</span> <span>this</span><span>.</span>lastName\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol>\n<li><code>watch</code>用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么<code>watch</code>为最佳选择</li>\n</ol>\n<blockquote>\n<p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用<code>unWatch</code>手动注销</p>\n</blockquote>\n<p><img src=\"/vue/vue8.png\" alt=\"img\" /></p>\n<div><pre><code><span>&lt;</span>template<span>></span><span>{</span><span>{</span>fullName<span>}</span><span>}</span><span>&lt;</span><span>/</span>template<span>></span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>(</span><span>)</span><span>{</span>\n    <span>return</span> <span>{</span>\n      firstName<span>:</span> <span>'xie'</span><span>,</span>\n      lastName<span>:</span> <span>'xiao fei'</span><span>,</span>\n      fullName<span>:</span> <span>'xie xiao fei'</span>\n    <span>}</span>\n  <span>}</span><span>,</span>\n  watch<span>:</span><span>{</span>\n    <span>firstName</span><span>(</span><span>val</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>fullName <span>=</span> val <span>+</span> <span>' '</span> <span>+</span> <span>this</span><span>.</span>lastName\n    <span>}</span><span>,</span>\n    <span>lastName</span><span>(</span><span>val</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>fullName <span>=</span> <span>this</span><span>.</span>firstName <span>+</span> <span>' '</span> <span>+</span> val\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_34-vue-router守卫\"> 34 vue-router守卫</h3>\n<blockquote>\n<p>导航守卫 <code>router.beforeEach</code> 全局前置守卫</p>\n</blockquote>\n<ul>\n<li><code>to: Route</code>: 即将要进入的目标（路由对象）</li>\n<li><code>from: Route</code>: 当前导航正要离开的路由</li>\n<li><code>next: Function</code>: 一定要调用该方法来 <code>resolve</code> 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）</li>\n<li>执行效果依赖 next 方法的调用参数。</li>\n<li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li>\n<li><code>next(false)</code>:取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)</li>\n</ul>\n<div><pre><code><span>// main.js 入口文件</span>\n<span>import</span> router <span>from</span> <span>'./router'</span><span>;</span> <span>// 引入路由</span>\nrouter<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span> \n  <span>next</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\nrouter<span>.</span><span>beforeResolve</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>\n  <span>next</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\nrouter<span>.</span><span>afterEach</span><span>(</span><span>(</span><span>to<span>,</span> <span>from</span></span><span>)</span> <span>=></span> <span>{</span>\n  console<span>.</span><span>log</span><span>(</span><span>'afterEach 全局后置钩子'</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>路由独享的守卫 你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫</p>\n</blockquote>\n<div><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>\n  routes<span>:</span> <span>[</span>\n    <span>{</span>\n      path<span>:</span> <span>'/foo'</span><span>,</span>\n      component<span>:</span> Foo<span>,</span>\n      <span>beforeEnter</span><span>:</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>\n        <span>// ...</span>\n      <span>}</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>组件内的守卫你可以在路由组件内直接定义以下路由导航守卫</p>\n</blockquote>\n<div><pre><code><span>const</span> Foo <span>=</span> <span>{</span>\n  template<span>:</span> <span><span>`</span><span>...</span><span>`</span></span><span>,</span>\n  <span>beforeRouteEnter</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>\n    <span>// 在渲染该组件的对应路由被 confirm 前调用</span>\n    <span>// 不！能！获取组件实例 `this`</span>\n    <span>// 因为当守卫执行前，组件实例还没被创建</span>\n  <span>}</span><span>,</span>\n  <span>beforeRouteUpdate</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>\n    <span>// 在当前路由改变，但是该组件被复用时调用</span>\n    <span>// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>\n    <span>// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>\n    <span>// 可以访问组件实例 `this`</span>\n  <span>}</span><span>,</span>\n  <span>beforeRouteLeave</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>\n    <span>// 导航离开该组件的对应路由时调用，我们用它来禁止用户离开</span>\n    <span>// 可以访问组件实例 `this`</span>\n    <span>// 比如还未保存草稿，或者在用户离开前，</span>\n    将setInterval销毁，防止离开之后，定时器还在调用。\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_35-vue修饰符\"> 35 vue修饰符</h3>\n<ul>\n<li><code>stop</code>：阻止事件的冒泡</li>\n<li><code>prevent</code>：阻止事件的默认行为</li>\n<li><code>once</code>：只触发一次</li>\n<li><code>self</code>：只触发自己的事件行为时，才会执行</li>\n</ul>\n<h3 id=\"_36-vue项目中的性能优化\"> 36 vue项目中的性能优化</h3>\n<ul>\n<li>不要在模板里面写过多表达式</li>\n<li>循环调用子组件时添加key</li>\n<li>频繁切换的使用v-show，不频繁切换的使用v-if</li>\n<li>尽量少用float，可以用flex</li>\n<li>按需加载，可以用require或者import()按需加载需要的组件</li>\n<li>路由懒加载</li>\n</ul>\n<h3 id=\"_37-vue-extend和vue-component\"> 37 vue.extend和vue.component</h3>\n<ul>\n<li><code>extend</code>是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li>\n<li><code>Vue.component</code>你可以创建 ，也可以取组件。</li>\n</ul>\n<h3 id=\"_38-vue的spa-如何优化加载速度\"> 38 Vue的SPA 如何优化加载速度</h3>\n<ul>\n<li>减少入口文件体积</li>\n<li>静态资源本地缓存</li>\n<li>开启Gzip压缩</li>\n<li>使用SSR,nuxt.js</li>\n</ul>\n<h3 id=\"_39-移动端如何设计一个比较友好的header组件\"> 39 移动端如何设计一个比较友好的Header组件？</h3>\n<blockquote>\n<p>当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格</p>\n</blockquote>\n<h3 id=\"_40-proxy与object-defineproperty的优劣对比\"> 40 Proxy与Object.defineProperty的优劣对比?</h3>\n<p><strong>Proxy的优势如下:</strong></p>\n<ul>\n<li>Proxy可以直接监听对象而非属性</li>\n<li>Proxy可以直接监听数组的变化</li>\n<li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li>\n<li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li>\n<li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li>\n</ul>\n<p><strong>Object.defineProperty的优势如下:</strong></p>\n<p>兼容性好,支持IE9</p>\n<h3 id=\"_41-你是如何理解vue的响应式系统的\"> 41 你是如何理解Vue的响应式系统的?</h3>\n<p><img src=\"/vue/vue9.png\" alt=\"img\" /></p>\n<p><strong>响应式系统简述:</strong></p>\n<ul>\n<li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li>\n<li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li>\n<li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li>\n<li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li>\n</ul>\n<h3 id=\"_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异\"> 42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</h3>\n<blockquote>\n<p>现代前端框架有两种方式侦测变化,一种是pull一种是push</p>\n</blockquote>\n<ul>\n<li>pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</li>\n<li>push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的</li>\n</ul>\n<h3 id=\"_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期\"> 43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</h3>\n<p>考点: Vue的变化侦测原理</p>\n<p>前置知识: 依赖收集、虚拟DOM、响应式系统</p>\n<blockquote>\n<p>根本原因是Vue与React的变化侦测方式有所不同</p>\n</blockquote>\n<ul>\n<li>React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.</li>\n<li>Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.</li>\n</ul>\n<h3 id=\"_44-vue中的key到底有什么用\"> 44 Vue中的key到底有什么用？</h3>\n<ul>\n<li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li>\n<li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li>\n</ul>\n<blockquote>\n<p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.\n准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code>.</p>\n</blockquote>\n<p><img src=\"/vue/vue1.png\" alt=\"img\" /></p>\n<h3 id=\"_45-vue-项目性能优化\"> 45 vue 项目性能优化</h3>\n<p><strong>代码层面：</strong></p>\n<ul>\n<li>合理使用 <code>v-if</code> 和 <code>v-show</code></li>\n<li>区分 <code>computed</code> 和 <code>watch</code> 的使用</li>\n<li><code>v-for</code> 遍历为 <code>item</code> 添加 <code>key</code></li>\n<li><code>v-for</code> 遍历避免同时使用 <code>v-if</code></li>\n<li>通过 <code>addEventListener</code>添加的事件在组件销毁时要用 <code>removeEventListener</code> 手动移除这些事件的监听</li>\n<li>图片懒加载</li>\n<li>路由懒加载</li>\n<li>第三方插件按需引入</li>\n<li><code>SSR</code>服务端渲染，首屏加载速度快，<code>SEO</code>效果好</li>\n</ul>\n<p><strong>Webpack 层面优化：</strong></p>\n<ul>\n<li>对图片进行压缩</li>\n<li>使用 <code>CommonsChunkPlugin</code> 插件提取公共代码</li>\n<li>提取组件的 CSS</li>\n<li>优化 <code>SourceMap</code></li>\n<li>构建结果输出分析，利用 <code>webpack-bundle-analyzer</code> 可视化分析工具</li>\n</ul>\n<h3 id=\"_46-nexttick\"> 46 nextTick</h3>\n<blockquote>\n<p>nextTick<code>可以让我们在下次</code>DOM<code>更新循环结束之后执行延迟回调，用于获得更新后的</code>DOM</p>\n</blockquote>\n<p><code>nextTick</code>主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>\n<ul>\n<li><code>Promise</code></li>\n<li><code>MutationObserver</code></li>\n<li><code>setImmediate</code></li>\n<li>如果以上都不行则采用<code>setTimeout</code></li>\n</ul>\n<blockquote>\n<p>定义了一个异步方法，多次调用<code>nextTick</code>会将方法存入队列中，通过这个异步方法清空当前队列</p>\n</blockquote>\n<h3 id=\"_47-说一下vue2-x中如何监测数组变化\"> 47 说一下vue2.x中如何监测数组变化</h3>\n<blockquote>\n<p>使用了函数劫持的方式，重写了数组的方法，<code>Vue</code>将<code>data</code>中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>\n</blockquote>\n<h3 id=\"_48-你的接口请求一般放在哪个生命周期中\"> 48 你的接口请求一般放在哪个生命周期中</h3>\n<blockquote>\n<p>接口请求一般放在<code>mounted</code>中，但需要注意的是服务端渲染时不支持<code>mounted</code>，需要放到<code>created</code>中</p>\n</blockquote>\n<h3 id=\"_49-组件中的data为什么是一个函数\"> 49 组件中的data为什么是一个函数</h3>\n<blockquote>\n<p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果<code>data</code>是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间d<code>ata</code>不冲突，data必须是一个函数</p>\n</blockquote>\n<h3 id=\"_50-说一下v-model的原理\"> 50 说一下v-model的原理</h3>\n<blockquote>\n<p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value + input</code>方法的语法糖。 可以通过<code>model</code>属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的<code>v-model</code>，会根据标签的不同生成不同的事件和属性</p>\n</blockquote>\n<h3 id=\"_51-vue事件绑定原理说一下\"> 51 Vue事件绑定原理说一下</h3>\n<blockquote>\n<p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过<code>Vue</code>自定义的<code>$on</code>实现的</p>\n</blockquote>\n<h3 id=\"_52-vue模版编译原理知道吗-能简单说一下吗\"> 52 Vue模版编译原理知道吗，能简单说一下吗？</h3>\n<blockquote>\n<p>简单说，<code>Vue</code>的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p>\n</blockquote>\n<ul>\n<li>生成<code>AST</code>树</li>\n<li>优化</li>\n<li><code>codegen</code></li>\n<li>首先解析模版，生成<code>AST</code>语法树(一种用J<code>avaScript</code>对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</li>\n<li><code>Vue</code>的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li>\n<li>编译的最后一步是将优化后的<code>AST</code>树转换为可执行的代码</li>\n</ul>\n<h3 id=\"_53-vue2-x和vue3-x渲染器的diff算法分别说一下\"> 53 Vue2.x和Vue3.x渲染器的diff算法分别说一下</h3>\n<blockquote>\n<p>简单来说，<code>diff</code>算法有以下过程</p>\n</blockquote>\n<ul>\n<li>同级比较，再比较子节点</li>\n<li>先判断一方有子节点一方没有子节点的情况(如果新的<code>children</code>没有子节点，将旧的子节点移除)</li>\n<li>比较都有子节点的情况(核心<code>diff</code>)</li>\n<li>递归比较子节点</li>\n<li>正常<code>Diff</code>两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行跨层级的移动<code>DOM</code>，所以<code>Vue</code>将<code>Diff</code>进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧<code>children</code>都为多个子节点时才需要用核心的<code>Diff</code>算法进行同层级比较。</li>\n<li><code>Vue2</code>的核心<code>Diff</code>算法采用了双端比较的算法，同时从新旧<code>children</code>的两端开始进行比较，借助<code>key</code>值找到可复用的节点，再进行相关操作。相比<code>React</code>的<code>Diff</code>算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅</li>\n<li>在创建<code>VNode</code>时就确定其类型，以及在<code>mount/patch</code>的过程中采用位运算来判断一个<code>VNode</code>的类型，在这个基础之上再配合核心的<code>Diff</code>算法，使得性能上较<code>Vue2.x</code>有了提升</li>\n</ul>\n<h3 id=\"_54-再说一下虚拟dom以及key属性的作用\"> 54 再说一下虚拟Dom以及key属性的作用</h3>\n<ul>\n<li>由于在浏览器中操作<code>DOM</code>是很昂贵的。频繁的操作<code>DOM</code>，会产生一定的性能问题。这就是虚拟Dom的产生原因</li>\n<li><code>Virtual DOM</code>本质就是用一个原生的JS对象去描述一个<code>DOM</code>节点。是对真实DOM的一层抽象</li>\n<li><code>VirtualDOM</code>映射到真实DOM要经历<code>VNode</code>的<code>create</code>、<code>diff</code>、<code>patch</code>等阶段</li>\n</ul>\n<p><strong>key的作用是尽可能的复用 DOM 元素：</strong></p>\n<ul>\n<li>新旧 <code>children</code> 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的</li>\n<li>需要在新旧 <code>children</code> 的节点中保存映射关系，以便能够在旧 <code>children</code> 的节点中找到可复用的节点。<code>key</code>也就是<code>children</code>中节点的唯一标识</li>\n</ul>\n<h3 id=\"_55-vue中组件生命周期调用顺序说一下\"> 55 Vue中组件生命周期调用顺序说一下</h3>\n<ul>\n<li>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</li>\n<li>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</li>\n</ul>\n<p><strong>加载渲染过程：</strong></p>\n<blockquote>\n<p>父beforeCreate<code>-&gt;</code>父created<code>-&gt;</code>父beforeMount<code>-&gt;</code>子beforeCreate<code>-&gt;</code>子created<code>-&gt;</code>子beforeMount<code>- &gt;</code>子mounted<code>-&gt;</code>父mounted</p>\n</blockquote>\n<p><strong>子组件更新过程：</strong></p>\n<blockquote>\n<p>父beforeUpdate<code>-&gt;</code>子beforeUpdate<code>-&gt;</code>子updated<code>-&gt;</code>父updated</p>\n</blockquote>\n<p><strong>父组件更新过程：</strong></p>\n<blockquote>\n<p>父 beforeUpdate<code>-&gt;</code>父 updated</p>\n</blockquote>\n<p><strong>销毁过程：</strong></p>\n<blockquote>\n<p>父beforeDestroy<code>-&gt;</code>子beforeDestroy<code>-&gt;</code>子destroyed<code>-&gt;</code>父destroyed</p>\n</blockquote>\n<h3 id=\"_56-ssr了解吗\"> 56 SSR了解吗</h3>\n<blockquote>\n<p><code>SSR</code>也就是服务端渲染，也就是将<code>Vue</code>在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>\n</blockquote>\n<p><code>SSR</code>有着更好的<code>SEO</code>、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于<code>Node.js</code>的运行环境。还有就是服务器会有更大的负载需求</p>\n<h3 id=\"_57-你都做过哪些vue的性能优化\"> 57 你都做过哪些Vue的性能优化</h3>\n<p><strong>编码阶段：</strong></p>\n<ul>\n<li>尽量减少<code>data</code>中的数据，<code>data</code>中的数据都会增加<code>getter</code>和<code>setter</code>，会收集对应的<code>watcher</code></li>\n<li><code>v-if</code>和<code>v-for</code>不能连用</li>\n<li>如果需要使用<code>v-for</code>给每项元素绑定事件时使用事件代理</li>\n<li><code>SPA</code> 页面采用<code>keep-alive</code>缓存组件</li>\n<li>在更多的情况下，使用<code>v-if</code>替代<code>v-show</code></li>\n<li><code>key</code>保证唯一</li>\n<li>使用路由懒加载、异步组件</li>\n<li>防抖、节流</li>\n<li>第三方模块按需导入</li>\n<li>长列表滚动到可视区域动态加载</li>\n<li>图片懒加载</li>\n</ul>\n<p><strong>SEO优化：</strong></p>\n<ul>\n<li>预渲染</li>\n<li>服务端渲染<code>SSR</code></li>\n</ul>\n<p><strong>打包优化：</strong></p>\n<ul>\n<li>压缩代码</li>\n<li><code>Tree Shaking/Scope Hoisting</code></li>\n<li>使用<code>cdn</code>加载第三方模块</li>\n<li>多线程打包<code>happypack</code></li>\n<li><code>splitChunks</code>抽离公共文件</li>\n<li><code>sourceMap</code>优化</li>\n</ul>\n<p><strong>用户体验：</strong></p>\n<ul>\n<li>骨架屏</li>\n<li><code>PWA</code></li>\n</ul>\n<blockquote>\n<p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启<code>gzip</code>压缩等。</p>\n</blockquote>\n<h3 id=\"_58-vue-js特点\"> 58 Vue.js特点</h3>\n<ul>\n<li>简洁：页面由<code>HTML</code>模板+Json数据+<code>Vue</code>实例组成</li>\n<li>数据驱动：自动计算属性和追踪依赖的模板表达式</li>\n<li>组件化：用可复用、解耦的组件来构造页面</li>\n<li>轻量：代码量小，不依赖其他库</li>\n<li>快速：精确有效批量DOM更新</li>\n<li>模板友好：可通过npm，bower等多种方式安装，很容易融入</li>\n</ul>\n<h3 id=\"_59-请说出vue-cli项目中src目录每个文件夹和文件的用法\"> 59 请说出vue.cli项目中src目录每个文件夹和文件的用法</h3>\n<ul>\n<li><code>assets</code>文件夹是放静态资源；</li>\n<li><code>components</code>是放组件；</li>\n<li><code>router</code>是定义路由相关的配置;</li>\n<li><code>view</code>视图；</li>\n<li><code>app.vue</code>是一个应用主组件；</li>\n<li><code>main.js</code>是入口文件</li>\n</ul>\n<h3 id=\"_60-vue路由传参数\"> 60 vue路由传参数</h3>\n<ul>\n<li>使用<code>query</code>方法传入的参数使用<code>this.$route.query</code>接受</li>\n<li>使用<code>params</code>方式传入的参数使用<code>this.$route.params</code>接受</li>\n</ul>\n<h3 id=\"_61-vuex-是什么-有哪几种属性\"> 61 vuex 是什么？ 有哪几种属性？</h3>\n<blockquote>\n<ul>\n<li><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。</li>\n<li>有 5 种，分别是 <code>state</code>、<code>getter</code>、<code>mutation</code>、<code>action</code>、<code>module</code></li>\n</ul>\n</blockquote>\n<ul>\n<li><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。</li>\n<li>有 5 种，分别是 <code>state</code>、<code>getter</code>、<code>mutation</code>、<code>action</code>、<code>module</code></li>\n<li><code>vuex</code> 的 <code>store</code> 是什么？</li>\n<li><code>vuex</code> 就是一个仓库，仓库里放了很多对象。其中 <code>state</code> 就是数据源存放地，对应于一般 vue 对象里面的 <code>datastate</code> 里面存放的数据是响应式的，<code>vue</code> 组件从 <code>store</code> 读取数据，若是 <code>store</code> 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 <code>mapState</code> 把全局的 <code>state</code> 和 <code>getters</code> 映射到当前组件的 <code>computed</code> 计算属性</li>\n</ul>\n<p><strong>vuex 的 getter 是什么？</strong></p>\n<ul>\n<li><code>getter</code> 可以对 <code>state</code> 进行计算操作，它就是 <code>store</code> 的计算属性虽然在组件内也可以做计算属性，但是 <code>getters</code> 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 <code>getters</code></li>\n</ul>\n<p><strong>vuex 的 mutation 是什么？</strong></p>\n<ul>\n<li>更改<code>Vuex</code>的<code>store</code>中的状态的唯一方法是提交<code>mutation</code></li>\n</ul>\n<p><strong>vuex 的 action 是什么？</strong></p>\n<ul>\n<li><code>action</code> 类似于 <code>muation</code>, 不同在于：<code>action</code> 提交的是 <code>mutation</code>,而不是直接变更状态<code>action</code> 可以包含任意异步操作</li>\n<li><code>vue</code> 中 <code>ajax</code> 请求代码应该写在组件的 <code>methods</code> 中还是 <code>vuex</code> 的 <code>action</code> 中</li>\n<li><code>vuex</code> 的 <code>module</code> 是什么？</li>\n</ul>\n<blockquote>\n<p>面对复杂的应用程序，当管理的状态比较多时；我们需要将<code>vuex</code>的<code>store</code>对象分割成模块(<code>modules</code>)。\n如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 <code>vuex</code> 的 <code>state</code> 里如果被其他地方复用，请将请求放入 <code>action</code> 里，方便复用，并包装成 <code>promise</code> 返回</p>\n</blockquote>\n<h3 id=\"_62-如何让css只在当前组件中起作用\"> 62 如何让CSS只在当前组件中起作用？</h3>\n<blockquote>\n<p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p>\n</blockquote>\n<h3 id=\"_63-delete和vue-delete删除数组的区别\"> 63 delete和Vue.delete删除数组的区别？</h3>\n<ul>\n<li><code>delete</code>只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li>\n<li><code>Vue.delete</code>直接删除了数组 改变了数组的键值。</li>\n</ul>\n<div><pre><code><span>var</span> a<span>=</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span>\n<span>var</span> b<span>=</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span>\n<span>delete</span> a<span>[</span><span>0</span><span>]</span>\nconsole<span>.</span><span>log</span><span>(</span>a<span>)</span>  <span>//[empty,2,3,4]</span>\n<span>this</span><span>.</span>$<span>delete</span><span>(</span>b<span>,</span><span>0</span><span>)</span>\nconsole<span>.</span><span>log</span><span>(</span>b<span>)</span>  <span>//[2,3,4]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_64-v-on可以监听多个方法吗\"> 64 v-on可以监听多个方法吗？</h3>\n<p>可以</p>\n<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>\"</span>text<span>\"</span></span> <span>:value</span><span><span>=</span><span>\"</span>name<span>\"</span></span> <span>@input</span><span><span>=</span><span>\"</span>onInput<span>\"</span></span> <span>@focus</span><span><span>=</span><span>\"</span>onFocus<span>\"</span></span> <span>@blur</span><span><span>=</span><span>\"</span>onBlur<span>\"</span></span> <span>/></span></span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>v-on 常用修饰符：</strong></p>\n<ul>\n<li><code>.stop</code> 该修饰符将阻止事件向上冒泡。同理于调用 <code>event.stopPropagation()</code> 方法</li>\n<li><code>.prevent</code> 该修饰符会阻止当前事件的默认行为。同理于调用 <code>event.preventDefault()</code> 方法</li>\n<li><code>.self</code> 该指令只当事件是从事件绑定的元素本身触发时才触发回调</li>\n<li><code>.once</code> 该修饰符表示绑定的事件只会被触发一次</li>\n</ul>\n<h3 id=\"_65-vue子组件调用父组件的方法\"> 65 Vue子组件调用父组件的方法</h3>\n<ul>\n<li>第一种方法是直接在子组件中通过<code>this.$parent.event</code>来调用父组件的方法</li>\n<li>第二种方法是在子组件里用<code>$emit</code>向父组件触发一个事件，父组件监听这个事件就行了。</li>\n</ul>\n<h3 id=\"_66-vue如何兼容ie的问题\"> 66 vue如何兼容ie的问题</h3>\n<blockquote>\n<p>babel-polyfill插件</p>\n</blockquote>\n<h3 id=\"_67-vue-改变数组触发视图更新\"> 67 Vue 改变数组触发视图更新</h3>\n<blockquote>\n<p>以下方法调用会改变原始数组：<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code>, <code>reverse()</code>,<code>Vue.set( target, key, value )</code></p>\n</blockquote>\n<ul>\n<li>\n<p>调用方法：</p>\n<div><pre><code>Vue<span>.</span><span>set</span><span>(</span> target<span>,</span> key<span>,</span> value <span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li><code>target</code>：要更改的数据源(可以是对象或者数组)</li>\n<li><code>key</code>：要更改的具体数据</li>\n<li><code>value</code> ：重新赋的值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_68-dom-渲染在哪个周期中就已经完成\"> 68 DOM 渲染在哪个周期中就已经完成？</h3>\n<blockquote>\n<p>在<code>mounted</code></p>\n</blockquote>\n<p>注意 <code>mounted</code> 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>mounted</code></p>\n<div><pre><code><span>mounted</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n  <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>// Code that will run only after the</span>\n    <span>// entire view has been rendered</span>\n  <span>}</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_69-简述每个周期具体适合哪些场景\"> 69 简述每个周期具体适合哪些场景</h3>\n<ul>\n<li><code>beforecreate</code> : 可以在这加个<code>loading</code>事件，在加载实例时触发</li>\n<li><code>created</code> : 初始化完成时的事件写在这里，如在这结束<code>loading</code>事件，异步请求也适宜在这里调用</li>\n<li><code>mounted</code> : 挂载元素，获取到DOM节点 <code>updated</code> : 如果对数据统一处理，在这里写上相应函数</li>\n<li><code>beforeDestroy</code> : 可以做一个确认停止事件的确认框</li>\n</ul>\n<p><strong>第一次加载会触发哪几个钩子：</strong></p>\n<blockquote>\n<p>会触发<code>beforeCreate</code> , <code>created</code> ,<code>beforeMount</code> ,<code>mounted</code></p>\n</blockquote>\n<h3 id=\"_70-动态绑定class\"> 70 动态绑定class</h3>\n<blockquote>\n<p><code>active</code> <code>classname</code>， <code>isActive</code> 变量</p>\n</blockquote>\n<div><pre><code><span><span><span>&lt;</span>div</span> <span>:class</span><span><span>=</span><span>\"</span>{ active: isActive }<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br></div></div>",
      "image": "https://github.com/letme350/vue/lifeTime.png",
      "date_published": "2021-07-28T00:00:00.000Z",
      "date_modified": "2021-07-30T15:17:57.534Z",
      "authors": [
        {
          "name": "Promise Li"
        }
      ],
      "tags": [
        "Vue"
      ]
    }
  ]
}